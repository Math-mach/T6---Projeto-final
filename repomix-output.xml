This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.repomixignore
dashboard/backend/auth.py
dashboard/backend/core.py
dashboard/backend/crud.py
dashboard/backend/database.py
dashboard/backend/Dockerfile
dashboard/backend/export_artifacts_target1.py
dashboard/backend/export_artifacts_target2.py
dashboard/backend/export_artifacts_target3.py
dashboard/backend/export_hibrido_target1.py
dashboard/backend/export_hibrido_target2.py
dashboard/backend/export_hibrido_target3.py
dashboard/backend/main.py
dashboard/backend/models.py
dashboard/backend/README.md
dashboard/backend/requirements.txt
dashboard/backend/schemas.py
dashboard/docker-compose.yml
dashboard/frontend/dashboard_dash.py
dashboard/frontend/Dockerfile
dashboard/frontend/README.md
dashboard/frontend/requirements.txt
dashboard/README.md
notebooks/PROJETOFINAL.ipynb
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".repomixignore">
# Arquivos de configuraÃ§Ã£o de ambiente e exemplos
dashboard/.env.example
.env

# Arquivos gerados pelo Git e editores
.gitignore

# Dados de treinamento e artefatos de ML (gerados pelos scripts)
# Ã‰ melhor ignorÃ¡-los se a lÃ³gica principal estÃ¡ nos scripts de exportaÃ§Ã£o
# e no notebook. O repomix jÃ¡ ignora binÃ¡rios como .pkl por padrÃ£o.
dashboard/backend/ml_artifacts/
*.pkl
*.joblib

# Dados brutos e intermediÃ¡rios (se existirem)
notebooks/JogadoresV1.xlsx
Dados_Otimizados_V4.xlsx
Dados_para_modelo.xlsx

# Arquivos de cache e logs do treinamento do CatBoost
dashboard/backend/catboost_info/

# Arquivos de cache do Python
__pycache__/
*.pyc

# Pontos de verificaÃ§Ã£o de notebooks
.ipynb_checkpoints/
</file>

<file path="dashboard/backend/auth.py">
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from datetime import datetime, timedelta
import os
from core import bcrypt # <--- IMPORTAÃ‡ÃƒO CHAVE

SECRET_KEY = os.getenv('JWT_SECRET_KEY', 'default_secret_key')
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="login")

def verify_password(plain_password, hashed_password):
    """Verifica a senha usando bcrypt."""
    # A biblioteca Flask-Bcrypt espera que o hash seja um bytes-like object
    return bcrypt.check_password_hash(hashed_password.encode('utf-8'), plain_password)

def get_password_hash(password):
    """Gera o hash da senha usando bcrypt."""
    return bcrypt.generate_password_hash(password).decode('utf-8')

def create_access_token(data: dict):
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

async def get_current_user_id(token: str = Depends(oauth2_scheme)):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        user_id: str = payload.get("sub")
        if user_id is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception
    return user_id
</file>

<file path="dashboard/backend/core.py">
from fastapi import FastAPI
from flask_bcrypt import Bcrypt

app = FastAPI(title="API do Projeto Daruma")

# Instancia o Bcrypt diretamente, sem associar a um app Flask.
bcrypt = Bcrypt()
</file>

<file path="dashboard/backend/crud.py">
# crud.py
from sqlalchemy.orm import Session
import models
import auth

def get_user_by_username(db: Session, username: str):
    return db.query(models.User).filter(models.User.username == username).first()

def create_user(db: Session, user_schema: models.User):
    hashed_password = auth.get_password_hash(user_schema.password)
    db_user = models.User(username=user_schema.username, password_hash=hashed_password)
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user
</file>

<file path="dashboard/backend/database.py">
# database.py
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
import os

SQLALCHEMY_DATABASE_URL = os.getenv('DATABASE_URL', 'postgresql://user:password@db:5432/daruma_db')

engine = create_engine(SQLALCHEMY_DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

# Dependency para obter a sessÃ£o do DB
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
</file>

<file path="dashboard/backend/export_artifacts_target1.py">
# export_artifacts_target1.py

import pandas as pd
import numpy as np
import os
import pickle
import joblib
import optuna
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import RobustScaler
from sklearn.feature_selection import VarianceThreshold
from sklearn.metrics import r2_score
from catboost import CatBoostRegressor

print("="*80)
print("INICIANDO EXPORTAÃ‡ÃƒO DE ARTEFATOS PARA O TARGET 1")
print("="*80)

# --- 1. CONFIGURAÃ‡Ã•ES ---
ARTIFACTS_PATH = "ml_artifacts"
if not os.path.exists(ARTIFACTS_PATH):
    os.makedirs(ARTIFACTS_PATH)
TARGET = 'Target1'
RAW_DATA_FILE = 'JogadoresV1.xlsx'
RANDOM_STATE = 42

# --- 2. CARREGAMENTO E FEATURE ENGINEERING (LÃ³gica do Notebook Fase 2) ---
print(f"\n[FASE 1] Carregando e processando dados de '{RAW_DATA_FILE}'...")
try:
    df = pd.read_excel(RAW_DATA_FILE)
except FileNotFoundError:
    print(f"âŒ ERRO: Arquivo '{RAW_DATA_FILE}' nÃ£o encontrado.")
    exit()

df.dropna(subset=[TARGET], inplace=True)

# Limpeza e conversÃ£o de tipos
if 'F0103' in df.columns:
    df['F0103'] = pd.to_numeric(df['F0103'].astype(str).str.replace(',', '.'), errors='coerce')

p_cols = [c for c in df.columns if c.startswith('P') and any(char.isdigit() for char in c)]
t_cols = [c for c in df.columns if c.startswith('T') and any(char.isdigit() for char in c)]
f_cols = [c for c in df.columns if c.startswith('F') and len(c) > 1 and any(char.isdigit() for char in c)]

for col in p_cols + t_cols + f_cols:
    df[col] = pd.to_numeric(df[col], errors='coerce')
    df[col].replace(-1, np.nan, inplace=True)

# ImputaÃ§Ã£o com mediana
for col in p_cols + t_cols + f_cols:
    if df[col].isnull().sum() > 0:
        df[col].fillna(df[col].median(), inplace=True)

# Feature Engineering
if 'QtdHorasDormi' in df.columns and 'Acordar' in df.columns:
    df['sono_total'] = df['QtdHorasDormi']
    df['sono_x_acordar'] = df['QtdHorasDormi'] * df['Acordar']

if p_cols:
    df['P_mean'] = df[p_cols].mean(axis=1)
    df['P_std'] = df[p_cols].std(axis=1)

if t_cols:
    df['T_mean'] = df[t_cols].mean(axis=1)

# AgregaÃ§Ãµes conceituais de F
f_sono = [c for c in f_cols if c.startswith('F07')]
if f_sono:
    df['F_sono_mean'] = df[f_sono].mean(axis=1)

print("âœ… Dados processados e features criadas.")

# --- 3. SELEÃ‡ÃƒO DE FEATURES ---
print("\n[FASE 2] Selecionando as melhores features...")
numeric_features = df.select_dtypes(include=np.number).columns.tolist()
features_to_exclude = ['Target1', 'Target2', 'Target3']
feature_candidates = [f for f in numeric_features if f not in features_to_exclude]

X_temp = df[feature_candidates].fillna(0)
selector = VarianceThreshold(threshold=0.01)
selector.fit(X_temp)
feature_cols_var = X_temp.columns[selector.get_support()].tolist()

correlations = [(col, abs(df[col].corr(df[TARGET]))) for col in feature_cols_var]
correlations = [corr for corr in correlations if not np.isnan(corr[1])]
correlations.sort(key=lambda x: x[1], reverse=True)

TOP_K = 30
selected_features = [col for col, _ in correlations[:TOP_K]]

# InteraÃ§Ãµes
top3_features = selected_features[:3]
for i, f1 in enumerate(top3_features):
    for f2 in top3_features[i+1:]:
        interaction_name = f'{f1}_X_{f2}'
        df[interaction_name] = df[f1] * df[f2]
        selected_features.append(interaction_name)

selected_features = list(dict.fromkeys(selected_features))
print(f"âœ… {len(selected_features)} features finais selecionadas para {TARGET}.")

# --- 4. PREPARAÃ‡ÃƒO FINAL E SALVAMENTO DE ARTEFATOS ---
X = df[selected_features]
y = df[TARGET]

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=RANDOM_STATE)

# Scaler
scaler = RobustScaler()
X_train_scaled = scaler.fit_transform(X_train)
joblib.dump(scaler, f'{ARTIFACTS_PATH}/scaler_{TARGET.lower()}.pkl')
print(f"ðŸ’¾ Scaler para {TARGET} salvo em: {ARTIFACTS_PATH}/scaler_{TARGET.lower()}.pkl")

# Lista de Features
with open(f'{ARTIFACTS_PATH}/features_{TARGET.lower()}.pkl', 'wb') as f:
    pickle.dump(selected_features, f)
print(f"ðŸ’¾ Lista de features para {TARGET} salva em: {ARTIFACTS_PATH}/features_{TARGET.lower()}.pkl")

# --- 5. OTIMIZAÃ‡ÃƒO E TREINAMENTO DO MODELO (LÃ³gica do Notebook Fase 3) ---
print(f"\n[FASE 3] Otimizando e treinando o modelo para {TARGET}...")

def objective_t1(trial):
    params = {
        'iterations': 500,
        'learning_rate': trial.suggest_float('learning_rate', 0.01, 0.1, log=True),
        'depth': trial.suggest_int('depth', 3, 6),
        'l2_leaf_reg': trial.suggest_float('l2_leaf_reg', 10, 100, log=True),
        'verbose': False,
        'random_seed': RANDOM_STATE
    }
    model = CatBoostRegressor(**params)
    model.fit(X_train_scaled, y_train, eval_set=[(scaler.transform(X_test), y_test)], early_stopping_rounds=50, verbose=False)
    preds = model.predict(scaler.transform(X_test))
    return r2_score(y_test, preds)

study = optuna.create_study(direction='maximize')
study.optimize(objective_t1, n_trials=50) # 50 trials for a good balance
best_params = study.best_params
best_params['iterations'] = 500 # Re-set iterations
best_params['verbose'] = False
best_params['random_seed'] = RANDOM_STATE

final_model = CatBoostRegressor(**best_params)
final_model.fit(X_train_scaled, y_train)

print(f"âœ… Modelo {TARGET} treinado com RÂ² de {study.best_value:.4f} na otimizaÃ§Ã£o.")

# Salvamento do Modelo
joblib.dump(final_model, f'{ARTIFACTS_PATH}/modelo_{TARGET.lower()}.pkl')
print(f"ðŸ’¾ Modelo para {TARGET} salvo em: {ARTIFACTS_PATH}/modelo_{TARGET.lower()}.pkl")
print("\n--- ConcluÃ­do para Target 1 ---")
</file>

<file path="dashboard/backend/export_artifacts_target2.py">
# export_artifacts_target2.py

import pandas as pd
import numpy as np
import os
import pickle
import joblib
import optuna
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.preprocessing import RobustScaler, PolynomialFeatures
from sklearn.ensemble import RandomForestRegressor, StackingRegressor
from sklearn.linear_model import Ridge
from catboost import CatBoostRegressor
import lightgbm as lgb
import xgboost as xgb

print("="*80)
print("INICIANDO EXPORTAÃ‡ÃƒO DE ARTEFATOS PARA O TARGET 2")
print("="*80)

# --- 1. CONFIGURAÃ‡Ã•ES ---
ARTIFACTS_PATH = "ml_artifacts"
if not os.path.exists(ARTIFACTS_PATH):
    os.makedirs(ARTIFACTS_PATH)
TARGET = 'Target2'
RAW_DATA_FILE = 'JogadoresV1.xlsx'
RANDOM_STATE = 42

# --- 2. CARREGAMENTO E FEATURE ENGINEERING ---
print(f"\n[FASE 1] Carregando e processando dados de '{RAW_DATA_FILE}'...")
try:
    df = pd.read_excel(RAW_DATA_FILE)
except FileNotFoundError:
    print(f"âŒ ERRO: Arquivo '{RAW_DATA_FILE}' nÃ£o encontrado.")
    exit()

df.dropna(subset=[TARGET], inplace=True)

# Limpeza e FE simples
if 'F0103' in df.columns:
    df['F0103'] = pd.to_numeric(df['F0103'].astype(str).str.replace(',', '.'), errors='coerce')
if 'QtdHorasDormi' in df.columns and 'Acordar' in df.columns:
    df['sono_total'] = df['QtdHorasDormi']
    df['sono_x_acordar'] = df['QtdHorasDormi'] * df['Acordar']

p_cols = [c for c in df.columns if c.startswith('P') and any(char.isdigit() for char in c)]
t_cols = [c for c in df.columns if c.startswith('T') and any(char.isdigit() for char in c)]
f_cols = [c for c in df.columns if c.startswith('F') and len(c) > 1 and any(char.isdigit() for char in c)]

for col in p_cols + t_cols + f_cols:
    df[col] = pd.to_numeric(df[col], errors='coerce')

if p_cols:
    df['P_mean'] = df[p_cols].mean(axis=1)
if t_cols:
    df['T_mean'] = df[t_cols].mean(axis=1)
if f_cols:
    df['F_mean'] = df[f_cols].mean(axis=1)

# ImputaÃ§Ã£o final antes de separar
numeric_cols = df.select_dtypes(include=np.number).columns
for col in numeric_cols:
    df[col].fillna(df[col].median(), inplace=True)

print("âœ… Dados processados e features base criadas.")

# --- 3. PREPARAÃ‡ÃƒO E SEPARAÃ‡ÃƒO DE DADOS ---
features_to_exclude = ['Target1', 'Target2', 'Target3', 'CÃ³digo de Acesso', 'Data/Hora Ãšltimo']
initial_features = [col for col in df.columns if col not in features_to_exclude and pd.api.types.is_numeric_dtype(df[col])]

X = df[initial_features]
y = df[TARGET]

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=RANDOM_STATE)

# --- 4. FEATURE ENGINEERING AVANÃ‡ADA E SELEÃ‡ÃƒO ---
print("\n[FASE 2] Criando features polinomiais e selecionando as melhores...")
# Features Polinomiais
rf_poly_selector = RandomForestRegressor(n_estimators=100, random_state=RANDOM_STATE, n_jobs=-1)
rf_poly_selector.fit(X_train, y_train)
importances = pd.Series(rf_poly_selector.feature_importances_, index=X_train.columns).sort_values(ascending=False)
top_features_for_poly = importances.head(15).index.tolist()

poly = PolynomialFeatures(degree=2, include_bias=False, interaction_only=True)
X_train_poly = poly.fit_transform(X_train[top_features_for_poly])
poly_names = [f"poly_{name}" for name in poly.get_feature_names_out(top_features_for_poly)]
X_train_poly_df = pd.DataFrame(X_train_poly, columns=poly_names, index=X_train.index)
X_train_expanded = X_train.join(X_train_poly_df)

# SeleÃ§Ã£o HÃ­brida
correlations = X_train_expanded.corrwith(y_train).abs().sort_values(ascending=False)
top_corr_features = correlations.head(60).index.tolist()
rf_final_selector = RandomForestRegressor(n_estimators=100, random_state=RANDOM_STATE, n_jobs=-1)
rf_final_selector.fit(X_train_expanded, y_train)
importances_final = pd.Series(rf_final_selector.feature_importances_, index=X_train_expanded.columns).sort_values(ascending=False)
top_rf_features = importances_final.head(60).index.tolist()

final_feature_list = list(set(top_corr_features + top_rf_features))
X_train_selected = X_train_expanded[final_feature_list]

print(f"âœ… {len(final_feature_list)} features finais selecionadas para {TARGET}.")

# --- 5. SALVAMENTO DE ARTEFATOS DE PRÃ‰-PROCESSAMENTO ---
# Scaler
scaler = RobustScaler()
scaler.fit(X_train_selected)
joblib.dump(scaler, f'{ARTIFACTS_PATH}/scaler_{TARGET.lower()}.pkl')
print(f"ðŸ’¾ Scaler para {TARGET} salvo.")

# Transformador Polinomial e sua lista de features
joblib.dump(poly, f'{ARTIFACTS_PATH}/poly_transformer_{TARGET.lower()}.pkl')
with open(f'{ARTIFACTS_PATH}/poly_features_list_{TARGET.lower()}.pkl', 'wb') as f:
    pickle.dump(top_features_for_poly, f)
print(f"ðŸ’¾ Transformador polinomial e lista de features para {TARGET} salvos.")

# Lista final de Features
with open(f'{ARTIFACTS_PATH}/features_{TARGET.lower()}.pkl', 'wb') as f:
    pickle.dump(final_feature_list, f)
print(f"ðŸ’¾ Lista final de features para {TARGET} salva.")


# --- 6. OTIMIZAÃ‡ÃƒO E TREINAMENTO DO MODELO STACKING ---
print(f"\n[FASE 3] Otimizando modelos base e treinando o Stacking para {TARGET}...")

def tune_model(model_name, X, y):
    def objective(trial):
        if model_name == 'catboost':
            params = {'iterations': trial.suggest_int('iterations', 100, 500), 'depth': trial.suggest_int('depth', 3, 7), 'learning_rate': trial.suggest_float('learning_rate', 0.01, 0.3, log=True), 'l2_leaf_reg': trial.suggest_float('l2_leaf_reg', 2, 20, log=True), 'verbose': 0}
            model = CatBoostRegressor(**params, random_state=RANDOM_STATE)
        # Adicione lgb e xgb se necessÃ¡rio
        score = cross_val_score(model, X, y, cv=3, scoring='r2', n_jobs=-1).mean()
        return score
    
    study = optuna.create_study(direction='maximize')
    study.optimize(objective, n_trials=30)
    print(f"  - Melhor RÂ² CV para {model_name}: {study.best_value:.4f}")
    return study.best_params

best_catboost_params = tune_model('catboost', scaler.transform(X_train_selected), y_train)

base_models = [
    ('catboost', CatBoostRegressor(**best_catboost_params, verbose=0, random_state=RANDOM_STATE)),
    ('random_forest', RandomForestRegressor(n_estimators=150, random_state=RANDOM_STATE))
]
meta_model = Ridge(random_state=RANDOM_STATE)
stacking_model = StackingRegressor(estimators=base_models, final_estimator=meta_model, cv=5, n_jobs=-1)

stacking_model.fit(scaler.transform(X_train_selected), y_train)
print(f"âœ… Modelo Stacking para {TARGET} treinado.")

# Salvamento do Modelo
joblib.dump(stacking_model, f'{ARTIFACTS_PATH}/modelo_{TARGET.lower()}.pkl')
print(f"ðŸ’¾ Modelo para {TARGET} salvo em: {ARTIFACTS_PATH}/modelo_{TARGET.lower()}.pkl")
print("\n--- ConcluÃ­do para Target 2 ---")
</file>

<file path="dashboard/backend/export_artifacts_target3.py">
# export_artifacts_target3.py

import pandas as pd
import numpy as np
import os
import pickle
import joblib
import optuna
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.preprocessing import RobustScaler, PolynomialFeatures
from sklearn.ensemble import RandomForestRegressor, StackingRegressor
from sklearn.linear_model import Ridge
from catboost import CatBoostRegressor
import lightgbm as lgb
import xgboost as xgb

print("="*80)
print("INICIANDO EXPORTAÃ‡ÃƒO DE ARTEFATOS PARA O TARGET 3")
print("="*80)

# --- 1. CONFIGURAÃ‡Ã•ES ---
ARTIFACTS_PATH = "ml_artifacts"
if not os.path.exists(ARTIFACTS_PATH):
    os.makedirs(ARTIFACTS_PATH)
TARGET = 'Target3' # <- ALTERADO
RAW_DATA_FILE = 'JogadoresV1.xlsx'
RANDOM_STATE = 42

# --- 2. CARREGAMENTO E FEATURE ENGINEERING ---
print(f"\n[FASE 1] Carregando e processando dados de '{RAW_DATA_FILE}'...")
try:
    df = pd.read_excel(RAW_DATA_FILE)
except FileNotFoundError:
    print(f"âŒ ERRO: Arquivo '{RAW_DATA_FILE}' nÃ£o encontrado.")
    exit()

df.dropna(subset=[TARGET], inplace=True)

# Limpeza e FE simples
if 'F0103' in df.columns:
    df['F0103'] = pd.to_numeric(df['F0103'].astype(str).str.replace(',', '.'), errors='coerce')
if 'QtdHorasDormi' in df.columns and 'Acordar' in df.columns:
    df['sono_total'] = df['QtdHorasDormi']
    df['sono_x_acordar'] = df['QtdHorasDormi'] * df['Acordar']

p_cols = [c for c in df.columns if c.startswith('P') and any(char.isdigit() for char in c)]
t_cols = [c for c in df.columns if c.startswith('T') and any(char.isdigit() for char in c)]
f_cols = [c for c in df.columns if c.startswith('F') and len(c) > 1 and any(char.isdigit() for char in c)]

for col in p_cols + t_cols + f_cols:
    df[col] = pd.to_numeric(df[col], errors='coerce')

if p_cols:
    df['P_mean'] = df[p_cols].mean(axis=1)
if t_cols:
    df['T_mean'] = df[t_cols].mean(axis=1)
if f_cols:
    df['F_mean'] = df[f_cols].mean(axis=1)

# ImputaÃ§Ã£o final antes de separar
numeric_cols = df.select_dtypes(include=np.number).columns
for col in numeric_cols:
    df[col].fillna(df[col].median(), inplace=True)

print("âœ… Dados processados e features base criadas.")

# --- 3. PREPARAÃ‡ÃƒO E SEPARAÃ‡ÃƒO DE DADOS ---
features_to_exclude = ['Target1', 'Target2', 'Target3', 'CÃ³digo de Acesso', 'Data/Hora Ãšltimo']
initial_features = [col for col in df.columns if col not in features_to_exclude and pd.api.types.is_numeric_dtype(df[col])]

X = df[initial_features]
y = df[TARGET]

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=RANDOM_STATE)

# --- 4. FEATURE ENGINEERING AVANÃ‡ADA E SELEÃ‡ÃƒO ---
print("\n[FASE 2] Criando features polinomiais e selecionando as melhores...")
# Features Polinomiais
rf_poly_selector = RandomForestRegressor(n_estimators=100, random_state=RANDOM_STATE, n_jobs=-1)
rf_poly_selector.fit(X_train, y_train)
importances = pd.Series(rf_poly_selector.feature_importances_, index=X_train.columns).sort_values(ascending=False)
top_features_for_poly = importances.head(15).index.tolist()

poly = PolynomialFeatures(degree=2, include_bias=False, interaction_only=True)
X_train_poly = poly.fit_transform(X_train[top_features_for_poly])
poly_names = [f"poly_{name}" for name in poly.get_feature_names_out(top_features_for_poly)]
X_train_poly_df = pd.DataFrame(X_train_poly, columns=poly_names, index=X_train.index)
X_train_expanded = X_train.join(X_train_poly_df)

# SeleÃ§Ã£o HÃ­brida
correlations = X_train_expanded.corrwith(y_train).abs().sort_values(ascending=False)
top_corr_features = correlations.head(60).index.tolist()
rf_final_selector = RandomForestRegressor(n_estimators=100, random_state=RANDOM_STATE, n_jobs=-1)
rf_final_selector.fit(X_train_expanded, y_train)
importances_final = pd.Series(rf_final_selector.feature_importances_, index=X_train_expanded.columns).sort_values(ascending=False)
top_rf_features = importances_final.head(60).index.tolist()

final_feature_list = list(set(top_corr_features + top_rf_features))
X_train_selected = X_train_expanded[final_feature_list]

print(f"âœ… {len(final_feature_list)} features finais selecionadas para {TARGET}.")

# --- 5. SALVAMENTO DE ARTEFATOS DE PRÃ‰-PROCESSAMENTO ---
# Scaler
scaler = RobustScaler()
scaler.fit(X_train_selected)
joblib.dump(scaler, f'{ARTIFACTS_PATH}/scaler_{TARGET.lower()}.pkl') # <- NOME ALTERADO
print(f"ðŸ’¾ Scaler para {TARGET} salvo.")

# Transformador Polinomial e sua lista de features
joblib.dump(poly, f'{ARTIFACTS_PATH}/poly_transformer_{TARGET.lower()}.pkl') # <- NOME ALTERADO
with open(f'{ARTIFACTS_PATH}/poly_features_list_{TARGET.lower()}.pkl', 'wb') as f: # <- NOME ALTERADO
    pickle.dump(top_features_for_poly, f)
print(f"ðŸ’¾ Transformador polinomial e lista de features para {TARGET} salvos.")

# Lista final de Features
with open(f'{ARTIFACTS_PATH}/features_{TARGET.lower()}.pkl', 'wb') as f: # <- NOME ALTERADO
    pickle.dump(final_feature_list, f)
print(f"ðŸ’¾ Lista final de features para {TARGET} salva.")


# --- 6. OTIMIZAÃ‡ÃƒO E TREINAMENTO DO MODELO STACKING ---
print(f"\n[FASE 3] Otimizando modelos base e treinando o Stacking para {TARGET}...")

def tune_model(model_name, X, y):
    def objective(trial):
        if model_name == 'catboost':
            params = {'iterations': trial.suggest_int('iterations', 100, 500), 'depth': trial.suggest_int('depth', 3, 7), 'learning_rate': trial.suggest_float('learning_rate', 0.01, 0.3, log=True), 'l2_leaf_reg': trial.suggest_float('l2_leaf_reg', 2, 20, log=True), 'verbose': 0}
            model = CatBoostRegressor(**params, random_state=RANDOM_STATE)
        score = cross_val_score(model, X, y, cv=3, scoring='r2', n_jobs=-1).mean()
        return score
    
    study = optuna.create_study(direction='maximize')
    study.optimize(objective, n_trials=30)
    print(f"  - Melhor RÂ² CV para {model_name}: {study.best_value:.4f}")
    return study.best_params

best_catboost_params = tune_model('catboost', scaler.transform(X_train_selected), y_train)

base_models = [
    ('catboost', CatBoostRegressor(**best_catboost_params, verbose=0, random_state=RANDOM_STATE)),
    ('random_forest', RandomForestRegressor(n_estimators=150, random_state=RANDOM_STATE))
]
meta_model = Ridge(random_state=RANDOM_STATE)
stacking_model = StackingRegressor(estimators=base_models, final_estimator=meta_model, cv=5, n_jobs=-1)

stacking_model.fit(scaler.transform(X_train_selected), y_train)
print(f"âœ… Modelo Stacking para {TARGET} treinado.")

# Salvamento do Modelo
joblib.dump(stacking_model, f'{ARTIFACTS_PATH}/modelo_{TARGET.lower()}.pkl') # <- NOME ALTERADO
print(f"ðŸ’¾ Modelo para {TARGET} salvo em: {ARTIFACTS_PATH}/modelo_{TARGET.lower()}.pkl")
print("\n--- ConcluÃ­do para Target 3 ---")
</file>

<file path="dashboard/backend/export_hibrido_target1.py">
# =============================================================================
# EXPORT HÃBRIDO - TARGET 1 (R1)
# =============================================================================
# Este script replica a SEÃ‡ÃƒO 2 do notebook hÃ­brido definitivo
# Treina o modelo R1 e salva os artefatos necessÃ¡rios para a API

import pandas as pd
import numpy as np
import warnings
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.preprocessing import RobustScaler
from sklearn.feature_selection import VarianceThreshold
from catboost import CatBoostRegressor
import optuna
import joblib
import pickle
import os

warnings.filterwarnings('ignore')
optuna.logging.set_verbosity(optuna.logging.WARNING)

# ConfiguraÃ§Ã£o de caminhos
ARTIFACTS_PATH = 'ml_artifacts'
os.makedirs(ARTIFACTS_PATH, exist_ok=True)

print("=" * 100)
print("ðŸŽ¯ TREINAMENTO TARGET 1 (R1) - MODELO HÃBRIDO".center(100))
print("=" * 100)

# =============================================================================
# CARREGAMENTO E PRÃ‰-PROCESSAMENTO
# =============================================================================

df_raw = pd.read_excel('JogadoresV3.xlsx')
df = df_raw.copy()

print(f"\nâœ… Dados carregados: {len(df)} linhas")

# Converter F0103
if 'F0103' in df.columns:
    df['F0103'] = pd.to_numeric(df['F0103'].astype(str).str.replace(',', '.'), errors='coerce')

# Identificar colunas P, T, F
p_cols = [col for col in df.columns if col.startswith('P') and any(c.isdigit() for c in col)]
t_cols = [col for col in df.columns if col.startswith('T') and any(c.isdigit() for c in col)]
f_cols = [col for col in df.columns if col.startswith('F') and len(col) > 1 and any(c.isdigit() for c in col)]

# Tratar colunas duplicadas
print("\n[1/6] Tratando colunas duplicadas...")
cols = pd.Series(df.columns)
duplicated_cols = cols[cols.duplicated()].unique()

if len(duplicated_cols) > 0:
    for dup in duplicated_cols:
        indices = cols[cols == dup].index.tolist()
        for i, idx in enumerate(indices):
            cols.iloc[idx] = f'{dup}_{i}'
    df.columns = cols
    # Atualizar listas de colunas
    p_cols = [col for col in df.columns if col.startswith('P') and any(c.isdigit() for c in col)]
    t_cols = [col for col in df.columns if col.startswith('T') and any(c.isdigit() for c in col)]
    f_cols = [col for col in df.columns if col.startswith('F') and len(col) > 1 and any(c.isdigit() for c in col)]
    print(f"  âœ… Colunas duplicadas renomeadas")
else:
    print("  âœ… Sem duplicatas")

# Converter para numÃ©rico
for col in p_cols + t_cols + f_cols:
    if col in df.columns:
        df[col] = pd.to_numeric(df[col], errors='coerce')

# Remover outliers extremos
numeric_cols = [col for col in df.select_dtypes(include=[np.number]).columns if 'Target' not in col]
for col in numeric_cols:
    if col in df.columns:
        df.loc[df[col] < -100, col] = np.nan
        if df[col].max() > 10000:
            df.loc[df[col] > 10000, col] = np.nan

# =============================================================================
# FEATURE ENGINEERING
# =============================================================================

print("\n[2/6] Criando features comportamentais...")

# Taxa de pulos (-1)
p_minus_ones = sum((df[col] == -1).sum() for col in p_cols if col in df.columns)
t_minus_ones = sum((df[col] == -1).sum() for col in t_cols if col in df.columns)

df['taxa_pulos_P'] = p_minus_ones / len(p_cols) if len(p_cols) > 0 else 0
df['taxa_pulos_T'] = t_minus_ones / len(t_cols) if len(t_cols) > 0 else 0
df['taxa_pulos_geral'] = (p_minus_ones + t_minus_ones) / (len(p_cols) + len(t_cols))

# Substituir -1 por NaN e preencher com mediana
for col in p_cols + t_cols + f_cols:
    if col in df.columns:
        df[col] = df[col].replace(-1, np.nan)
        df[col] = df[col].replace(-1.0, np.nan)
        if df[col].isnull().sum() > 0:
            df[col].fillna(df[col].median(), inplace=True)

print("\n[3/6] Feature engineering avanÃ§ado...")

# Features de SONO
if 'QtdHorasDormi' in df.columns and 'Acordar' in df.columns:
    df['sono_total'] = df['QtdHorasDormi']
    df['sono_x_acordar'] = df['QtdHorasDormi'] * df['Acordar']
    df['sono_squared'] = df['QtdHorasDormi'] ** 2
    df['sono_irregular'] = np.abs(df['QtdHorasDormi'] - df['QtdHorasDormi'].median())
    print(f"  âœ… Sono: 4 features")

# Features de PERFORMANCE
if len(p_cols) > 0:
    df['P_mean'] = df[p_cols].mean(axis=1)
    df['P_std'] = df[p_cols].std(axis=1)
    df['P_min'] = df[p_cols].min(axis=1)
    df['P_max'] = df[p_cols].max(axis=1)
    df['P_range'] = df['P_max'] - df['P_min']
    df['P_late'] = df[['P09', 'P12', 'P13', 'P15']].mean(axis=1) if all(c in df.columns for c in ['P09', 'P12', 'P13', 'P15']) else 0
    df['P_early'] = df[['P01', 'P02', 'P03', 'P04']].mean(axis=1) if all(c in df.columns for c in ['P01', 'P02', 'P03', 'P04']) else 0
    print(f"  âœ… Performance: 7 features")

# Features de TEMPO
if len(t_cols) > 0:
    df['T_mean'] = df[t_cols].mean(axis=1)
    df['T_std'] = df[t_cols].std(axis=1)
    df['T_min'] = df[t_cols].min(axis=1)
    df['T_max'] = df[t_cols].max(axis=1)
    print(f"  âœ… Tempo: 4 features")

# Features de FORMULÃRIOS
f_perfil = [c for c in f_cols if c.startswith('F01') or c.startswith('F02')]
if len(f_perfil) > 0:
    df['F_perfil_mean'] = df[f_perfil].mean(axis=1)
    df['F_perfil_std'] = df[f_perfil].std(axis=1)

f_sono = [c for c in f_cols if c.startswith('F07')]
if len(f_sono) > 0:
    df['F_sono_mean'] = df[f_sono].mean(axis=1)
    df['F_sono_std'] = df[f_sono].std(axis=1)

f_final = [c for c in f_cols if c.startswith('F11')]
if len(f_final) > 0:
    df['F_final_mean'] = df[f_final].mean(axis=1)
    df['F_final_std'] = df[f_final].std(axis=1)

df['F_mean_geral'] = df[f_cols].mean(axis=1)

# =============================================================================
# SELEÃ‡ÃƒO DE FEATURES
# =============================================================================

print("\n[4/6] Selecionando TOP features...")

TARGET = 'Target1'
feature_cols = [col for col in df.columns if col not in [TARGET, 'CÃ³digo de Acesso', 'Data/Hora Ãšltimo', 'Target2', 'Target3']
                and pd.api.types.is_numeric_dtype(df[col])]

X = df[feature_cols].fillna(0)
y = df[TARGET]

# Variance Threshold
selector = VarianceThreshold(threshold=0.01)
selector.fit(X)
feature_cols = X.columns[selector.get_support()].tolist()
X = df[feature_cols]

# CorrelaÃ§Ã£o com target
correlations = []
for col in feature_cols:
    corr = abs(df[col].corr(df[TARGET]))
    if not np.isnan(corr):
        correlations.append((col, corr))

correlations.sort(key=lambda x: x[1], reverse=True)

# TOP 30 features
TOP_K = min(30, len(correlations))
selected_features_r1 = [col for col, _ in correlations[:TOP_K]]

print(f"  âœ… {TOP_K} features selecionadas")

# Criar interaÃ§Ãµes entre TOP 3
top3_features = [col for col, _ in correlations[:3]]
interaction_features = []

for i, f1 in enumerate(top3_features):
    for f2 in top3_features[i+1:]:
        interaction_name = f'{f1}_X_{f2}'
        df[interaction_name] = df[f1] * df[f2]
        interaction_features.append(interaction_name)

selected_features_r1.extend(interaction_features)
selected_features_r1 = list(dict.fromkeys(selected_features_r1))

print(f"  Total com interaÃ§Ãµes: {len(selected_features_r1)}")

# =============================================================================
# PREPARAÃ‡ÃƒO DOS DADOS
# =============================================================================

print("\n[5/6] Preparando dados para treinamento...")

# Scaler
scaler_r1 = RobustScaler()
X_final = df[selected_features_r1].copy().fillna(0)
X_scaled = scaler_r1.fit_transform(X_final)

X_r1 = X_scaled
y_r1 = df[TARGET].values

# Remover NaNs
valid_idx = ~np.isnan(y_r1)
X_r1 = X_r1[valid_idx]
y_r1 = y_r1[valid_idx]

# Split
X_train_r1, X_test_r1, y_train_r1, y_test_r1 = train_test_split(X_r1, y_r1, test_size=0.25, random_state=42)

print(f"  Treino: {len(X_train_r1)} | Teste: {len(X_test_r1)}")

# =============================================================================
# OTIMIZAÃ‡ÃƒO E TREINAMENTO
# =============================================================================

print("\n[6/6] Otimizando hiperparÃ¢metros (100 trials)...")

def objective_r1(trial):
    params = {
        'iterations': 500,
        'learning_rate': trial.suggest_float('learning_rate', 0.01, 0.1, log=True),
        'depth': trial.suggest_int('depth', 3, 6),
        'l2_leaf_reg': trial.suggest_float('l2_leaf_reg', 10, 100, log=True),
        'border_count': trial.suggest_int('border_count', 32, 128),
        'bagging_temperature': trial.suggest_float('bagging_temperature', 0.5, 1.0),
        'random_strength': trial.suggest_float('random_strength', 0.5, 2.0),
        'verbose': False,
        'random_seed': 42
    }
    model = CatBoostRegressor(**params)
    scores = cross_val_score(model, X_train_r1, y_train_r1, cv=5, scoring='r2')
    return scores.mean()

study_r1 = optuna.create_study(direction='maximize')
study_r1.optimize(objective_r1, n_trials=100, show_progress_bar=True)

best_params_r1 = study_r1.best_params
best_params_r1['iterations'] = 500
best_params_r1['verbose'] = False
best_params_r1['random_seed'] = 42

print(f"\nâœ… Melhor RÂ² CV: {study_r1.best_value:.4f}")

# Treinar modelo final
print("\nðŸ”§ Treinando modelo final...")
model_r1 = CatBoostRegressor(**best_params_r1)
model_r1.fit(X_train_r1, y_train_r1, verbose=False)

# =============================================================================
# SALVAR ARTEFATOS
# =============================================================================

print("\nðŸ’¾ Salvando artefatos...")

# Salvar modelo
joblib.dump(model_r1, f'{ARTIFACTS_PATH}/modelo_target1.pkl')
print(f"  âœ… Modelo salvo: {ARTIFACTS_PATH}/modelo_target1.pkl")

# Salvar scaler
joblib.dump(scaler_r1, f'{ARTIFACTS_PATH}/scaler_target1.pkl')
print(f"  âœ… Scaler salvo: {ARTIFACTS_PATH}/scaler_target1.pkl")

# Salvar lista de features
with open(f'{ARTIFACTS_PATH}/features_target1.pkl', 'wb') as f:
    pickle.dump(selected_features_r1, f)
print(f"  âœ… Features salvas: {ARTIFACTS_PATH}/features_target1.pkl")

print("\n" + "=" * 100)
print("âœ… TARGET 1 (R1) - TREINAMENTO COMPLETO!".center(100))
print("=" * 100)
print(f"\nðŸ“¦ Artefatos salvos em: {ARTIFACTS_PATH}/")
print(f"  â€¢ modelo_target1.pkl")
print(f"  â€¢ scaler_target1.pkl")
print(f"  â€¢ features_target1.pkl")
</file>

<file path="dashboard/backend/export_hibrido_target2.py">
# =============================================================================
# EXPORT HÃBRIDO - TARGET 2 (R2)
# =============================================================================
# Este script replica a SEÃ‡ÃƒO 3 do notebook hÃ­brido definitivo (CORRIGIDO!)
# Treina o ENSEMBLE de 3 modelos R2 e salva os artefatos necessÃ¡rios para a API

import pandas as pd
import numpy as np
import warnings
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.preprocessing import QuantileTransformer
from sklearn.feature_selection import VarianceThreshold
from catboost import CatBoostRegressor
import optuna
import joblib
import pickle
import os

warnings.filterwarnings('ignore')
optuna.logging.set_verbosity(optuna.logging.WARNING)

# ConfiguraÃ§Ã£o de caminhos
ARTIFACTS_PATH = 'ml_artifacts'
os.makedirs(ARTIFACTS_PATH, exist_ok=True)

print("=" * 100)
print("ðŸŽ¯ TREINAMENTO TARGET 2 (R2) - ENSEMBLE HÃBRIDO CORRIGIDO".center(100))
print("=" * 100)

# =============================================================================
# CARREGAMENTO E PRÃ‰-PROCESSAMENTO
# =============================================================================

df_raw = pd.read_excel('JogadoresV3.xlsx')
df = df_raw.copy()

TARGET = 'Target2'

print(f"\nâœ… Dados carregados: {len(df)} linhas")

# Converter F0103
if 'F0103' in df.columns:
    df['F0103'] = pd.to_numeric(df['F0103'].astype(str).str.replace(',', '.'), errors='coerce')

# Identificar colunas P, T, F
p_cols = [col for col in df.columns if col.startswith('P') and any(c.isdigit() for c in col)]
t_cols = [col for col in df.columns if col.startswith('T') and any(c.isdigit() for c in col)]
f_cols = [col for col in df.columns if col.startswith('F') and len(col) > 1 and any(c.isdigit() for c in col)]

print("\n[1/5] Tratando valores -1 e NaN...")

# Converter para numÃ©rico e tratar -1
for col in p_cols + t_cols + f_cols:
    if col in df.columns:
        df[col] = pd.to_numeric(df[col], errors='coerce')
        df[col] = df[col].replace(-1, np.nan)
        if df[col].isnull().sum() > 0:
            df[col].fillna(df[col].median(), inplace=True)

# =============================================================================
# FEATURE ENGINEERING MINIMALISTA
# =============================================================================

print("\n[2/5] Criando features minimalistas para R2...")

# Features de sono
if 'QtdHorasDormi' in df.columns and 'Acordar' in df.columns:
    df['sono_total'] = df['QtdHorasDormi']
    df['acordar'] = df['Acordar']

# Features de formulÃ¡rio sono
f_sono = [c for c in f_cols if c.startswith('F07')]
if len(f_sono) > 0:
    df['F_sono_mean'] = df[f_sono].mean(axis=1)

# Features de formulÃ¡rio final
f_final = [c for c in f_cols if c.startswith('F11')]
if len(f_final) > 0:
    df['F_final_mean'] = df[f_final].mean(axis=1)

# Features de performance
p_cols_exist = [c for c in p_cols if c in df.columns]
if len(p_cols_exist) > 0:
    df['P_mean'] = df[p_cols_exist].mean(axis=1)

# Preencher NaN remanescentes
numeric_cols = df.select_dtypes(include=np.number).columns
for col in numeric_cols:
    if df[col].isnull().sum() > 0:
        df[col].fillna(df[col].median(), inplace=True)

# =============================================================================
# SELEÃ‡ÃƒO DE FEATURES CONSERVADORA
# =============================================================================

print("\n[3/5] SeleÃ§Ã£o conservadora (â‰¤12 features)...")

feature_cols = [col for col in df.columns if col not in [TARGET, 'CÃ³digo de Acesso', 'Data/Hora Ãšltimo', 'Target1', 'Target3']
                and pd.api.types.is_numeric_dtype(df[col])]

X_pre = df[feature_cols].fillna(0)
y = df[TARGET]

# Variance Threshold
selector = VarianceThreshold(threshold=0.01)
selector.fit(X_pre)
feature_cols_filtered = X_pre.columns[selector.get_support()].tolist()

# CorrelaÃ§Ã£o com target
correlations = []
for col in feature_cols_filtered:
    corr = df[col].corr(df[TARGET])
    if not np.isnan(corr):
        correlations.append((col, abs(corr)))

correlations.sort(key=lambda x: x[1], reverse=True)

# TOP 12 features
MAX_FEATURES = 12
selected_features_r2 = [col for col, _ in correlations[:MAX_FEATURES]]

print(f"  âœ… {len(selected_features_r2)} features selecionadas")

# Criar uma interaÃ§Ã£o entre TOP 2
if len(selected_features_r2) >= 2:
    f1, f2 = selected_features_r2[0], selected_features_r2[1]
    df[f'{f1}_X_{f2}'] = df[f1] * df[f2]
    selected_features_r2.append(f'{f1}_X_{f2}')

# =============================================================================
# PREPARAÃ‡ÃƒO DOS DADOS
# =============================================================================

print("\n[4/5] Preparando dados...")

X_r2 = df[selected_features_r2].copy()
y_r2 = df[TARGET].values

# Remover NaNs
valid_idx = ~np.isnan(y_r2)
X_r2 = X_r2[valid_idx]
y_r2 = y_r2[valid_idx]

print(f"  Dados: {len(X_r2)} amostras Ã— {len(selected_features_r2)} features")

# =============================================================================
# OTIMIZAÃ‡ÃƒO
# =============================================================================

print("\n[5/5] OtimizaÃ§Ã£o brutal (150 trials)...")

def objective_r2(trial):
    params = {
        'iterations': trial.suggest_int('iterations', 300, 700),
        'learning_rate': trial.suggest_float('learning_rate', 0.001, 0.03, log=True),
        'depth': trial.suggest_int('depth', 2, 3),
        'l2_leaf_reg': trial.suggest_float('l2_leaf_reg', 50, 300, log=True),
        'border_count': trial.suggest_int('border_count', 16, 48),
        'bagging_temperature': trial.suggest_float('bagging_temperature', 0.0, 0.5),
        'random_strength': trial.suggest_float('random_strength', 2.0, 5.0),
        'min_data_in_leaf': trial.suggest_int('min_data_in_leaf', 5, 15),
        'verbose': False,
        'random_seed': 42
    }

    X_tr_opt, X_te_opt, y_tr_opt, y_te_opt = train_test_split(X_r2, y_r2, test_size=0.25, random_state=42)
    scaler_temp = QuantileTransformer(output_distribution='normal', random_state=42)
    X_tr_scaled = scaler_temp.fit_transform(X_tr_opt)

    model = CatBoostRegressor(**params)
    scores = cross_val_score(model, X_tr_scaled, y_tr_opt, cv=5, scoring='r2')
    return scores.mean()

study_r2 = optuna.create_study(direction='maximize')
study_r2.optimize(objective_r2, n_trials=150, show_progress_bar=True)

best_params_r2 = study_r2.best_params
best_params_r2['verbose'] = False
best_params_r2['random_seed'] = 42

print(f"\nâœ… Melhor RÂ² CV: {study_r2.best_value:.4f}")

# =============================================================================
# TREINAMENTO DO ENSEMBLE (3 MODELOS) - VERSÃƒO CORRIGIDA
# =============================================================================

print("\nðŸš€ Treinando ensemble (3 modelos)...")
print("  âœ… Cada modelo treina com seed diferente (diversidade)")

# SPLIT BASE COMUM (para consistÃªncia do scaler)
X_train_base, X_test_base, y_train_base, y_test_base = train_test_split(
    X_r2, y_r2, test_size=0.25, random_state=42
)

# SCALER BASE COMUM
scaler_base = QuantileTransformer(output_distribution='normal', random_state=42)
X_train_base_scaled = scaler_base.fit_transform(X_train_base)
X_test_base_scaled = scaler_base.transform(X_test_base)

models_r2 = []

for i, seed in enumerate([42, 123, 456], 1):
    print(f"\n  Treinando Modelo {i} (seed={seed})...")
    
    # Cada modelo treina com seed diferente para diversidade
    X_tr_div, X_te_div, y_tr_div, y_te_div = train_test_split(X_r2, y_r2, test_size=0.25, random_state=seed)
    scaler_div = QuantileTransformer(output_distribution='normal', random_state=42)
    X_tr_div_scaled = scaler_div.fit_transform(X_tr_div)
    
    # Treinar modelo
    params_i = best_params_r2.copy()
    params_i['random_seed'] = seed
    model_i = CatBoostRegressor(**params_i)
    model_i.fit(X_tr_div_scaled, y_tr_div, verbose=False)
    
    models_r2.append(model_i)
    print(f"  âœ… Modelo {i} treinado!")

# =============================================================================
# SALVAR ARTEFATOS
# =============================================================================

print("\nðŸ’¾ Salvando artefatos...")

# Salvar os 3 modelos do ensemble
for i, model in enumerate(models_r2):
    joblib.dump(model, f'{ARTIFACTS_PATH}/modelo_target2_ensemble_{i}.pkl')
    print(f"  âœ… Modelo {i+1} salvo: {ARTIFACTS_PATH}/modelo_target2_ensemble_{i}.pkl")

# Salvar o scaler (QuantileTransformer)
joblib.dump(scaler_base, f'{ARTIFACTS_PATH}/scaler_target2.pkl')
print(f"  âœ… Scaler salvo: {ARTIFACTS_PATH}/scaler_target2.pkl")

# Salvar a lista de features
with open(f'{ARTIFACTS_PATH}/features_target2.pkl', 'wb') as f:
    pickle.dump(selected_features_r2, f)
print(f"  âœ… Features salvas: {ARTIFACTS_PATH}/features_target2.pkl")

print("\n" + "=" * 100)
print("âœ… TARGET 2 (R2) - ENSEMBLE COMPLETO!".center(100))
print("=" * 100)
print(f"\nðŸ“¦ Artefatos salvos em: {ARTIFACTS_PATH}/")
print(f"  â€¢ modelo_target2_ensemble_0.pkl")
print(f"  â€¢ modelo_target2_ensemble_1.pkl")
print(f"  â€¢ modelo_target2_ensemble_2.pkl")
print(f"  â€¢ scaler_target2.pkl (QuantileTransformer)")
print(f"  â€¢ features_target2.pkl")
print(f"\nðŸ’¡ NOTA: A API farÃ¡ a mÃ©dia das prediÃ§Ãµes dos 3 modelos")
</file>

<file path="dashboard/backend/export_hibrido_target3.py">
# =============================================================================
# EXPORT HÃBRIDO - TARGET 3 (R3)
# =============================================================================
# Este script replica a SEÃ‡ÃƒO 4 do notebook hÃ­brido definitivo (CORRIGIDO!)
# Treina o ENSEMBLE de 3 modelos R3 e salva os artefatos necessÃ¡rios para a API

import pandas as pd
import numpy as np
import warnings
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.preprocessing import RobustScaler
from catboost import CatBoostRegressor
import optuna
import joblib
import pickle
import os

warnings.filterwarnings('ignore')
optuna.logging.set_verbosity(optuna.logging.WARNING)

# ConfiguraÃ§Ã£o de caminhos
ARTIFACTS_PATH = 'ml_artifacts'
os.makedirs(ARTIFACTS_PATH, exist_ok=True)

print("=" * 100)
print("ðŸŽ¯ TREINAMENTO TARGET 3 (R3) - ENSEMBLE HÃBRIDO CORRIGIDO".center(100))
print("=" * 100)

# =============================================================================
# CARREGAMENTO E PRÃ‰-PROCESSAMENTO
# =============================================================================

df_raw = pd.read_excel('JogadoresV3.xlsx')
df = df_raw.copy()

TARGET = 'Target3'

print(f"\nâœ… Dados carregados: {len(df)} linhas")

# Converter F0103
if 'F0103' in df.columns:
    df['F0103'] = pd.to_numeric(df['F0103'].astype(str).str.replace(',', '.'), errors='coerce')

# Identificar colunas P, T, F
p_cols = [col for col in df.columns if col.startswith('P') and any(c.isdigit() for c in col)]
t_cols = [col for col in df.columns if col.startswith('T') and any(c.isdigit() for c in col)]
f_cols = [col for col in df.columns if col.startswith('F') and len(col) > 1 and any(c.isdigit() for c in col)]

print("\n[1/5] Tratando valores -1 e NaN...")

# Converter para numÃ©rico e tratar -1
for col in p_cols + t_cols + f_cols:
    if col in df.columns:
        df[col] = pd.to_numeric(df[col], errors='coerce')
        df[col] = df[col].replace(-1, np.nan)
        if df[col].isnull().sum() > 0:
            df[col].fillna(df[col].median(), inplace=True)

# =============================================================================
# FEATURE ENGINEERING
# =============================================================================

print("\n[2/5] Feature engineering para R3...")

# Features de Performance
df['P_mean'] = df[p_cols].mean(axis=1)
df['P_std'] = df[p_cols].std(axis=1)
df['P_late'] = df[['P09', 'P12', 'P13', 'P15']].mean(axis=1) if all(c in df.columns for c in ['P09', 'P12', 'P13', 'P15']) else 0
df['P_early'] = df[['P01', 'P02', 'P03', 'P04']].mean(axis=1) if all(c in df.columns for c in ['P01', 'P02', 'P03', 'P04']) else 0

# Features de Tempo
df['T_mean'] = df[t_cols].mean(axis=1)
df['T_std'] = df[t_cols].std(axis=1)

# Features de Sono
if 'QtdHorasSono' in df.columns:
    f_sono = [c for c in f_cols if '07' in c]
    df['F_sono_mean'] = df[f_sono].mean(axis=1)
    df['F_sono_std'] = df[f_sono].std(axis=1)
    df['F_sono_max'] = df[f_sono].max(axis=1)
    if 'Acordar' in df.columns:
        df['sono_x_acordar'] = df['QtdHorasSono'] * df['Acordar']
        df['acordar_squared'] = df['Acordar'] ** 2

# Features de FormulÃ¡rio Final
f_final = [c for c in f_cols if '11' in c]
df['F_final_mean'] = df[f_final].mean(axis=1)

print("  âœ… Features criadas!")

# =============================================================================
# SELEÃ‡ÃƒO DE FEATURES
# =============================================================================

print("\n[3/5] SeleÃ§Ã£o TOP 15 features...")

# Pool de features com correlaÃ§Ã£o > 0.35
feature_pool = []
for col in df.columns:
    if col not in [TARGET, 'CÃ³digo de Acesso', 'Target1', 'Target2'] and df[col].dtype in ['float64', 'int64']:
        corr = abs(df[col].corr(df[TARGET]))
        if not np.isnan(corr) and corr > 0.35:
            feature_pool.append((col, corr))

feature_pool.sort(key=lambda x: x[1], reverse=True)
selected_features_r3 = [f[0] for f in feature_pool[:15]]

print(f"  âœ… {len(selected_features_r3)} features selecionadas")

# Criar interaÃ§Ã£o
if 'F1103' in selected_features_r3 and 'P_mean' in selected_features_r3:
    df['F1103_X_P_mean'] = df['F1103'] * df['P_mean']
    selected_features_r3.append('F1103_X_P_mean')

# =============================================================================
# PREPARAÃ‡ÃƒO DOS DADOS
# =============================================================================

print("\n[4/5] Preparando dados...")

X_r3 = df[selected_features_r3].fillna(df[selected_features_r3].median())
y_r3 = df[TARGET].values

print(f"  Dados: {len(X_r3)} amostras Ã— {len(selected_features_r3)} features")

# =============================================================================
# OTIMIZAÃ‡ÃƒO
# =============================================================================

print("\n[5/5] OtimizaÃ§Ã£o (100 trials)...")

def objective_r3(trial):
    X_tr_opt, X_te_opt, y_tr_opt, y_te_opt = train_test_split(X_r3, y_r3, test_size=0.25, random_state=42)
    scaler_temp = RobustScaler()
    X_tr_scaled = scaler_temp.fit_transform(X_tr_opt)

    params = {
        'iterations': trial.suggest_int('iterations', 200, 800),
        'learning_rate': trial.suggest_float('learning_rate', 0.005, 0.05, log=True),
        'depth': 2,
        'l2_leaf_reg': trial.suggest_float('l2_leaf_reg', 120, 180),
        'border_count': trial.suggest_int('border_count', 16, 128),
        'bagging_temperature': trial.suggest_float('bagging_temperature', 0, 1),
        'random_strength': trial.suggest_float('random_strength', 0.5, 5),
        'min_data_in_leaf': trial.suggest_int('min_data_in_leaf', 8, 15),
        'random_seed': 42,
        'verbose': False
    }
    model = CatBoostRegressor(**params)
    scores = cross_val_score(model, X_tr_scaled, y_tr_opt, cv=3, scoring='r2')
    return scores.mean()

study_r3 = optuna.create_study(direction='maximize')
study_r3.optimize(objective_r3, n_trials=100, show_progress_bar=True)

best_params_r3 = study_r3.best_params
best_params_r3['depth'] = 2
best_params_r3['verbose'] = False
best_params_r3['random_seed'] = 42

print(f"\nâœ… Melhor RÂ² CV: {study_r3.best_value:.4f}")

# =============================================================================
# TREINAMENTO DO ENSEMBLE (3 MODELOS) - VERSÃƒO CORRIGIDA
# =============================================================================

print("\nðŸš€ Treinando ensemble (3 modelos)...")
print("  âœ… Cada modelo treina com seed diferente (diversidade)")

# SPLIT BASE COMUM (para consistÃªncia do scaler)
X_train_base_r3, X_test_base_r3, y_train_base_r3, y_test_base_r3 = train_test_split(
    X_r3, y_r3, test_size=0.25, random_state=42
)

# SCALER BASE COMUM
scaler_base_r3 = RobustScaler()
X_train_base_r3_scaled = scaler_base_r3.fit_transform(X_train_base_r3)
X_test_base_r3_scaled = scaler_base_r3.transform(X_test_base_r3)

models_r3 = []

for i, seed in enumerate([42, 123, 456], 1):
    print(f"\n  Treinando Modelo {i} (seed={seed})...")
    
    # Cada modelo treina com seed diferente para diversidade
    X_tr_div, X_te_div, y_tr_div, y_te_div = train_test_split(X_r3, y_r3, test_size=0.25, random_state=seed)
    scaler_div = RobustScaler()
    X_tr_div_scaled = scaler_div.fit_transform(X_tr_div)
    
    # Treinar modelo
    params_i = best_params_r3.copy()
    params_i['random_seed'] = seed
    model_i = CatBoostRegressor(**params_i)
    model_i.fit(X_tr_div_scaled, y_tr_div, verbose=False)
    
    models_r3.append(model_i)
    print(f"  âœ… Modelo {i} treinado!")

# =============================================================================
# SALVAR ARTEFATOS
# =============================================================================

print("\nðŸ’¾ Salvando artefatos...")

# Salvar os 3 modelos do ensemble
for i, model in enumerate(models_r3):
    joblib.dump(model, f'{ARTIFACTS_PATH}/modelo_target3_ensemble_{i}.pkl')
    print(f"  âœ… Modelo {i+1} salvo: {ARTIFACTS_PATH}/modelo_target3_ensemble_{i}.pkl")

# Salvar o scaler (RobustScaler)
joblib.dump(scaler_base_r3, f'{ARTIFACTS_PATH}/scaler_target3.pkl')
print(f"  âœ… Scaler salvo: {ARTIFACTS_PATH}/scaler_target3.pkl")

# Salvar a lista de features
with open(f'{ARTIFACTS_PATH}/features_target3.pkl', 'wb') as f:
    pickle.dump(selected_features_r3, f)
print(f"  âœ… Features salvas: {ARTIFACTS_PATH}/features_target3.pkl")

print("\n" + "=" * 100)
print("âœ… TARGET 3 (R3) - ENSEMBLE COMPLETO!".center(100))
print("=" * 100)
print(f"\nðŸ“¦ Artefatos salvos em: {ARTIFACTS_PATH}/")
print(f"  â€¢ modelo_target3_ensemble_0.pkl")
print(f"  â€¢ modelo_target3_ensemble_1.pkl")
print(f"  â€¢ modelo_target3_ensemble_2.pkl")
print(f"  â€¢ scaler_target3.pkl (RobustScaler)")
print(f"  â€¢ features_target3.pkl")
print(f"\nðŸ’¡ NOTA: A API farÃ¡ a mÃ©dia das prediÃ§Ãµes dos 3 modelos")
</file>

<file path="dashboard/backend/models.py">
# models.py
from sqlalchemy import Column, Integer, String, Float, DateTime, ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from database import Base

class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, unique=True, index=True, nullable=False)
    password_hash = Column(String, nullable=False)
    predictions = relationship('Prediction', backref='user', lazy=True)

class Prediction(Base):
    __tablename__ = 'predictions'
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey('users.id'), nullable=False)
    upload_timestamp = Column(DateTime, nullable=False, default=func.now())
    jogador_id = Column(String, nullable=False)
    pred_t1 = Column(Float, nullable=False)
    pred_t2 = Column(Float, nullable=False)
    pred_t3 = Column(Float, nullable=False)
</file>

<file path="dashboard/backend/README.md">
# Backend API (FastAPI)

Esta API serve como o cÃ©rebro do projeto, lidando com autenticaÃ§Ã£o, processamento de dados e previsÃµes de Machine Learning.

## Principais Funcionalidades

-   **AutenticaÃ§Ã£o JWT:** Sistema de registro (`/register`) e login (`/login`) que gera tokens JWT para proteger os endpoints.
-   **Endpoint de PrevisÃ£o (`/predict`):** Recebe um arquivo `.xlsx` com novos dados de jogadores, aplica o mesmo pipeline de prÃ©-processamento dos modelos treinados e retorna as previsÃµes para os 3 targets.
-   **AnÃ¡lise SHAP:** Junto com as previsÃµes, a API calcula os valores SHAP para cada jogador, permitindo entender a contribuiÃ§Ã£o de cada feature para o resultado.
-   **HistÃ³rico de PrevisÃµes (`/history`):** Salva cada lote de previsÃµes no banco de dados, associado ao usuÃ¡rio que fez o upload.
-   **AnÃ¡lise do Modelo (`/feature_importance`):** ExpÃµe a importÃ¢ncia geral das features para cada modelo.

## Principais Endpoints

-   `POST /register`: Cria um novo usuÃ¡rio.
-   `POST /login`: Autentica um usuÃ¡rio e retorna um token de acesso.
-   `POST /predict`: (Protegido) Recebe um arquivo Excel e retorna as previsÃµes e dados SHAP.
-   `GET /history`: (Protegido) Retorna o histÃ³rico de uploads do usuÃ¡rio logado.
-   `GET /feature_importance`: (Protegido) Retorna a importÃ¢ncia das features para cada modelo.
-   `GET /health`: Verifica a saÃºde da aplicaÃ§Ã£o, incluindo o carregamento dos modelos de ML.
</file>

<file path="dashboard/backend/schemas.py">
# schemas.py
from pydantic import BaseModel

class UserCreate(BaseModel):
    username: str
    password: str

class Token(BaseModel):
    access_token: str
    token_type: str
</file>

<file path="dashboard/frontend/README.md">
# Frontend Dashboard (Plotly Dash)

Este Ã© um dashboard interativo construÃ­do com Plotly Dash para fornecer uma interface amigÃ¡vel para o sistema de previsÃ£o.

## Funcionalidades

O dashboard Ã© dividido em abas:

1.  **Nova PrevisÃ£o:**
    -   Permite o upload de um arquivo `.xlsx` com novos dados de jogadores.
    -   Exibe os resultados em uma tabela interativa (ordenÃ¡vel, filtrÃ¡vel) e em grÃ¡ficos de barras comparativos.
    -   Disponibiliza um botÃ£o para download dos resultados.
    -   Apresenta uma seÃ§Ã£o de anÃ¡lise SHAP, onde Ã© possÃ­vel selecionar um jogador e visualizar grÃ¡ficos que explicam sua previsÃ£o.

2.  **AnÃ¡lise do Modelo:**
    -   Exibe grÃ¡ficos de barras horizontais mostrando as 20 features mais importantes para cada um dos 3 modelos de target.

3.  **HistÃ³rico:**
    -   Mostra uma tabela com o histÃ³rico de uploads de arquivos realizados pelo usuÃ¡rio, incluindo data e quantidade de jogadores previstos em cada lote.
</file>

<file path="dashboard/README.md">
# Projeto Daruma: PrevisÃ£o de Targets de Jogadores

Este projeto Ã© a soluÃ§Ã£o para o Desafio Final de Ciclo, que consiste em construir um sistema de Machine Learning completo para prever 3 targets numÃ©ricos com base nos dados de jogadores.

A soluÃ§Ã£o inclui um pipeline de treinamento de modelos, uma API backend para servir as previsÃµes e um dashboard interativo para visualizaÃ§Ã£o e anÃ¡lise dos resultados.

## Arquitetura

O projeto Ã© conteinerizado com Docker e orquestrado com Docker Compose, seguindo a arquitetura abaixo:

```
Frontend (Plotly Dash) <--> Backend (FastAPI) <--> Database (PostgreSQL)
```

-   **Frontend:** Um dashboard interativo onde o usuÃ¡rio pode fazer upload de novos dados, visualizar previsÃµes, anÃ¡lises de importÃ¢ncia de features e explicaÃ§Ãµes de prediÃ§Ã£o individuais com SHAP.
-   **Backend:** Uma API RESTful construÃ­da com FastAPI que lida com autenticaÃ§Ã£o de usuÃ¡rios, recebe os dados, executa o pipeline de prÃ©-processamento e prediÃ§Ã£o usando modelos prÃ©-treinados, e salva os resultados.
-   **Database:** Um banco de dados PostgreSQL para armazenar informaÃ§Ãµes de usuÃ¡rios e histÃ³rico de previsÃµes.
-   **ML Training:** Scripts Python para treinar os modelos de Machine Learning, realizar a otimizaÃ§Ã£o de hiperparÃ¢metros e exportar os artefatos (modelos, scalers, listas de features) necessÃ¡rios para a API.

## Estrutura do Projeto

```
.
â”œâ”€â”€ backend/            # CÃ³digo da API FastAPI
â”‚   â”œâ”€â”€ ml_artifacts/   # Artefatos de ML (modelos, scalers, etc.)
â”‚   â””â”€â”€ ...
â”œâ”€â”€ frontend/           # CÃ³digo do Dashboard em Dash
â”‚   â””â”€â”€ ...
â”œâ”€â”€ .env                # Arquivo de configuraÃ§Ã£o de ambiente (NÃƒO COMMITAR)
â”œâ”€â”€ .gitignore
â”œâ”€â”€ docker-compose.yml
â””â”€â”€ README.md
```

## Como Executar

**PrÃ©-requisitos:**
*   Docker
*   Docker Compose

**Passo 1: Preparar os Modelos de ML**

# Pipeline de Treinamento de Modelos

Esta parte contÃ©m os scripts responsÃ¡veis pelo treinamento, otimizaÃ§Ã£o e exportaÃ§Ã£o dos modelos de Machine Learning. Pois, os modelos precisam ser treinados antes de iniciar a aplicaÃ§Ã£o.

# Navegue atÃ© a pasta backend
cd backend

# Instale as dependÃªncias
pip install -r requirements.txt

# Certifique-se que o excel para treinamento 'JogadoresV1.xlsx' esteja na mesma pasta e Execute os scripts de treinamento para gerar os artefatos
python export_artifacts_target1.py
python export_artifacts_target2.py
python export_artifacts_target3.py

## Funcionamento
Cada script `export_artifacts_target<N>.py` Ã© um pipeline completo para um dos trÃªs targets. O processo geral inclui:

1.  **Carregamento e Limpeza:** Os dados do arquivo `JogadoresV1.xlsx` sÃ£o carregados. Valores ausentes sÃ£o tratados (imputaÃ§Ã£o por mediana) e tipos de dados sÃ£o corrigidos.
2.  **Engenharia de Features:** Novas features sÃ£o criadas a partir das existentes (mÃ©dias, interaÃ§Ãµes, features polinomiais) para aumentar o poder preditivo do modelo.
3.  **SeleÃ§Ã£o de Features:** TÃ©cnicas como `VarianceThreshold`, correlaÃ§Ã£o com o target e importÃ¢ncia de features de um `RandomForest` sÃ£o usadas para selecionar as variÃ¡veis mais relevantes.
4.  **OtimizaÃ§Ã£o de HiperparÃ¢metros:** A biblioteca `Optuna` Ã© utilizada para encontrar os melhores hiperparÃ¢metros para os modelos (ex: `CatBoost`), maximizando a mÃ©trica `R2 Score` em validaÃ§Ã£o cruzada.
5.  **Treinamento Final:** O modelo Ã© treinado com os melhores parÃ¢metros em todo o conjunto de dados de treino.
6.  **ExportaÃ§Ã£o de Artefatos:** O modelo treinado, o `scaler` (para normalizaÃ§Ã£o) e a lista de features utilizadas sÃ£o salvos como arquivos `.pkl` na pasta `backend/ml_artifacts`.

# Volte para a raiz do projeto
cd ..
```
Isso criarÃ¡ a pasta `backend/ml_artifacts` com todos os arquivos `.pkl` necessÃ¡rios.

**Passo 2: Configurar o Ambiente**

Crie uma cÃ³pia do arquivo `.env.example` (que vocÃª deve criar) e renomeie para `.env`. Preencha com suas configuraÃ§Ãµes, principalmente uma `JWT_SECRET_KEY` segura.

**Passo 3: Iniciar a AplicaÃ§Ã£o**

Com o Docker em execuÃ§Ã£o, rode o seguinte comando na raiz do projeto:

```bash
docker-compose up --build
```

A aplicaÃ§Ã£o estarÃ¡ disponÃ­vel nos seguintes endereÃ§os:
-   **Dashboard:** `http://localhost:8050`
-   **API (documentaÃ§Ã£o):** `http://localhost:5000/docs`
</file>

<file path="notebooks/PROJETOFINAL.ipynb">
{
  "nbformat": 4,
  "nbformat_minor": 0,
  "metadata": {
    "colab": {
      "provenance": []
    },
    "kernelspec": {
      "name": "python3",
      "display_name": "Python 3"
    },
    "language_info": {
      "name": "python"
    }
  },
  "cells": [
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "tuhH-znyFcGf",
        "outputId": "c0c316ca-190e-4ac9-c8fb-99b0987ab8ae"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "\u001b[?25l   \u001b[90mâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\u001b[0m \u001b[32m0.0/175.3 kB\u001b[0m \u001b[31m?\u001b[0m eta \u001b[36m-:--:--\u001b[0m\r\u001b[2K   \u001b[91mâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\u001b[0m\u001b[91mâ•¸\u001b[0m \u001b[32m174.1/175.3 kB\u001b[0m \u001b[31m6.9 MB/s\u001b[0m eta \u001b[36m0:00:01\u001b[0m\r\u001b[2K   \u001b[90mâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\u001b[0m \u001b[32m175.3/175.3 kB\u001b[0m \u001b[31m3.9 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n",
            "\u001b[?25hâœ… Bibliotecas instaladas!\n",
            "================================================================================\n",
            "     FASE 2 OTIMIZADA: LIMPEZA E PREPARAÃ‡ÃƒO (VERSÃƒO MELHORADA)\n",
            "================================================================================\n",
            "ðŸ“‹ CategÃ³ricas: 21 | Targets: 3\n",
            "\n",
            "================================================================================\n",
            "ETAPA 0: CARREGANDO DADOS\n",
            "================================================================================\n",
            "âœ… Carregado: 183 linhas, 114 colunas\n",
            "\n",
            "================================================================================\n",
            "ETAPA 1: REMOÃ‡ÃƒO DE NEGATIVOS â†’ NaN\n",
            "================================================================================\n",
            "âœ… 108 negativos convertidos â†’ NaN\n",
            "\n",
            "================================================================================\n",
            "ETAPA 2: ANÃLISE DE MISSING\n",
            "================================================================================\n",
            "ðŸ—‘ï¸  Removendo 7 colunas (>70% missing)\n",
            "âœ… Shape: (183, 107)\n",
            "\n",
            "================================================================================\n",
            "ETAPA 3: REMOÃ‡ÃƒO DE JOGADORES SEM TARGETS\n",
            "================================================================================\n",
            "âœ… Jogadores mantidos: 173 (removidos: 10)\n",
            "\n",
            "================================================================================\n",
            "ETAPA 4: IMPUTAÃ‡ÃƒO\n",
            "================================================================================\n",
            "âœ… 90 numÃ©ricas imputadas (mediana)\n",
            "âœ… 17 categÃ³ricas imputadas (moda)\n",
            "\n",
            "================================================================================\n",
            "ETAPA 5: TRATAMENTO DE OUTLIERS\n",
            "================================================================================\n",
            "âœ… 727 outliers tratados (substituÃ­dos por mediana)\n",
            "\n",
            "================================================================================\n",
            "ETAPA 6: ONE-HOT ENCODING\n",
            "================================================================================\n",
            "âœ… One-Hot concluÃ­do: 107 â†’ 355 colunas\n",
            "\n",
            "================================================================================\n",
            "ETAPA 7: FEATURE ENGINEERING\n",
            "================================================================================\n",
            "âœ… F11_mean criada (8 colunas)\n",
            "âœ… F07_mean criada (9 colunas)\n",
            "\n",
            "================================================================================\n",
            "ðŸ”§ CORREÃ‡ÃƒO 1: CONVERSÃƒO BOOL â†’ INT\n",
            "================================================================================\n",
            "ðŸ“‹ Convertendo 265 colunas booleanas...\n",
            "âœ… VERDADEIRO/FALSO â†’ 1/0\n",
            "   Exemplo: ['Cor0202_000000', 'Cor0202_3E3200', 'Cor0202_552D2D']\n",
            "\n",
            "================================================================================\n",
            "ETAPA 8: FEATURE SELECTION\n",
            "================================================================================\n",
            "ðŸ“Š Features disponÃ­veis: 347\n",
            "âœ… Features mantidas: 54 (threshold=0.2)\n",
            "âœ… Features removidas: 293\n",
            "\n",
            "ðŸ† TOP 10 FEATURES:\n",
            "    1. F07_mean                       | Corr: 0.6025\n",
            "    2. F1105                          | Corr: 0.5670\n",
            "    3. F1107                          | Corr: 0.5448\n",
            "    4. F1101                          | Corr: 0.5363\n",
            "    5. F0708                          | Corr: 0.5349\n",
            "    6. F0711                          | Corr: 0.5341\n",
            "    7. Acordar                        | Corr: 0.5263\n",
            "    8. F1109                          | Corr: 0.5226\n",
            "    9. F0710                          | Corr: 0.5146\n",
            "   10. F0707                          | Corr: 0.5088\n",
            "\n",
            "================================================================================\n",
            "ETAPA 9: CRIAÃ‡ÃƒO DOS DATAFRAMES FINAIS\n",
            "================================================================================\n",
            "âœ… DataFrame NÃƒO-NORMALIZADO: (173, 57)\n",
            "ðŸ”¢ NumÃ©ricas a normalizar: 25\n",
            "ðŸ“ CategÃ³ricas (preservadas): 29\n",
            "âœ… NormalizaÃ§Ã£o concluÃ­da!\n",
            "âœ… DataFrame NORMALIZADO: (173, 57)\n",
            "\n",
            "================================================================================\n",
            "ETAPA 10: EXPORTAÃ‡ÃƒO\n",
            "================================================================================\n",
            "âœ… Arquivo 'Dados_Otimizados_V4.xlsx' criado!\n",
            "\n",
            "================================================================================\n",
            "ðŸŽ‰ FASE 2 OTIMIZADA CONCLUÃDA!\n",
            "================================================================================\n",
            "\n",
            "ðŸ“Š RESUMO:\n",
            "   Jogadores: 173\n",
            "   Features: 54\n",
            "   Targets: 3\n",
            "\n",
            "ðŸ”§ MELHORIAS APLICADAS:\n",
            "   âœ… BOOL convertidas para INT (0/1)\n",
            "   âœ… ClusterizaÃ§Ã£o REMOVIDA (nÃ£o agregava valor)\n",
            "   âœ… Pipeline otimizado\n",
            "\n",
            "ðŸ“ ARQUIVO GERADO: Dados_Otimizados_V4.xlsx\n",
            "   Aba 1: Dados_Para_Analise\n",
            "   Aba 2: Dados_Para_Modelo â­ (usar este!)\n",
            "   Aba 3: Resumo_Estatistico\n",
            "   Aba 4: Correlacoes\n",
            "\n",
            "ðŸš€ PRÃ“XIMO PASSO: FASE 3 OTIMIZADA\n",
            "   Use: Dados_Para_Modelo\n"
          ]
        }
      ],
      "source": [
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "# FASE 2 OTIMIZADA: PIPELINE COM MELHORIAS APLICADAS\n",
        "# ðŸ”§ CORREÃ‡Ã•ES IMPLEMENTADAS:\n",
        "#    âœ… ConversÃ£o BOOL â†’ INT (problema crÃ­tico resolvido!)\n",
        "#    âœ… RemoÃ§Ã£o de features de cluster (nÃ£o agregavam valor)\n",
        "#    âœ… CÃ³digo otimizado e mais rÃ¡pido\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "# CÃ‰LULA 1: INSTALAÃ‡ÃƒO\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "!pip install xlsxwriter openpyxl scikit-learn -q\n",
        "print(\"âœ… Bibliotecas instaladas!\")\n",
        "\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "# CÃ‰LULA 2: IMPORTS\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "import pandas as pd\n",
        "import numpy as np\n",
        "from sklearn.impute import SimpleImputer\n",
        "from sklearn.preprocessing import StandardScaler\n",
        "from datetime import datetime\n",
        "import warnings\n",
        "warnings.filterwarnings('ignore')\n",
        "\n",
        "print(\"=\" * 80)\n",
        "print(\"     FASE 2 OTIMIZADA: LIMPEZA E PREPARAÃ‡ÃƒO (VERSÃƒO MELHORADA)\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "# CÃ‰LULA 3: DEFINIÃ‡Ã•ES\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "COLUNAS_CATEGORICAS = [\n",
        "    'Cor0202', 'Cor0204', 'Cor0206', 'Cor0208', 'Cor0209Outro',\n",
        "    'P01', 'P02', 'P03', 'P04', 'P05', 'P07', 'P08', 'P09', 'P10',\n",
        "    'P12', 'P13', 'P15', 'P12_1', 'P02_1', 'P03_1', 'P09_1'\n",
        "]\n",
        "\n",
        "COLUNAS_TARGETS = ['Target1', 'Target2', 'Target3']\n",
        "\n",
        "COLUNAS_IGNORAR = [\n",
        "    'CÃ³digo de Acesso', 'Data/Hora Ãšltimo',\n",
        "    'L0210 (nÃ£o likert)',\n",
        "    'F0299 - ExplicaÃ§Ã£o Tempo', 'T0499 - ExplicaÃ§Ã£o Tempo',\n",
        "    'PTempoTotalExpl', 'T1199Expl', 'T1205Expl', 'T1210Expl',\n",
        "    'TempoTotalExpl'\n",
        "]\n",
        "\n",
        "print(f\"ðŸ“‹ CategÃ³ricas: {len(COLUNAS_CATEGORICAS)} | Targets: {len(COLUNAS_TARGETS)}\")\n",
        "\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "# CÃ‰LULA 4: CARREGAR DADOS\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 0: CARREGANDO DADOS\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "df = pd.read_excel('JogadoresV1.xlsx')\n",
        "print(f\"âœ… Carregado: {df.shape[0]} linhas, {df.shape[1]} colunas\")\n",
        "\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "# CÃ‰LULA 5: TRATAMENTO F0103 (vÃ­rgula â†’ ponto)\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "if 'F0103' in df.columns and df['F0103'].dtype == 'object':\n",
        "    print(\"\\nðŸ”§ Convertendo F0103 (vÃ­rgula â†’ ponto)\")\n",
        "    df['F0103'] = df['F0103'].str.replace(',', '.').astype(float)\n",
        "    print(\"   âœ… Convertido!\")\n",
        "\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "# CÃ‰LULA 6: REMOÃ‡ÃƒO DE NEGATIVOS (TODOS!)\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 1: REMOÃ‡ÃƒO DE NEGATIVOS â†’ NaN\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "colunas_numericas = df.select_dtypes(include=[np.number]).columns.tolist()\n",
        "colunas_numericas = [col for col in colunas_numericas if col not in COLUNAS_TARGETS]\n",
        "\n",
        "contador = 0\n",
        "for col in colunas_numericas:\n",
        "    negativos = (df[col] < 0).sum()\n",
        "    if negativos > 0:\n",
        "        df.loc[df[col] < 0, col] = np.nan\n",
        "        contador += negativos\n",
        "\n",
        "print(f\"âœ… {contador} negativos convertidos â†’ NaN\")\n",
        "\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "# CÃ‰LULA 7: REMOÃ‡ÃƒO DE COLUNAS COM MUITO MISSING\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 2: ANÃLISE DE MISSING\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "missing_info = pd.DataFrame({\n",
        "    'Coluna': df.columns,\n",
        "    'Missing': df.isna().sum(),\n",
        "    'Percentual': (df.isna().sum() / len(df) * 100).round(2)\n",
        "})\n",
        "missing_info = missing_info[missing_info['Missing'] > 0].sort_values('Percentual', ascending=False)\n",
        "\n",
        "threshold = 70\n",
        "colunas_remover = missing_info[missing_info['Percentual'] > threshold]['Coluna'].tolist()\n",
        "\n",
        "if colunas_remover:\n",
        "    print(f\"ðŸ—‘ï¸  Removendo {len(colunas_remover)} colunas (>{threshold}% missing)\")\n",
        "    df = df.drop(columns=colunas_remover)\n",
        "\n",
        "print(f\"âœ… Shape: {df.shape}\")\n",
        "\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "# CÃ‰LULA 8: REMOÃ‡ÃƒO DE JOGADORES SEM TARGETS\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 3: REMOÃ‡ÃƒO DE JOGADORES SEM TARGETS\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "antes = len(df)\n",
        "df = df.dropna(subset=COLUNAS_TARGETS, how='all')\n",
        "depois = len(df)\n",
        "\n",
        "print(f\"âœ… Jogadores mantidos: {depois} (removidos: {antes-depois})\")\n",
        "\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "# CÃ‰LULA 9: IMPUTAÃ‡ÃƒO DE VALORES FALTANTES\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 4: IMPUTAÃ‡ÃƒO\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "# NumÃ©ricas: MEDIANA\n",
        "colunas_num_imputar = [\n",
        "    col for col in df.select_dtypes(include=[np.number]).columns\n",
        "    if col not in COLUNAS_TARGETS and col not in COLUNAS_IGNORAR\n",
        "]\n",
        "\n",
        "if colunas_num_imputar:\n",
        "    imputer_num = SimpleImputer(strategy='median')\n",
        "    df[colunas_num_imputar] = imputer_num.fit_transform(df[colunas_num_imputar])\n",
        "    print(f\"âœ… {len(colunas_num_imputar)} numÃ©ricas imputadas (mediana)\")\n",
        "\n",
        "# CategÃ³ricas: MODA\n",
        "colunas_cat_imputar = [col for col in COLUNAS_CATEGORICAS if col in df.columns]\n",
        "\n",
        "if colunas_cat_imputar:\n",
        "    imputer_cat = SimpleImputer(strategy='most_frequent')\n",
        "    df[colunas_cat_imputar] = imputer_cat.fit_transform(df[colunas_cat_imputar])\n",
        "    print(f\"âœ… {len(colunas_cat_imputar)} categÃ³ricas imputadas (moda)\")\n",
        "\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "# CÃ‰LULA 10: TRATAMENTO DE OUTLIERS (IQR + MEDIANA)\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 5: TRATAMENTO DE OUTLIERS\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "colunas_outliers = [\n",
        "    col for col in colunas_num_imputar\n",
        "    if col not in ['QtdHorasSono', 'QtdHorasDormi', 'Acordar']\n",
        "]\n",
        "\n",
        "outliers_tratados = 0\n",
        "for col in colunas_outliers:\n",
        "    Q1 = df[col].quantile(0.25)\n",
        "    Q3 = df[col].quantile(0.75)\n",
        "    IQR = Q3 - Q1\n",
        "\n",
        "    limite_inf = Q1 - 1.5 * IQR\n",
        "    limite_sup = Q3 + 1.5 * IQR\n",
        "\n",
        "    outliers_mask = (df[col] < limite_inf) | (df[col] > limite_sup)\n",
        "    n_outliers = outliers_mask.sum()\n",
        "\n",
        "    if n_outliers > 0:\n",
        "        mediana = df[col].median()\n",
        "        df.loc[outliers_mask, col] = mediana\n",
        "        outliers_tratados += n_outliers\n",
        "\n",
        "print(f\"âœ… {outliers_tratados} outliers tratados (substituÃ­dos por mediana)\")\n",
        "\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "# CÃ‰LULA 11: ONE-HOT ENCODING\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 6: ONE-HOT ENCODING\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "colunas_cat_presentes = [col for col in COLUNAS_CATEGORICAS if col in df.columns]\n",
        "\n",
        "if colunas_cat_presentes:\n",
        "    colunas_antes = df.shape[1]\n",
        "    df = pd.get_dummies(df, columns=colunas_cat_presentes, prefix=colunas_cat_presentes, drop_first=False)\n",
        "    colunas_depois = df.shape[1]\n",
        "\n",
        "    print(f\"âœ… One-Hot concluÃ­do: {colunas_antes} â†’ {colunas_depois} colunas\")\n",
        "\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "# CÃ‰LULA 12: FEATURE ENGINEERING (AgregaÃ§Ãµes)\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 7: FEATURE ENGINEERING\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "# AgregaÃ§Ã£o F11*\n",
        "f11_cols = [c for c in df.columns if c.startswith('F11') and pd.api.types.is_numeric_dtype(df[c])]\n",
        "if len(f11_cols) > 2:\n",
        "    df['F11_mean'] = df[f11_cols].mean(axis=1)\n",
        "    print(f\"âœ… F11_mean criada ({len(f11_cols)} colunas)\")\n",
        "\n",
        "# AgregaÃ§Ã£o F07*\n",
        "f07_cols = [c for c in df.columns if c.startswith('F07') and pd.api.types.is_numeric_dtype(df[c])]\n",
        "if len(f07_cols) > 2:\n",
        "    df['F07_mean'] = df[f07_cols].mean(axis=1)\n",
        "    print(f\"âœ… F07_mean criada ({len(f07_cols)} colunas)\")\n",
        "\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "# CÃ‰LULA 13: ðŸ”§ CORREÃ‡ÃƒO 1 - CONVERTER BOOL â†’ INT\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ðŸ”§ CORREÃ‡ÃƒO 1: CONVERSÃƒO BOOL â†’ INT\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "bool_cols = df.select_dtypes(include=['bool']).columns.tolist()\n",
        "\n",
        "if bool_cols:\n",
        "    print(f\"ðŸ“‹ Convertendo {len(bool_cols)} colunas booleanas...\")\n",
        "    df[bool_cols] = df[bool_cols].astype(int)\n",
        "    print(f\"âœ… VERDADEIRO/FALSO â†’ 1/0\")\n",
        "    print(f\"   Exemplo: {bool_cols[:3]}\")\n",
        "else:\n",
        "    print(\"â„¹ï¸  Nenhuma coluna booleana encontrada\")\n",
        "\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "# CÃ‰LULA 14: FEATURE SELECTION POR CORRELAÃ‡ÃƒO\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 8: FEATURE SELECTION\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "features_numericas_finais = [\n",
        "    col for col in df.columns\n",
        "    if col not in COLUNAS_TARGETS\n",
        "    and col not in COLUNAS_IGNORAR\n",
        "    and pd.api.types.is_numeric_dtype(df[col])\n",
        "]\n",
        "\n",
        "print(f\"ðŸ“Š Features disponÃ­veis: {len(features_numericas_finais)}\")\n",
        "\n",
        "corr_t1 = df[features_numericas_finais].corrwith(df['Target1']).abs()\n",
        "corr_t2 = df[features_numericas_finais].corrwith(df['Target2']).abs()\n",
        "corr_t3 = df[features_numericas_finais].corrwith(df['Target3']).abs()\n",
        "\n",
        "corr_mean = (corr_t1 + corr_t2 + corr_t3) / 3\n",
        "\n",
        "threshold = 0.20\n",
        "features_selecionadas = corr_mean[corr_mean > threshold].index.tolist()\n",
        "\n",
        "print(f\"âœ… Features mantidas: {len(features_selecionadas)} (threshold={threshold})\")\n",
        "print(f\"âœ… Features removidas: {len(features_numericas_finais) - len(features_selecionadas)}\")\n",
        "\n",
        "# Top 10\n",
        "print(f\"\\nðŸ† TOP 10 FEATURES:\")\n",
        "top10 = corr_mean.sort_values(ascending=False).head(10)\n",
        "for idx, (feat, corr) in enumerate(top10.items(), 1):\n",
        "    print(f\"   {idx:2d}. {feat:30s} | Corr: {corr:.4f}\")\n",
        "\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "# CÃ‰LULA 15: CRIAR DATAFRAMES FINAIS\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 9: CRIAÃ‡ÃƒO DOS DATAFRAMES FINAIS\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "df_final_nao_normalizado = df[features_selecionadas + COLUNAS_TARGETS].copy()\n",
        "print(f\"âœ… DataFrame NÃƒO-NORMALIZADO: {df_final_nao_normalizado.shape}\")\n",
        "\n",
        "df_final_normalizado = df_final_nao_normalizado.copy()\n",
        "\n",
        "# Identificar categÃ³ricas (One-Hot) para NÃƒO normalizar\n",
        "features_cat_onehot = [\n",
        "    col for col in features_selecionadas\n",
        "    if any(cat in col for cat in COLUNAS_CATEGORICAS)\n",
        "]\n",
        "\n",
        "features_numericas_normalizar = [\n",
        "    col for col in features_selecionadas\n",
        "    if col not in features_cat_onehot\n",
        "]\n",
        "\n",
        "print(f\"ðŸ”¢ NumÃ©ricas a normalizar: {len(features_numericas_normalizar)}\")\n",
        "print(f\"ðŸ“ CategÃ³ricas (preservadas): {len(features_cat_onehot)}\")\n",
        "\n",
        "if features_numericas_normalizar:\n",
        "    scaler = StandardScaler()\n",
        "    df_final_normalizado[features_numericas_normalizar] = scaler.fit_transform(\n",
        "        df_final_normalizado[features_numericas_normalizar]\n",
        "    )\n",
        "    print(f\"âœ… NormalizaÃ§Ã£o concluÃ­da!\")\n",
        "\n",
        "print(f\"âœ… DataFrame NORMALIZADO: {df_final_normalizado.shape}\")\n",
        "\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "# CÃ‰LULA 16: EXPORTAR PARA EXCEL\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 10: EXPORTAÃ‡ÃƒO\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "output_file = 'Dados_Otimizados_V4.xlsx'\n",
        "\n",
        "writer = pd.ExcelWriter(output_file, engine='xlsxwriter')\n",
        "workbook = writer.book\n",
        "\n",
        "header_format = workbook.add_format({\n",
        "    'bold': True, 'text_wrap': True, 'valign': 'vcenter',\n",
        "    'align': 'center', 'fg_color': '#1F4E78',\n",
        "    'font_color': 'white', 'border': 1\n",
        "})\n",
        "\n",
        "title_format = workbook.add_format({\n",
        "    'bold': True, 'font_size': 16,\n",
        "    'fg_color': '#4472C4', 'font_color': 'white',\n",
        "    'align': 'center', 'valign': 'vcenter', 'border': 2\n",
        "})\n",
        "\n",
        "# Aba 1: Dados nÃ£o-normalizados\n",
        "df_final_nao_normalizado.to_excel(writer, sheet_name='Dados_Para_Analise', index=False, startrow=2)\n",
        "worksheet1 = writer.sheets['Dados_Para_Analise']\n",
        "worksheet1.merge_range('A1:Z1', 'ðŸ“‹ DADOS LIMPOS - VersÃ£o Otimizada', title_format)\n",
        "worksheet1.freeze_panes(3, 0)\n",
        "\n",
        "# Aba 2: Dados normalizados\n",
        "df_final_normalizado.to_excel(writer, sheet_name='Dados_Para_Modelo', index=False, startrow=2)\n",
        "worksheet2 = writer.sheets['Dados_Para_Modelo']\n",
        "worksheet2.merge_range('A1:Z1', 'ðŸ“Š DADOS NORMALIZADOS - Para ML', title_format)\n",
        "worksheet2.freeze_panes(3, 0)\n",
        "\n",
        "# Aba 3: Resumo estatÃ­stico\n",
        "summary = df_final_nao_normalizado[COLUNAS_TARGETS].describe().T\n",
        "summary.to_excel(writer, sheet_name='Resumo_Estatistico', startrow=2)\n",
        "worksheet3 = writer.sheets['Resumo_Estatistico']\n",
        "worksheet3.merge_range('A1:I1', 'ðŸ“Š RESUMO ESTATÃSTICO', title_format)\n",
        "\n",
        "# Aba 4: CorrelaÃ§Ãµes\n",
        "correlations_df = pd.DataFrame({\n",
        "    'Feature': corr_mean.index,\n",
        "    'Corr_Target1': corr_t1.values,\n",
        "    'Corr_Target2': corr_t2.values,\n",
        "    'Corr_Target3': corr_t3.values,\n",
        "    'Corr_Media': corr_mean.values,\n",
        "    'Mantida': ['âœ…' if f in features_selecionadas else 'âŒ' for f in corr_mean.index]\n",
        "}).sort_values('Corr_Media', ascending=False)\n",
        "\n",
        "correlations_df.to_excel(writer, sheet_name='Correlacoes', index=False, startrow=2)\n",
        "worksheet4 = writer.sheets['Correlacoes']\n",
        "worksheet4.merge_range('A1:F1', 'ðŸ” ANÃLISE DE CORRELAÃ‡Ã•ES', title_format)\n",
        "\n",
        "writer.close()\n",
        "\n",
        "print(f\"âœ… Arquivo '{output_file}' criado!\")\n",
        "\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "# CÃ‰LULA 17: RELATÃ“RIO FINAL\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ðŸŽ‰ FASE 2 OTIMIZADA CONCLUÃDA!\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "print(f\"\\nðŸ“Š RESUMO:\")\n",
        "print(f\"   Jogadores: {len(df_final_nao_normalizado)}\")\n",
        "print(f\"   Features: {len(features_selecionadas)}\")\n",
        "print(f\"   Targets: {len(COLUNAS_TARGETS)}\")\n",
        "\n",
        "print(f\"\\nðŸ”§ MELHORIAS APLICADAS:\")\n",
        "print(f\"   âœ… BOOL convertidas para INT (0/1)\")\n",
        "print(f\"   âœ… ClusterizaÃ§Ã£o REMOVIDA (nÃ£o agregava valor)\")\n",
        "print(f\"   âœ… Pipeline otimizado\")\n",
        "\n",
        "print(f\"\\nðŸ“ ARQUIVO GERADO: {output_file}\")\n",
        "print(f\"   Aba 1: Dados_Para_Analise\")\n",
        "print(f\"   Aba 2: Dados_Para_Modelo â­ (usar este!)\")\n",
        "print(f\"   Aba 3: Resumo_Estatistico\")\n",
        "print(f\"   Aba 4: Correlacoes\")\n",
        "\n",
        "print(f\"\\nðŸš€ PRÃ“XIMO PASSO: FASE 3 OTIMIZADA\")\n",
        "print(f\"   Use: Dados_Para_Modelo\")"
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "# FASE 3 COMPLETA: MODELAGEM AVANÃ‡ADA + VISUALIZAÃ‡Ã•ES DETALHADAS\n",
        "# ðŸ”§ COMBINA O MELHOR DAS DUAS VERSÃ•ES:\n",
        "#    âœ… 8 Algoritmos testados (incluindo LightGBM e CatBoost)\n",
        "#    âœ… GrÃ¡fico de DispersÃ£o (Previsto vs. Real) para os melhores modelos\n",
        "#    âœ… GrÃ¡fico de Feature Importance para os melhores modelos\n",
        "#    âœ… Salva os modelos e gera um relatÃ³rio final completo\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "# CÃ‰LULA 1: INSTALAÃ‡ÃƒO DE BIBLIOTECAS\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "!pip install xgboost lightgbm catboost scikit-learn pandas matplotlib seaborn plotly -q\n",
        "print(\"âœ… Bibliotecas instaladas com sucesso!\")\n",
        "\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "# CÃ‰LULA 2: IMPORTAÃ‡ÃƒO DE BIBLIOTECAS\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "import pandas as pd\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "import seaborn as sns\n",
        "import warnings\n",
        "from sklearn.model_selection import train_test_split, cross_val_score\n",
        "from sklearn.linear_model import LinearRegression, Ridge\n",
        "from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor\n",
        "from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score\n",
        "import xgboost as xgb\n",
        "import lightgbm as lgb\n",
        "from catboost import CatBoostRegressor\n",
        "import pickle\n",
        "\n",
        "warnings.filterwarnings('ignore')\n",
        "sns.set_style('whitegrid')\n",
        "\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"     FASE 3 COMPLETA: MODELAGEM AVANÃ‡ADA + VISUALIZAÃ‡Ã•ES\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "# CÃ‰LULA 3: CARREGAMENTO DOS DADOS\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 1: CARREGANDO DADOS LIMPOS\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "# MUDE O NOME DO ARQUIVO AQUI SE NECESSÃRIO:\n",
        "df = pd.read_excel('Dados_para_modelo.xlsx')\n",
        "\n",
        "print(f\"âœ… Dados carregados com sucesso. Shape: {df.shape}\")\n",
        "print(f\"   Total de Jogadores: {len(df)}\")\n",
        "print(f\"   Total de Colunas: {len(df.columns)}\")\n",
        "\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "# CÃ‰LULA 4: SEPARAÃ‡ÃƒO DE FEATURES (X) E TARGETS (y)\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 2: SEPARAÃ‡ÃƒO DE FEATURES E TARGETS\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "targets = ['Target1', 'Target2', 'Target3']\n",
        "X = df.drop(columns=targets)\n",
        "y1 = df['Target1']\n",
        "y2 = df['Target2']\n",
        "y3 = df['Target3']\n",
        "\n",
        "print(f\"âœ… Features (X) separadas. Total de features: {X.shape[1]}\")\n",
        "print(f\"âœ… Targets (y1, y2, y3) separados.\")\n",
        "\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "# CÃ‰LULA 5: DIVISÃƒO EM DADOS DE TREINO E TESTE (80/20)\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 3: DIVISÃƒO TREINO/TESTE\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "X_train, X_test, y1_train, y1_test = train_test_split(X, y1, test_size=0.2, random_state=42)\n",
        "_, _, y2_train, y2_test = train_test_split(X, y2, test_size=0.2, random_state=42)\n",
        "_, _, y3_train, y3_test = train_test_split(X, y3, test_size=0.2, random_state=42)\n",
        "\n",
        "print(f\"âœ… Dados divididos em 80% treino e 20% teste.\")\n",
        "print(f\"   Tamanho do treino: {len(X_train)} jogadores\")\n",
        "print(f\"   Tamanho do teste:  {len(X_test)} jogadores\")\n",
        "\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "# CÃ‰LULA 6: DEFINIÃ‡ÃƒO DOS MODELOS A SEREM TESTADOS\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 4: DEFINIÃ‡ÃƒO DOS MODELOS\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "modelos = {\n",
        "    'Linear Regression': LinearRegression(),\n",
        "    'Ridge': Ridge(alpha=1.0),\n",
        "    'Random Forest': RandomForestRegressor(n_estimators=100, max_depth=10, random_state=42, n_jobs=-1),\n",
        "    'Gradient Boosting': GradientBoostingRegressor(n_estimators=100, max_depth=5, random_state=42),\n",
        "    'XGBoost': xgb.XGBRegressor(n_estimators=100, max_depth=6, learning_rate=0.1, random_state=42, n_jobs=-1),\n",
        "    'LightGBM': lgb.LGBMRegressor(n_estimators=100, max_depth=6, learning_rate=0.1, random_state=42, n_jobs=-1, verbose=-1),\n",
        "    'CatBoost': CatBoostRegressor(iterations=100, depth=6, learning_rate=0.1, random_state=42, verbose=False)\n",
        "}\n",
        "print(f\"âœ… {len(modelos)} modelos definidos para teste.\")\n",
        "\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "# CÃ‰LULA 7: FUNÃ‡ÃƒO DE TREINAMENTO E AVALIAÃ‡ÃƒO\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "def treinar_avaliar_modelo(modelo, X_train, X_test, y_train, y_test):\n",
        "    \"\"\"FunÃ§Ã£o para treinar, prever e avaliar um modelo, retornando as mÃ©tricas e o modelo treinado.\"\"\"\n",
        "    modelo.fit(X_train, y_train)\n",
        "    y_pred = modelo.predict(X_test)\n",
        "    r2 = r2_score(y_test, y_pred)\n",
        "    rmse = np.sqrt(mean_squared_error(y_test, y_pred))\n",
        "    mae = mean_absolute_error(y_test, y_pred)\n",
        "    return {'modelo': modelo, 'y_pred': y_pred, 'r2': r2, 'rmse': rmse, 'mae': mae}\n",
        "\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "# CÃ‰LULA 8: TREINAMENTO E AVALIAÃ‡ÃƒO DE TODOS OS MODELOS\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 5: TREINAMENTO E AVALIAÃ‡ÃƒO DOS MODELOS\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "# --- Target 1 ---\n",
        "resultados_t1 = {}\n",
        "for nome, modelo in modelos.items():\n",
        "    resultados_t1[nome] = treinar_avaliar_modelo(type(modelo)(**modelo.get_params()), X_train, X_test, y1_train, y1_test)\n",
        "melhor_t1 = max(resultados_t1.items(), key=lambda x: x[1]['r2'])\n",
        "print(f\"ðŸŽ¯ Target 1 | Melhor Modelo: {melhor_t1[0]:<20} | RÂ² = {melhor_t1[1]['r2']:.4f}\")\n",
        "\n",
        "# --- Target 2 ---\n",
        "resultados_t2 = {}\n",
        "for nome, modelo in modelos.items():\n",
        "    resultados_t2[nome] = treinar_avaliar_modelo(type(modelo)(**modelo.get_params()), X_train, X_test, y2_train, y2_test)\n",
        "melhor_t2 = max(resultados_t2.items(), key=lambda x: x[1]['r2'])\n",
        "print(f\"ðŸŽ¯ Target 2 | Melhor Modelo: {melhor_t2[0]:<20} | RÂ² = {melhor_t2[1]['r2']:.4f}\")\n",
        "\n",
        "# --- Target 3 ---\n",
        "resultados_t3 = {}\n",
        "for nome, modelo in modelos.items():\n",
        "    resultados_t3[nome] = treinar_avaliar_modelo(type(modelo)(**modelo.get_params()), X_train, X_test, y3_train, y3_test)\n",
        "melhor_t3 = max(resultados_t3.items(), key=lambda x: x[1]['r2'])\n",
        "print(f\"ðŸŽ¯ Target 3 | Melhor Modelo: {melhor_t3[0]:<20} | RÂ² = {melhor_t3[1]['r2']:.4f}\")\n",
        "\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "# CÃ‰LULA 9: VISUALIZAÃ‡ÃƒO 1 - PREVISTO vs. REAL (GrÃ¡fico de DispersÃ£o)\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 6: VISUALIZAÃ‡ÃƒO - PREVISTO vs. REAL\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "fig, axes = plt.subplots(1, 3, figsize=(18, 5))\n",
        "fig.suptitle('AnÃ¡lise de PrevisÃ£o vs. Valor Real para os Melhores Modelos', fontsize=16, fontweight='bold')\n",
        "\n",
        "# GrÃ¡fico para Target 1\n",
        "y1_pred = melhor_t1[1]['y_pred']\n",
        "axes[0].scatter(y1_test, y1_pred, alpha=0.7, color='blue', edgecolors='k')\n",
        "axes[0].plot([y1_test.min(), y1_test.max()], [y1_test.min(), y1_test.max()], 'r--', lw=2, label='Linha Perfeita')\n",
        "axes[0].set_xlabel('Valores Reais', fontsize=12)\n",
        "axes[0].set_ylabel('Valores Previstos', fontsize=12)\n",
        "axes[0].set_title(f'Target 1 - {melhor_t1[0]}\\nRÂ²={melhor_t1[1][\"r2\"]:.3f}', fontsize=14)\n",
        "axes[0].legend()\n",
        "axes[0].grid(True)\n",
        "\n",
        "# GrÃ¡fico para Target 2\n",
        "y2_pred = melhor_t2[1]['y_pred']\n",
        "axes[1].scatter(y2_test, y2_pred, alpha=0.7, color='green', edgecolors='k')\n",
        "axes[1].plot([y2_test.min(), y2_test.max()], [y2_test.min(), y2_test.max()], 'r--', lw=2, label='Linha Perfeita')\n",
        "axes[1].set_xlabel('Valores Reais', fontsize=12)\n",
        "axes[1].set_ylabel('Valores Previstos', fontsize=12)\n",
        "axes[1].set_title(f'Target 2 - {melhor_t2[0]}\\nRÂ²={melhor_t2[1][\"r2\"]:.3f}', fontsize=14)\n",
        "axes[1].legend()\n",
        "axes[1].grid(True)\n",
        "\n",
        "# GrÃ¡fico para Target 3\n",
        "y3_pred = melhor_t3[1]['y_pred']\n",
        "axes[2].scatter(y3_test, y3_pred, alpha=0.7, color='purple', edgecolors='k')\n",
        "axes[2].plot([y3_test.min(), y3_test.max()], [y3_test.min(), y3_test.max()], 'r--', lw=2, label='Linha Perfeita')\n",
        "axes[2].set_xlabel('Valores Reais', fontsize=12)\n",
        "axes[2].set_ylabel('Valores Previstos', fontsize=12)\n",
        "axes[2].set_title(f'Target 3 - {melhor_t3[0]}\\nRÂ²={melhor_t3[1][\"r2\"]:.3f}', fontsize=14)\n",
        "axes[2].legend()\n",
        "axes[2].grid(True)\n",
        "\n",
        "plt.tight_layout(rect=[0, 0, 1, 0.96])\n",
        "plt.savefig('grafico_dispersao_previsto_vs_real.png', dpi=300, bbox_inches='tight')\n",
        "print(\"âœ… GrÃ¡fico de DispersÃ£o (Previsto vs. Real) salvo como 'grafico_dispersao_previsto_vs_real.png'\")\n",
        "\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "# CÃ‰LULA 10: VISUALIZAÃ‡ÃƒO 2 - IMPORTÃ‚NCIA DAS FEATURES\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 7: VISUALIZAÃ‡ÃƒO - IMPORTÃ‚NCIA DAS FEATURES\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "def plotar_importancia(melhor_modelo_info, target_name, feature_names, ax):\n",
        "    \"\"\"FunÃ§Ã£o auxiliar para plotar a importÃ¢ncia das features em um eixo do matplotlib.\"\"\"\n",
        "    nome_modelo = melhor_modelo_info[0]\n",
        "    modelo = melhor_modelo_info[1]['modelo']\n",
        "\n",
        "    if hasattr(modelo, 'feature_importances_'):\n",
        "        importances = modelo.feature_importances_\n",
        "    else: # CatBoost\n",
        "        importances = modelo.get_feature_importance()\n",
        "\n",
        "    df_importances = pd.DataFrame({'feature': feature_names, 'importance': importances}).sort_values('importance', ascending=True).tail(15)\n",
        "\n",
        "    ax.barh(df_importances['feature'], df_importances['importance'], color='darkcyan')\n",
        "    ax.set_title(f'Top 15 Features - {target_name}\\n(Modelo: {nome_modelo})', fontsize=14)\n",
        "    ax.set_xlabel('ImportÃ¢ncia')\n",
        "\n",
        "fig, axes = plt.subplots(1, 3, figsize=(20, 8))\n",
        "fig.suptitle('AnÃ¡lise de ImportÃ¢ncia das Features para os Melhores Modelos', fontsize=16, fontweight='bold')\n",
        "\n",
        "plotar_importancia(melhor_t1, 'Target 1', X.columns, axes[0])\n",
        "plotar_importancia(melhor_t2, 'Target 2', X.columns, axes[1])\n",
        "plotar_importancia(melhor_t3, 'Target 3', X.columns, axes[2])\n",
        "\n",
        "plt.tight_layout(rect=[0, 0, 1, 0.95])\n",
        "plt.savefig('grafico_feature_importance.png', dpi=300, bbox_inches='tight')\n",
        "print(\"âœ… GrÃ¡fico de ImportÃ¢ncia das Features salvo como 'grafico_feature_importance.png'\")\n",
        "\n",
        "\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "# CÃ‰LULA 11: SALVANDO OS MELHORES MODELOS\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 8: SALVANDO OS MELHORES MODELOS\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "with open('modelo_target1_final.pkl', 'wb') as f: pickle.dump(melhor_t1[1]['modelo'], f)\n",
        "print(f\"âœ… Modelo para Target 1 ({melhor_t1[0]}) salvo como 'modelo_target1_final.pkl'\")\n",
        "\n",
        "with open('modelo_target2_final.pkl', 'wb') as f: pickle.dump(melhor_t2[1]['modelo'], f)\n",
        "print(f\"âœ… Modelo para Target 2 ({melhor_t2[0]}) salvo como 'modelo_target2_final.pkl'\")\n",
        "\n",
        "with open('modelo_target3_final.pkl', 'wb') as f: pickle.dump(melhor_t3[1]['modelo'], f)\n",
        "print(f\"âœ… Modelo para Target 3 ({melhor_t3[0]}) salvo como 'modelo_target3_final.pkl'\")\n",
        "\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "# CÃ‰LULA 12: RELATÃ“RIO FINAL\n",
        "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ðŸŽ‰ FASE 3 COMPLETA - RELATÃ“RIO FINAL ðŸŽ‰\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "print(\"\\nðŸ“Š RESUMO DOS MELHORES MODELOS:\\n\")\n",
        "\n",
        "print(f\"  TARGET 1\")\n",
        "print(f\"  - Melhor Modelo: {melhor_t1[0]}\")\n",
        "print(f\"  - RÂ² (R-quadrado): {melhor_t1[1]['r2']:.4f}  (Explica ~{melhor_t1[1]['r2']:.1%} da variÃ¢ncia)\")\n",
        "print(f\"  - RMSE (Erro MÃ©dio): {melhor_t1[1]['rmse']:.2f} pontos\")\n",
        "print(f\"  - MAE (Erro Absoluto MÃ©dio): {melhor_t1[1]['mae']:.2f} pontos\\n\")\n",
        "\n",
        "print(f\"  TARGET 2\")\n",
        "print(f\"  - Melhor Modelo: {melhor_t2[0]}\")\n",
        "print(f\"  - RÂ² (R-quadrado): {melhor_t2[1]['r2']:.4f}  (Explica ~{melhor_t2[1]['r2']:.1%} da variÃ¢ncia)\")\n",
        "print(f\"  - RMSE (Erro MÃ©dio): {melhor_t2[1]['rmse']:.2f} pontos\")\n",
        "print(f\"  - MAE (Erro Absoluto MÃ©dio): {melhor_t2[1]['mae']:.2f} pontos\\n\")\n",
        "\n",
        "print(f\"  TARGET 3\")\n",
        "print(f\"  - Melhor Modelo: {melhor_t3[0]}\")\n",
        "print(f\"  - RÂ² (R-quadrado): {melhor_t3[1]['r2']:.4f}  (Explica ~{melhor_t3[1]['r2']:.1%} da variÃ¢ncia)\")\n",
        "print(f\"  - RMSE (Erro MÃ©dio): {melhor_t3[1]['rmse']:.2f} pontos\")\n",
        "print(f\"  - MAE (Erro Absoluto MÃ©dio): {melhor_t3[1]['mae']:.2f} pontos\\n\")\n",
        "\n",
        "print(\"ðŸ“ ARQUIVOS GERADOS:\")\n",
        "print(\"  âœ… modelo_target1_final.pkl\")\n",
        "print(\"  âœ… modelo_target2_final.pkl\")\n",
        "print(\"  âœ… modelo_target3_final.pkl\")\n",
        "print(\"  âœ… grafico_dispersao_previsto_vs_real.png\")\n",
        "print(\"  âœ… grafico_feature_importance.png\")\n",
        "\n",
        "print(\"\\nðŸš€ PRÃ“XIMOS PASSOS:\")\n",
        "print(\"  1. Usar os arquivos '.pkl' salvos para carregar os modelos no seu backend (Node.js/FastAPI).\")\n",
        "print(\"  2. Criar as rotas da API que recebem novos dados de jogadores e usam os modelos para prever os targets.\")\n",
        "print(\"  3. Desenvolver o dashboard interativo que consome essa API e exibe os resultados e insights.\")\n",
        "print(\"  4. Preparar a apresentaÃ§Ã£o de slides contando a histÃ³ria do projeto, dos dados aos resultados.\")\n",
        "\n",
        "print(\"\\nâœ¨ Excelente trabalho! A etapa de modelagem e anÃ¡lise estÃ¡ concluÃ­da. âœ¨\")"
      ],
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 1000
        },
        "id": "qrrGV7ZrGYVu",
        "outputId": "f887f2ae-d192-4602-9d5d-bd8c4dd445b9"
      },
      "execution_count": null,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "âœ… Bibliotecas instaladas com sucesso!\n",
            "\n",
            "================================================================================\n",
            "     FASE 3 COMPLETA: MODELAGEM AVANÃ‡ADA + VISUALIZAÃ‡Ã•ES\n",
            "================================================================================\n",
            "\n",
            "================================================================================\n",
            "ETAPA 1: CARREGANDO DADOS LIMPOS\n",
            "================================================================================\n",
            "âœ… Dados carregados com sucesso. Shape: (173, 57)\n",
            "   Total de Jogadores: 173\n",
            "   Total de Colunas: 57\n",
            "\n",
            "================================================================================\n",
            "ETAPA 2: SEPARAÃ‡ÃƒO DE FEATURES E TARGETS\n",
            "================================================================================\n",
            "âœ… Features (X) separadas. Total de features: 54\n",
            "âœ… Targets (y1, y2, y3) separados.\n",
            "\n",
            "================================================================================\n",
            "ETAPA 3: DIVISÃƒO TREINO/TESTE\n",
            "================================================================================\n",
            "âœ… Dados divididos em 80% treino e 20% teste.\n",
            "   Tamanho do treino: 138 jogadores\n",
            "   Tamanho do teste:  35 jogadores\n",
            "\n",
            "================================================================================\n",
            "ETAPA 4: DEFINIÃ‡ÃƒO DOS MODELOS\n",
            "================================================================================\n",
            "âœ… 7 modelos definidos para teste.\n",
            "\n",
            "================================================================================\n",
            "ETAPA 5: TREINAMENTO E AVALIAÃ‡ÃƒO DOS MODELOS\n",
            "================================================================================\n",
            "ðŸŽ¯ Target 1 | Melhor Modelo: CatBoost             | RÂ² = 0.5766\n",
            "ðŸŽ¯ Target 2 | Melhor Modelo: Random Forest        | RÂ² = 0.4057\n",
            "ðŸŽ¯ Target 3 | Melhor Modelo: Random Forest        | RÂ² = 0.4198\n",
            "\n",
            "================================================================================\n",
            "ETAPA 6: VISUALIZAÃ‡ÃƒO - PREVISTO vs. REAL\n",
            "================================================================================\n",
            "âœ… GrÃ¡fico de DispersÃ£o (Previsto vs. Real) salvo como 'grafico_dispersao_previsto_vs_real.png'\n",
            "\n",
            "================================================================================\n",
            "ETAPA 7: VISUALIZAÃ‡ÃƒO - IMPORTÃ‚NCIA DAS FEATURES\n",
            "================================================================================\n",
            "âœ… GrÃ¡fico de ImportÃ¢ncia das Features salvo como 'grafico_feature_importance.png'\n",
            "\n",
            "================================================================================\n",
            "ETAPA 8: SALVANDO OS MELHORES MODELOS\n",
            "================================================================================\n",
            "âœ… Modelo para Target 1 (CatBoost) salvo como 'modelo_target1_final.pkl'\n",
            "âœ… Modelo para Target 2 (Random Forest) salvo como 'modelo_target2_final.pkl'\n",
            "âœ… Modelo para Target 3 (Random Forest) salvo como 'modelo_target3_final.pkl'\n",
            "\n",
            "================================================================================\n",
            "ðŸŽ‰ FASE 3 COMPLETA - RELATÃ“RIO FINAL ðŸŽ‰\n",
            "================================================================================\n",
            "\n",
            "ðŸ“Š RESUMO DOS MELHORES MODELOS:\n",
            "\n",
            "  TARGET 1\n",
            "  - Melhor Modelo: CatBoost\n",
            "  - RÂ² (R-quadrado): 0.5766  (Explica ~57.7% da variÃ¢ncia)\n",
            "  - RMSE (Erro MÃ©dio): 16.25 pontos\n",
            "  - MAE (Erro Absoluto MÃ©dio): 13.75 pontos\n",
            "\n",
            "  TARGET 2\n",
            "  - Melhor Modelo: Random Forest\n",
            "  - RÂ² (R-quadrado): 0.4057  (Explica ~40.6% da variÃ¢ncia)\n",
            "  - RMSE (Erro MÃ©dio): 22.05 pontos\n",
            "  - MAE (Erro Absoluto MÃ©dio): 18.98 pontos\n",
            "\n",
            "  TARGET 3\n",
            "  - Melhor Modelo: Random Forest\n",
            "  - RÂ² (R-quadrado): 0.4198  (Explica ~42.0% da variÃ¢ncia)\n",
            "  - RMSE (Erro MÃ©dio): 16.37 pontos\n",
            "  - MAE (Erro Absoluto MÃ©dio): 14.50 pontos\n",
            "\n",
            "ðŸ“ ARQUIVOS GERADOS:\n",
            "  âœ… modelo_target1_final.pkl\n",
            "  âœ… modelo_target2_final.pkl\n",
            "  âœ… modelo_target3_final.pkl\n",
            "  âœ… grafico_dispersao_previsto_vs_real.png\n",
            "  âœ… grafico_feature_importance.png\n",
            "\n",
            "ðŸš€ PRÃ“XIMOS PASSOS:\n",
            "  1. Usar os arquivos '.pkl' salvos para carregar os modelos no seu backend (Node.js/FastAPI).\n",
            "  2. Criar as rotas da API que recebem novos dados de jogadores e usam os modelos para prever os targets.\n",
            "  3. Desenvolver o dashboard interativo que consome essa API e exibe os resultados e insights.\n",
            "  4. Preparar a apresentaÃ§Ã£o de slides contando a histÃ³ria do projeto, dos dados aos resultados.\n",
            "\n",
            "âœ¨ Excelente trabalho! A etapa de modelagem e anÃ¡lise estÃ¡ concluÃ­da. âœ¨\n"
          ]
        },
        {
          "output_type": "display_data",
          "data": {
            "text/plain": [
              "<Figure size 1800x500 with 3 Axes>"
            ],
            "image/png": "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lnZIy6xYvHgxbt++DV9fX7x79w7h4eGIi4uDkZERbGxs4OLigv79+0uGUHR2dsbu3buxcuVK3L59G3FxcShXrhw6dOiAkSNHYvbs2V88pqOjI44cOYJ9+/bh7NmzePLkCSIjI6Gvrw9ra2u4uLigT58+qFKlSrbOCZDPz2dqaip5AaBJkyYZ9pIpXrw4li1bBh8fHzx48AAfP35EeHg4EhISYGxsjAoVKqBx48bo37+/ZAiz3NalSxcsWbJEMmQhALi5uWW4fk6vw9cMHz4crVu3hre3N27evImgoCDEx8ejRIkS4u/Id999l6Nkc27Q0dGBu7u7JDHt7e2NoUOHiterffv2qFevHvbs2YMrV67g2bNniIqKgo6ODiwsLFCxYkXUrVsXrq6ukpdEXF1dsWXLFqxduxa+vr5ISUlBhQoV0L17dwwcOBCDBw/Ot/OcNGkSnJ2dsW3bNjx69AgA4ODggMGDB6Ndu3aSdfPr/pPXx2natCmOHz+Ov/76CxcvXsTz588RHR0NQ0ND2NraolGjRujbt6/S33Xbtm2hra2Ne/fu4cmTJwgLC8Pnz5/FYT4dHBzQvn17dO7cOU/mnMyqgnyPy4/fayD7bWBra4uFCxfCx8cHDx8+REhICMLDw5GcnAwTExNUrFgRLVu2RJ8+fVCiRImcNkeuyMlvq5ubG8qXLw8vLy/cu3cPiYmJsLOzg5ubG/r37//F2AGQvzh0/Phx/P333zh//jyePHmCiIgIaGlpoVSpUrCzs0Pt2rXRunVr1KxZM1/Oy93dHU5OTrh37x5evnyJ8PBw8TtWunRpODs74/vvv4eLi0uW6kNERESFi5aQX2OsEBEREREREeWy1q1bS3paZzT0KxERERERUVGg/lf1iIiIiIiIiIiIiIiIiChHmPQjIiIiIiIiIiIiIiIi0nBM+hERERERERERERERERFpOM7pR0RERERERERERERERKTh2NOPiIiIiIiIiIiIiIiISMMx6UdERERERERERERERESk4Zj0IyIiIiIiIiIiIiIiItJwTPoRERERERERERERERERaTgm/YiIiIiIiIiIiIiIiIg0HJN+RERERERERERERERERBqOST8iIiIiIiIiIiIiIiIiDcekHxEREREREREREREREZGGY9KPiIiIiIiIiIiIiIiISMMx6UdERERERERERERERESk4Zj0IyIiIiIiIiIiIiIiItJwTPoRERERERERERERERERaTgm/YiIiIiIiIiIiIiIiIg0HJN+RERERERERERERERERBqOST8iIiIiIiIiIiIiIiIiDcekHxEREREREREREREREZGGY9KPiIiIiIiIiIiIiIiISMMx6UdERERERERERERERESk4Zj0IyIiIiIiIiIiIiIiItJwTPoRERERERERERERERERaTgm/YiIiIiIiIiIiIiIiIg0HJN+RERERERERERERERERBqOST8iIiIiIiIiIiIiIiIiDcekHxEREREREREREREREZGGY9KPiIiIiIiIiIiIiIiISMMx6UdERERERERERERERESk4Zj0IyIiIiIiIiIiIiIiItJwTPoRERERERERERERERERaTgm/YiIiIiIiIiIiIiIiIg0HJN+RERERERERERERERERBqOST8iIiIiIiIiIiIiIiIiDcekHxEREREREREREREREZGGY9KPiIiIiIiIiIiIiIiISMMx6UdERERERERERERERESk4Zj0IyIiIiIiIiIiIiIiItJwTPoRERERERERERERERERaTgm/YiIiIiIiIiIiIiIiIg0HJN+RERERERERERERERERBqOST8iIiIiIiIq0G7cuAEHBwesWrVK3VUhIiIi0miMq4gKN111V4CIpBwcHLK0/uPHj/OoJrlr1apV8PT0xLZt29CgQQOVtwsNDcW+ffvg5+eHhw8fIigoCED+n3dSUhIOHTqEEydO4NGjR/j8+TMMDAxgZ2eHpk2bomfPnrC2ts7Wvt+8eYM2bdrAzc0NCxcuVFq+f/9+TJs2TVKmpaUFY2NjyGQy9OjRAz169MjWsfODg4MDXFxcsH37dnVXhYiI1IgxjtTt27dx+vRp3Lx5E0FBQYiJiYG1tTXatGmDESNGwMTEJA9rnVrvtAwNDVG+fHm0adMGw4YNg7GxcZ7WobAaMGAAbt68menyadOmYfDgwflXoRzK7neciIjyDuMqKV9fX+zatQt+fn74+PEjYmNjUaZMGTg6OmLo0KGoUaNGHtaacVVeYlxFlHVM+hEVMB4eHkplW7duRWRkZIbLCrunT59i2bJl0NLSgq2tLYoVK4bY2Nh8rUNQUBBGjRqFgIAAWFhYoHHjxihbtixiYmLw6NEjbNiwAZs2bcLRo0dha2ubZ/Vo1KgR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1aEAAAAXQl5VdeRVAADgfMirqo68CnAdFP0AVEpCQoI6deqk/Pz8X3zOM888o8jISOXk5NRiZLVv3LhxCgsLK/8TGRmpW2+9VXPmzFFhYaHV4QEAABdHXlWBvAoAAFwK8qoK5FUAJMnT6gAAuIe+fftq8+bN+uijj3T33Xefc7ygoED//Oc/1bNnTwUGBtZ+gLXM29tb06ZNkyTl5+fr448/1vz58/X9999r9uzZNfa6d911l+644w55e3vX2GsAAICaRV7ljLwKAABcLPIqZ+RVAJjpB6BSevXqpUaNGmndunXnPf7xxx/r9OnT6tu3by1HVuH06dO19lqenp666667dNddd+mBBx7Q0qVLFRMTow0bNujEiRM19roeHh7y8fGRzWarsdcAAAA1i7zKGXkVAAC4WORVzsirAFD0A1ApDRo00C233KIvvvhCWVlZ5xxfv369GjVqpF69eunkyZN66aWX1KdPH8XGxiouLk6PPvqo9uzZU6nX2rJli+6//37FxMTommuu0YgRI7R//36n57z++usKCwvTvn379Mwzz6hz5866//77y49/8MEH6t+/v6Kjo9WlSxeNGjVK//3vf53OcfDgQT3xxBPq0aOHoqKidN1112nUqFE6depUlfvHZrMpLi5OhmHohx9+cDr26aeflr+f2NhYDR8+XHv37nV6zp49ezRu3DjdeOONioqKUo8ePfTcc8+ds/TE+dZIT0tL09ChQ9W1a1dFR0erV69eeu6556r8HgAAQO0gr7ow8ioAAFBZ5FUXRl4F1D8s7wmg0vr06aP3339fH374oQYPHlzefvLkSf373//WHXfcoQYNGmjv3r366KOPdNttt6l169Y6ceKE/vKXv2jw4MHasGGDWrRo8YuvkZKSomHDhql169ZKTEzUmTNntGLFCg0aNEjvvfeeWrdu7fT8p556Sm3bttWoUaNkGIYkacGCBZozZ4569+6te+65R9nZ2VqxYoUeeOABrV27Vo0bN1ZRUZGGDh2qoqIiDR48WEFBQTp69Kg++eQT5eXlyd/fv8r98+OPP0qSGjduXN62du1ajRs3Tj179lRSUpIKCgq0atUq3X///Xr//ffL309KSop++OEH9e/fX82aNdPevXu1evVq7du3T6tXr/7FkVJZWVkaOnSoAgMDNXz4cDVu3FiHDx/Wpk2bqhw/AACoPeRVF0ZeBQAAKou86sLIq4B6xgCASiopKTF69Ohh3HfffU7tq1atMkJDQ41//etfhmEYRmFhoVFaWur0nB9++MGIjIw0kpOTndpCQ0ONNWvWlLfdddddRvfu3Y2cnJzytoyMDKNDhw7G2LFjy9vmzp1rhIaGGqNHj3Z6ncOHDxvh4eHGggULnNq/+eYbo2PHjuXtu3fvNkJDQ40PP/ywyv3w7LPPGjExMUZWVpaRlZVlHDp0yFi6dKkRFhZm3HnnnYbD4TAMwzDy8/ONa665xpgwYYLT9x8/fty4+uqrndoLCgrOeZ3169cboaGhxtatW8vb1qxZY4SGhho//PCDYRiGsWnTJiM0NNTYuXNnld8HAACwDnmVibwKAABcKvIqE3kVAMMwDJb3BFBpHh4euuOOO5Samuo0XX/9+vUKCgpS9+7dJZmbBtvt5q+X0tJS5eTkqGHDhrryyiu1e/fuXzz/sWPHlJGRoX79+qlJkybl7R06dFB8fLw+/fTTc77nd7/7ndPjTZs2yeFwqHfv3srOzi7/ExQUpLZt2+rLL7+UJPn5+UmS/v3vf6ugoKDKfXH69Gl1795d3bt3180336yXXnpJcXFxmj9/fvkop5SUFOXl5emOO+5wisVut6tTp07lsUjmchRlCgsLlZ2drU6dOkmS0tPTfzGOshFen3zyiYqLi6v8PgAAgDXIqyqQVwEAgEtBXlWBvAoAy3sCqJI+ffrorbfe0vr165WQkKDMzEx9/fXXGjJkiDw8PCRJDodDf/rTn7Ry5UodPnxYpaWl5d9/dnL0c0eOHJEkXXnlleccCwkJ0b///W+dPn1aDRs2LG//+fIJBw8elGEYuuWWW877Gp6e5q+9Nm3a6JFHHtGyZcu0bt06XXPNNerVq5f69u1bqaUSfHx8tHDhQklSZmamlixZoqysLPn4+DjFIkkPPfTQec9RlshJ5pITycnJ2rhx4zlr0F9ozfYuXbro1ltvVXJyst566y116dJFN910k/r06SNvb+9ffR8AAMA65FUm8ioAAHCpyKtM5FUAKPoBqJLIyEi1b99eGzZsUEJCgtavXy/DMNSnT5/y5yxcuFBz5szRgAED9NRTTykgIEB2u13Tp08vX8e8upydtEhmAmez2bR48eLypO5sZydg48aNU79+/fTxxx/r888/17Rp07Ro0SKtXr1awcHBF3xdDw8PxcfHlz/u2bOnevfurYkTJ5YnV2Xv9eWXX1azZs3Oe44yTz/9tFJTUzV06FCFh4erYcOGcjgcevTRRy/YZzabTXPnztX27du1efNm/etf/9L48eO1bNky/eUvf1GjRo0u+D4AAIB1yKtM5FUAAOBSkVeZyKsAUPQDUGV9+vTRnDlztGfPHq1fv17t2rVTdHR0+fH/+7//U9euXTV9+nSn78vLy1NgYOAvnrdVq1aSpO++++6cYwcOHFBgYKBTEnQ+V1xxhQzDUOvWrc87AuvnwsLCFBYWpscff1zbtm3ToEGDtGrVKo0aNepXv/dszZs318MPP6zk5GRt375dMTExatOmjSSpadOmTgnXz+Xm5mrLli164oknlJiYWN5eNvKqMmJiYhQTE6NRo0Zp3bp1SkpK0saNGzVw4MAqvQ8AAFC7yKvORV4FAAAuBnnVucirgPqHPf0AVFnZKKm5c+cqIyPDadSUZI4I+vlonw8//FBHjx694HmbN2+u8PBwrV27Vnl5eeXt3377rT7//HNdf/31vxrbLbfcIg8PDyUnJ58Tg2EYysnJkSTl5+erpKTE6XhoaKjsdruKiop+9XXOZ/DgwfL19dUbb7whSbr22mvl5+enRYsWnXf98uzsbEk67wgvSXr77bd/9TVzc3PPeZ/h4eGSdNHvAwAA1B7yqvMjrwIAAFVFXnV+5FVA/cJMPwBV1qZNG8XGxurjjz+WpHOSqBtuuEHz5s3Tc889p9jYWH377bdat25d+UiiCxk7dqyGDRum++67T/fcc4/OnDmjFStWyN/f32lU0S+54oor9PTTT2v27Nn68ccfddNNN6lRo0Y6fPiwPvroI917770aOnSovvjiC02ZMkW33Xab2rVrp9LSUn3wwQfy8PDQrbfeelH9EhgYqP79+2vlypXav3+/QkJC9MILL2js2LHq37+/br/9dl122WU6cuSIPv30U8XFxWnixIny8/NT586dtWTJEhUXF6tFixb6/PPPnTaf/iXvv/++Vq1apZtuuklXXHGFfvrpJ61evVp+fn667rrrLup9AACA2kNedX7kVQAAoKrIq86PvAqoXyj6Abgoffr0UWpqqqKjo9W2bVunYwkJCSooKNC6deu0ceNGdezYUYsWLdLs2bN/9bzx8fFasmSJ5s6dq7lz58rT01OdO3fWmDFjKpWESdLw4cPVrl07vfXWW5o3b54kKTg4WD169FCvXr0kmcsk9OzZU5s3b9bRo0fl6+ursLAwLV68WDExMVXrjLM88sgjeuedd7R48WLNnDlTffr0UfPmzfXGG29o6dKlKioqUosWLXTNNdeof//+5d83e/ZsTZ06VStXrpRhGOrRo4cWL16sa6+99oKv16VLF6WlpWnjxo06ceKE/P39FR0drVmzZlW6vwAAgLXIq86PvAoAAFQVedX5kVcB9YfNqO5dSgEAAAAAAAAAAADUKvb0AwAAAAAAAAAAANwcRT8AAAAAAAAAAADAzVH0AwAAAAAAAAAAANwcRT8AAAAAAAAAAADAzVH0AwAAAAAAAAAAANwcRT8AAAAAAAAAAADAzVH0AwAAAAAAAAAAANwcRT8AAAAAAAAAAADAzVH0AwAAAAAAAAAAANwcRT8AAAAAAAAAAADAzVH0AwAAAAAAAAAAANwcRT8AAAAAAAAAAADAzVH0AwAAAAAAAAAAANzc/wNlbWI5n5GAGgAAAABJRU5ErkJggg==\n"
          },
          "metadata": {}
        },
        {
          "output_type": "display_data",
          "data": {
            "text/plain": [
              "<Figure size 2000x800 with 3 Axes>"
            ],
            "image/png": "iVBORw0KGgoAAAANSUhEUgAAB8YAAAMUCAYAAADOvk1nAAAAOnRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjEwLjAsIGh0dHBzOi8vbWF0cGxvdGxpYi5vcmcvlHJYcgAAAAlwSFlzAAAPYQAAD2EBqD+naQABAABJREFUeJzs3Xdc1eX///EnMhRDQRHNbZrgXjlzFZkDzXLkHqllfsxZ+XWlpVnasMyRaebee48yUXPhwgHunThRwS3r/P7gxzsO54iALA+P++3m7eZ5z+u63me8eL/e13XZmUwmkwAAAAAAAAAAAAAAsFGZ0roAAAAAAAAAAAAAAACkJBLjAAAAAAAAAAAAAACbRmIcAAAAAAAAAAAAAGDTSIwDAAAAAAAAAAAAAGwaiXEAAAAAAAAAAAAAgE0jMQ4AAAAAAAAAAAAAsGkkxgEAAAAAAAAAAAAANo3EOAAAAAAAAAAAAADApjmkdQEAAACQOsLDwzV9+nSFhYUpc+bM6ty5szJnzpzWxQKSXWBgoLZs2SJJKlOmjN588800LhEAAAAAAADSGolxAACADOK7777TnDlz5OTkpEmTJpEUh0168OCB+vbtq3///VeS5OzsrBUrVuiVV15J45IBAAAAAAAgLTGUOgAAQAq5ffu2ypQpIy8vL7N/vr6+qV6W9evXG0nxiRMnqk6dOla3i11Ob29vs3XLly83Wz9hwoTUKHqKScv6dOzY0ezcy5cvT7Vz27pvv/1W//77r2rWrKkuXbro0aNH+r//+z9FRESkddEMEyZMSLfX39vb26xs6dnly5ctvl/j+3f8+PG0LjLwQnraZ2369OlP3WfkyJFW90lOGSlmSU1xfwe8vLzUo0ePp26/ceNGq9faz88v1crs5+dndu5BgwYl27HT8282AAAAEo/EOAAAQApZvXq1wsPDLZavWLEiVctx9uxZDR061EiK161bN1XPDyRVYpO0f//9t5YuXaqyZctqwoQJGjhwoN59910dOXJEv/32WyqUGIgfCRbYknnz5ikqKspi+b1791I91kHK2rZtmy5dumR13ezZs1O5NAAAAEDSMZQ6AABACnnaTeEtW7YoJCREbm5uqVKOkydPqmvXrqpSpYqqV6+e5OPkz59fDRo0MF4XK1YsOYoHJJvr16+rd+/eateunV566SVJ0T3IixcvroiICIWFhcnJySmNSxn92Yn9WcqfP38alsa2xG7XuLJly5aKJQFs3+XLl7VlyxbVq1fPbPnSpUv18OHDNCoVUkJUVJTmzp2rIUOGmC0PDAzUgQMH0qhUAAAAQOKRGAcAAEgBx44d04kTJ4zXjo6ORu/x8PBwrV27Vh06dEiVsvj4+CTLcapVq6Zq1aoly7GAlNCuXTuLZQ4ODvroo4/SoDRP5+Pjk2yfS5gbP358WhcByFDmzJljlhiPSaDC9ixfvlx9+/Y1HjyT6C0OAACAFw+JcQAAgBQQd3jcXr166eeffzZb/7TEuLe3t4KCgozXJ0+e1KZNmzR37lwdO3ZM4eHhevXVV9WpUye99957FvuvWrVK+/bt08mTJ3Xz5k2FhoYqLCxMLi4uKlKkiF5//XW1b99euXLlSnSdBg8ebFan3r17G68fPnyoBQsWaMuWLTp37pzu3bsnR0dHubm5KW/evCpTpoxq1KihN9980+LYly5d0oIFC7R7925dvnxZjx8/lqurq8qUKaNmzZqpQYMGsrOzS1R5JenRo0eaNm2a1q5dq6CgILm6uqpmzZpm5X6W/fv3a8mSJfL399fNmzcVEREhDw8PValSRe3bt1e5cuUSXa5n6dixo/bu3Wu8/vvvv3XgwAHNnTtXp0+fVpYsWVSzZk3169dPBQsWVFhYmKZPn66VK1ca9axdu7b69++v3Llzmx17woQJmjhxovF69OjRqlixoiZNmqQ9e/YoJCREefPmlY+Pj7p37252Azy2I0eOaNGiRTpw4ICuX7+u8PBwubm5qWTJkmrYsKHeeecdi97Zfn5+6tSpk/G6WbNmGjBggH799Vf5+vrqxo0bqlixooKCgsw+AzHiDqd+8uRJSdKJEye0Zs0anThxQv/++69CQ0N1//59OTk5KU+ePCpfvrzef/99Va5c2eKYgwYNMhvdYfbs2cqWLZumTJmivXv36t69e8qbN68aN26snj17PrXHeWBgoBYvXqyDBw/q6tWrxnu4YMGCqlatmllbWrsGzZs3N177+vpq+/btOnHihK5fv67Q0FA9fvxYWbNmVcGCBVW1alW1b99eBQsWtFqWZzl48KAmT56sQ4cOKTw8XEWLFlXr1q3VqlWrePcLCwvTzJkzdeLECZ0+fVp37txRaGioJMnV1VWenp6qV6+eWrZsabWdDh8+rPnz5+vQoUPGeyZbtmzKmTOnihcvrrJly+rdd9+Vh4dHkuqVWBEREdqwYYPWrVunY8eO6c6dO3JwcFCBAgVUq1Ytde7cWS+//LLFfkm5PnGveYzBgwebfa/GvBee9X0rmX8e8ufPry1bthivre3/3nvvadKkSdq5c6du3bqlpk2basyYMcY2N27c0MKFC7Vjxw5duHBBDx48kIuLi0qWLKnGjRvrvffek6Ojo0Udkvu6WvueGDp0qH777Tf9+eefunbtmrJnz65atWqpV69eFp+DO3fuaP78+Tpx4oTOnTunkJAQhYaGyt7eXjly5FCJEiXk4+OjJk2aKFMm89nlEtNuz3OehErK96yU8p81V1dXPXnyRI8fP9aePXt06tQpeXp6SooeFefy5cuSpDx58uj69evPPN7jx4+1YsUKbd68WSdOnFBoaKgyZ86swoULy9vbW+3bt1eOHDmSVNbYQkJC9Ntvv+mvv/7S9evX5erqqjp16qhfv37KkyeP1X3Onj2rBQsWaO/evQoKCtKTJ0+ULVs2FS9eXG+99ZZatmxp8Tt5+fJlvfXWW8brqlWr6rffftPUqVO1ceNGXblyRR4eHmaf2aS2wdWrVzV79mwjfnr48KFeeuklubm5qXDhwipbtqzefvttlSpVKsntFnMd7927p5UrV6p9+/aSpODgYK1bt87YLnfu3Lpx40a8x4qKitLmzZu1Zs0aHT16VLdv35adnZ1y5cqlChUqqEWLFnr99det7hsREaG5c+dq2bJlunDhgrJmzaoqVaqoZ8+eCa7LiRMntGDBAu3fv19Xr15VWFiYcubMqQoVKqh169aqWbNmgo+VXPVat26d1qxZo+PHj+v27dsymUxyc3NT7ty5VbJkSZUpU0atWrWSvb19ksoGAAAAcyTGAQAAkllMj/AYWbNmVefOnbVlyxYdPnxYUnQSLfaN5PgMHDhQK1euNFsWGBiogQMHKiQkRB988IHZut9//12nT5+2OE5ISIgOHTqkQ4cOaf78+Zo5c6ZKliyZ+ApaERYWpg4dOigwMNBseXh4uB4+fKgrV67owIED2r9/v0VifN68eRo9erTFfOzBwcHaunWrtm7dqjp16mj8+PFydnZOcJnu37+vzp07KyAgwOyYq1at0ubNm9WkSZN494+IiNCwYcOszgEck7hdtWqV/ve//6lv374JLldSjB49Wps3bzZeP3r0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NHr0aH344Yfq3r27GjRooPz588vf31979+412i6p269atUqLFi1SlSpVjKd3z5w5o+3bt8vNzc2sbatXr65NmzapT58+ql27tjJnzqwSJUrI29vb2Gbnzp2SlOD3KAAAGRlxYOrFgfH56KOPtGjRIs2cOVMdO3ZU9uzZ1aFDB+3YsUPt2rVTo0aN5OTkpL179+r69euqWrWq1R5RiVG4cGH17NlTEyZMMOptb2+vP//8U15eXlZ7dH311Vdq166dhg0bJl9fX7366qs6ffq0tmzZopw5c+qrr756rjKlpKRc5/jUqVNHPXv21K+//qr69eurdu3aypcvn0JCQnTx4kUdOHBA/fr1U7FixfT48WO1bdtWRYoUUZkyZZQ3b149fPhQW7du1c2bN9W1a1fjodGiRYsqd+7cWrdunZycnJQnTx7Z2dmpY8eOxjCkDx480OHDh/X6668ra9asKdJeAAAkN+JO4k7iTuJOIClIjANIdu+//74mT56s1atXJygwTaxGjRrJw8NDU6ZM0V9//aVHjx4pf/786tmzpz766COzHsFS9BNz2bJl06+//qoVK1YoW7Zs8vb21oABA6w+Tefk5KTff/9dS5cu1cqVK/Xnn38qLCxMuXLlUrFixdSmTZsEDfXSpUsXFSpUSDNnztTq1asVHh6uIkWKaNCgQerYseNT53lJjCxZsuinn35Sy5YttWzZMvn7++uff/6RJOXNm1c+Pj5q1aqVMde3vb29pkyZoh9//FH//POPjh49qsKFC+v//u//VKdOHauJ8Z49e+ru3bvy9fXVgQMHFBkZqV69elkkxidOnGi8dnJy0ssvv6y2bduqe/fuRk/1GJUrV9aiRYs0adIk7dy5U/fv31fu3LnVqVMn/e9//7OYYyYx2zdp0kRPnjyRv7+/jhw5orCwMKMs3bp1MytLq1atFBQUpPXr12vatGnGE7+xE+Nr1qxRyZIljTYEAABPRxwYLTXiwPjkypVLbdu21fTp0zVjxgz17dtXb775psaPH68pU6Zo9erVypIli6pXr65JkyZp0qRJyXLeXr16KU+ePJo5c6YWLlwod3d3+fj4qG/fvipfvrzF9kWLFtWyZcs0ceJE/fPPP9q2bZty5Mih5s2bq1evXhZzKKY3yX2d+/btqypVqmj27NnavXu37t27Jzc3NxUoUEC9evXSO++8I0ly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O1tpaWnq1q2bOnbsqJkzZ2r37t3KycmRJDVo0KDWvj/77DOlpKR4Il0AAAC40alTp7R27Vo9/PDD+sMf/qB33nnH5flNmzYpJSVF0dHRiouL08iRI53P/fjjj5owYYL+4z/+Q507d9YTTzyhf/3rX87n3377bXXt2lUfffSR+vTpo+joaB07dkylpaUaPny4OnXqpMTERL333nu14lqxYoXuvfdexcTEqEePHsrIyNCpU6d+ddsAAABwP09ef/w1drtdq1at0rBhw9S5c2f17t1bu3fvVmFhoQYNGqSYmBg99NBDOnz4sMvrNm7cqL59+yo6Olq33367Fi1apLNnzzqfv9R+c8uWLerdu7e6dOmiIUOGqKio6IryAAAAMFKg0QH4g7y8PFVWVqp79+7OZZGRkWrevLlycnIUExNT6zVr1qxRgwYN9Mc//tGLkQKAf3M4HIbu16j9w/04pnWjHhf24Ycf6uabb9bNN9+s++67TzNnztSwYcNUr149bd68WampqRo+fLjmzJmjyspKffzxx87XpqWlqbCwUP/n//wfNW7cWHPnztXQoUP1wQcfKCgoSJJUXl6upUuXasaMGbr22msVHh6u0aNHq6ioSG+88YYCAwM1Y8aMWj/BU69ePaWnp6tly5Y6cuSIMjMzNXfuXGVkZDjXqWvbgL9zx/nKiu8F5GwdVszbijlL/pu3v8XrL15++WWlpaUpLS1N8+bN09NPP61WrVpp6NChat68uSZPnqznnntOy5YtkyR98cUXmjhxoqZMmaKuXbvq8OHDmjp1qiQ574R5qf3mq6++qjlz5iggIEDPPvusZs+erfnz53u9BgCswczvI/763u5O1IAaSO6tweVswzSD8c2bN6tLly7OxwkJCVq4cKFbtl1SUqKgoCBdc801LsvDw8NVXFxc52tWr16te+65Rw0aNHBLDABgBQUFBSorKzNs/7m5uYbtG57BMcWlWr16te677z5J5/rIn376SZ9//rni4uK0ePFi9enTR6NHj3au365dO0nSv/71L23atEn/+Z//qdjYWEnSvHnz9Ic//EEbN25U7969JUmVlZXKyMhwvu7QoUP65JNP9N///d/q1KmTJOn5559Xnz59XOJ69NFHnf/dsmVLjR07VtOnT3e5UPnLbQNm4M6ewIrvBeRsHVbM24o5S9bN29d48vrjpUhOTnb2i08++aT69++vESNGKCEhQZI0ePBgTZo0ybn+okWLNHToUPXt21eS1KpVK40ZM0Zz5851DsYvtd/MzMzUTTfdJEkaMGCAXn75ZU+mCsDijL5G6A28t1MDiRpI3q+BaQbjcXFxLg1bSEiIYbHs3r1b33zzjebMmWNYDADgj+x2uyH7dTgcys3NVXR0tGw2myExwL04pnWrqQtcHTx4ULm5uXrppZckSYGBgerTp49Wr16tuLg45efn68EHH6zztd98840CAwPVuXNn57LrrrtOv/3tb/XNN984lwUFBbmc42pe17FjR+eyyMjIWh/E3LZtm5YsWaKDBw/q559/lsPh0JkzZ1RWVubsd3+5bcAM3PH/tBXfC8jZGjlL1szbijlL/pu3WftOo68/nv/+WHOXoLZt27osO3PmjH7++Wc1btxY+/bt065du7R48WLnOr/sJy+l3wwJCXEOxSWpWbNmte50BADuZOZ/4/rre7s7UQNqILm3BpfTe5pmMB4SEqLWrVt7ZNsRERGqrKzUyZMnXS5WlpaWqmnTprXW/+///m9FRUW5XOgEAPw6o5sAm81meAxwL44pLsXq1at19uxZ5zdtJKm6ulrBwcGaNm2aW+4A1KBBA9WrV++yXnP06FENGzZMDz/8sMaNG6ewsDDt3LlT6enpqqysdF6ovJJtA77OneduK74XkLN1WDFvK+YsWTdvX+PJ64+XouZneiQ5+7+6llVVVUmSTp8+rVGjRumuu+6qta369etfcr8ZGOh6CblevXqqrq52b3IAcB4rvOfx3k4NJGogeb8GphmMe1LHjh0VFBSk7du3q1evXpLOfbPo2LFjtX5f/NSpU/rwww/19NNPGxApAAAALsfZs2f17rvvKi0tTf/f//f/uTw3cuRIvf/++2rbtq22b9+ulJSUWq+PjIzU2bNn9eWXXzpvpf7DDz/o0KFDatOmzQX3e/PNN+vs2bPKy8tz3kr94MGDOnnypHOdvXv3qrq6WmlpaQoICJB07rfQAQAAgEvRvn17HTp06ILDfPpNAABgNaYfjJ86dUqHDx92Pj569Kjy8/MVFham5s2bS5JOnDih7777TkVFRZLO/eajdO6b4k2bNlVoaKhSUlI0a9YshYWFqXHjxpoxY4a6dOlSazC+du1aORwO529UAgAAwHdt3rxZP/74ox544AGFhoa6PHfXXXdp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rby8PBUWFmrQoEFKT093Wee//uu/tGbNGn399deSpA4dOmj8+PHO66sAAAD+whSDcUlKSEhQVlaWy7ImTZpo7dq1ysrKUmZmpjp37qzXX39dQ4YM0bp16xQeHq4bb7xRW7dudXndW2+9peXLl+u2226TJDkcDg0bNkwRERFatWqVioqKNHHiRAUFBWn8+PGSpPT0dD399NPObTgcDt1///364x//6OHMAQAArO1CfeC//vUv2e12paSkKDU1tc7Xnj59WrGxserdu7emTJnijXABAADgQ86/Lrh27VotXLhQ69atcy5r2LChEWFdspSUFH355ZcqKCio9ZzD4VD9+vU1aNAgrV+/vs7XV1RU6LrrrtNTTz2l1157rc51PvvsM919992KjY1VcHCwli1bpscff1wffPCBrr/+enemAwAA4FGmuZV6cHCwmjZt6vLHZrNpxYoV6tevn1JSUtSmTRtlZmaqQYMGys7OliTZbLZar9u4caN69+6tRo0aSTrXIB84cEBz585VVFSUevTooTFjxmjlypWqqKiQJIWGhrpsIy8vTz/++KOSk5MNqwkAAIAVXKgP7NGjh8aNG6c777zzgq9NSkpSamqqunXrdkX7ttvtWrVqlYYNG6bOnTurd+/e2r17t/PbNjExMXrooYd0+PBhl9dt3LhRffv2VXR0tG6//XYtWrRIZ8+edT6/YsUK3XvvvYqJiVGPHj2UkZGhU6dOOZ9/++231bVrV23ZskW9e/dWly5dNGTIEBUVFV1RHgAAAFZ1fg8ZGhqqevXquSxbu3atevfurejoaP3xj3/UypUrna89evSo7Ha71q5dq0ceeUSdOnVSSkqKDh06pD179ig5OVldunTRE088oePHjztfl5aWphEjRmjRokX6/e9/r9jYWE2bNs15nVE6N7CeMWOGunXrpujoaD388MPas2ePS+xTpkzRgAED1KpVqzpza9iwoTIzM9WvXz81bdq0znVatmypKVOmKCkpSaGhoXWuM3/+fA0YMEBRUVGKjIzUjBkzVFVVpe3bt19ynQEAAHyBab4xXpeKigrt3btXw4YNcy4LCAhQ9+7dtXv37jpfk5eXp/z8fE2bNs25LCcnR23btlVERIRzWXx8vDIyMnTgwAG1b9++1nZWr16t7t27q0WLFm7MCMCFOBwOr+/Lm/uEZ3FMzYdjWjfq4Rkv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tHTp0lrbeO2119SrVy916tRJPXr00MyZM3XmzJlL2v+OHTs0fPhwxcfHy263a+PGjZf0us8++0x9+/Z1xvz2229fetIAAADwC+f3quf/KSwsvKQ+csOGDXr88ccVFxcnu92u/Pz8WuucOXNGmZmZiouLU5cuXTRq1CiVlJS4rDNjxgwlJyerY8eOuv/++z2WLwAAANzjaq95VlZWatGiRbrjjjsUHR2t++67T5988skl759rngAAwOp8cjAuSQkJCdq6davWr1+vxx57TIsWLdLy5cv1888/a8iQIWrevLnefvttTZgwQYsWLdJbb73lfO3f//53zZ8/X6mpqVq7dq2ef/55rV27Vn/5y18uad+nT5+W3W7X9OnTLzneI0eOaNiwYYqLi9O7776rP/3pT5oyZYq2bNly2bkDAADAt9X0quf/admy5SX1kadPn1ZsbKyeeeaZC64zc+ZM/eMf/9CCBQv05ptvqqioSKmpqbXWS0lJUZ8+fdySEwAAADzvaq55LliwQG+99ZamTp2qtWvX6qGHHlJqaqq++uqrS9o31zwBAIDVBRodwIUEBweradOmkqRHHnlEGzdu1KZNmxQaGqrKykrNnDlTwcHBuuWWW5Sfn68VK1aof//+kqTdu3crNjZW9957rySpZcuWuueee/Tll19e0r579OihHj16XFa8q1atUsuWLZWWliZJioyM1M6dO/Xaa68pISHhsrYFAAAA33Z+r3q+S+kjk5KSJElHjx6t8/mffvpJ2dnZmjdvnrp16ybp3KC8T58+ysnJUUxMjCRpypQpkqTjx4+roKDgCjMBAACAN13NNc93331XTz31lLPffOSRR7R9+3a9+uqrmjdv3q/um2ueAADA6nx2MP5L9evX14kTJ5STk6OuXbsqODjY+Vx8fLyWLl2qH3/8UWFhYerSpYvee+897dmzR506ddKRI0f08ccfe/QWkzk5Oc4Ll+fHNXPmTI/tE7gQh8NhdAimVlNf6mweHFPz4ZjWjXr4h7y8PFVWVqp79+7OZZGRkWrevLnLYByX5pf/31vx/GDFnCVr5k3O1mHFvK2Ys+S/eftbvEa6nGuelZWVLs/XvH7Xrl0ei49rnlfvl3+Prfz3w+o1sHr+EjWQqIFEDSRqILm3BpezDZ8fjFdXV2v79u3aunWrBg4cqIKCArVs2dJlnYiICElSSUmJ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X8/25O1j4O35S4yBxBhIjIHEGEj2HYO81J4OaYwHBASoatWqNstSU1Pl6+urlJQUm+UpKSnW4vFmX331la5du6bOnTvnef9Fi/7/aRUpUsTmduayjIwMSTc+8SnduJz6PffcY7NeZhG7Zs0aTZo0ScOHD1e9evVUokQJJSQkaOfOnTnuN3M/zjhACu/lrX9AncXX15cx9zDMqedhTuEo9qh3c1KuXDmdOXPGZtn169d1/vx5m4O9knTfffdJuvEBzfT0dI0aNUq9e/fmeX+TnMbCG/8+eGPOknfmTc7ewxvz9sacJe/NW9Idj635+fllu/zw4cNq3bq1zbK6detmaYyXKFFCK1asyPL4tm3b2mzLYrFYm+KSFB4eroyMDB09etRa69WoUcOmKS7d+KrIadOmad++fTp//rw1n99++00PPvignn32WQ0ePFh79uxRkyZN1Lp161xdPTNzO0WKFJEkHTlyRK1atbJZJzw8XPPnz1d6err1+RMaGpplWwEBAdamuHSjHq1UqZL1MvGZy26tUXFn2b1uvfn1nMnbx8Db85cYA4kxkBgDiTGQCn8MfAprR/7+/goJCdGmTZusyzIyMrRp06ZsP5W5bNkytWzZMstlJO0tODhY/v7+OnXqlKpWrWrzk3mgcdu2bapXr56ef/551apVS1WrVtXx48cdGhcAAADcS17r3ZzUq1dPFy5c0O7du63LNm/erIyMDNWuXTvHxxljdP36desHQAEAANzZ/fffryJFiujw4cPZ3n/48GGVLVtWpUuXLtB+fHx8shwTvPUDkLkVEBBgczvzEuwlSpTQlClTtHTpUk2bNk3SjatVSlLz5s313//+VzExMfrzzz8VExOjSZMm3XFfmeOS2zPMc4pRyv5kn9udaAQAAOCuHHLGeE569eql4cOHKzQ0VLVr19a8efN09epVm8v5SDculbRlyxZ9+umnDo+pZMmS6t27tyZMmCBjjOrXr6+LFy9q27ZtKlmypLp06aKqVatq5cqV2rhxoypXrqx//etf2rVrV54LTwAAAHi23NS7p0+fVnJysvWDlgcOHFCJEiV03333qUyZMgoODlZkZKTefPNNjR49WmlpaRo7dqw6dOhgvcLRqlWrVLRoUVksFvn7+2vXrl1677331L59+xzPmgIAAHAngYGBatKkiT777DPFxMTYfM/46dOntXr1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de3aVaGhoXryySezxHDkyBH17NlTjRs3VlhYmFq1aqX3339faWlpjh8AAAAAOyvq7ABuJzIyUhMmTFBqaqq+/fZbjRkzRn5+fnr++efVp08fNWrUSKNHj9aBAwf0xhtvqHTp0urRo4fNNk6cOKFJkybl62Br5v4z+fv733b9L7/8UhMmTNDo0aNVp04dzZs3T3369NFXX32loKCgPO8fAADAVf3222+Kj4/Xxo0bde7cOZUvX16tWrXSwIEDFRgYKOlGk/aFF15QTExMnra9fPlyvfPOO9q6dWuW+ywWi6ZPn67WrVvbI418s1gs1t8DAgJUoUIFhYeHKzo6WqGhoU6La+nSpQoICHDa/gEAAGBftx6flKSyZcve8Tjkfffdp++++87mcYsWLVJCQoKaNWtms7xbt27auXOn9u/fn2X/fn5+6ty5s0JCQlSqVCnt27dPb775powxGjp0qP0TBgAAcCCXboz7+/urfPnykqTnnntO69at0/r161WqVCmlpaXpnXfekb+/vx566CHt3btXc+bMsWmMp6ena9iwYRo0aJB+/vlnXbhwId/7z405c+bo6aefVrdu3SRJo0eP1oYNG7Rs2TK99NJLedo3AACAq0pKSlKPHj1UrVo1TZ06VZUrV9bBgwf17rvvauPGjVq0aJHKlCnj7DCzlZqaescPO+bWhAkTFBkZqb/++kvHjh3T4sWL9fTTT+udd95R586dnRJj2bJl871fAAAAuJ6cjk/e6Tikr69vlsetW7dO7du3V4kSJazLRo4cKUk6c+ZMto3xKlWqqEqVKtbblSpV0k8//ZTth1gBAABcnUs3xm9111136dy5c9qxY4caNGhgc8CwadOmmjlzps6fP6+7775bkjR9+nQFBQXpqaee0s8//5zn/f30009q1KiRSpcurYYNG2rIkCHWM6BulZqaql9//VUvv/yydZmPj48aN26s7du353nfQG6lp6c7OwSvkznmjL3nYE49D3OaPXuNx+jRo+Xn56fZs2erWLFikqSKFSuqVq1aatOmjd5//30dOXJEJ0+e1IQJE6xnuGQeaFu+fLni4+N19uxZNW3aVPXr1893LPv379f48eO1Y8cOBQQEqG3btoqLi7Me7IuLi9OFCxcUFhamhQsXyt/fX+vXr9fKlSs1f/58HT16VMWLF1fDhg31xhtvWK/yc/78eY0Z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wDvk9TjksmXL1LJly3xfWfNWxhhdv36dOhQAALgdl26M56RTp07y8/PTiBEjdPDgQX355ZeaP3++evXqJUm66667VKNGDZuf0qVLq0SJEtmeMXSry5cva9KkSdqxY4dOnDihTZs2acCAAapataoiIyOt67344ov6xz/+Yb3dq1cvLV68WCtWrNDhw4f19ttv6+rVqzaXyQQAAHBngYGBatKkiT777LMs37l9+vRprV69Wl26dJF046zxWw+WBQcH65dffrFZtnPnznzFEhwcrP379+vKlSvWZdu2bZOPj48eeOCBHB935MgRnTt3TsOGDVODBg0UHByc5WwbSSpbtqy6dOmiKVOm6I033tCiRYvuGNO8efNUsmRJNW7cWNKNS6tv27bNZp1t27apWrVqXv+JYAAAAORfbo9DJiYmasuWLTZfJXTr/Xv37tXp06d17do17d27V3v37lVqaqokadWqVfryyy91+PBhJSUl6csvv9R7772n9u3b53iVKAAAAFfl0pdSz0mpUqWUkJCgMWPGqGvXrgoMDNSAAQPUo0cPu2zf19dXBw4c0MqVK3Xx4kVVqFBBTZo00SuvvGLTVE9KStLZs2ett6OionTmzBnFx8fr9OnTqlmzpmbNmsWl1AEAgEd588039cwzz6hPnz4aMmSIKleurIMHD+rdd99VtWrVrN+nXalSJW3ZskUdOnSQn5+fypYtq549e+rZZ59VQkKCWrVqpe+++y7LZdRzq1OnToqPj1dcXJxiY2N15swZjR07Vk8++eRt66+KFSvKz89PCxYs0LPPPqsDBw7o448/tlnnww8/VEhIiB566CGlpqZqw4YNWb5X/cKFCzp9+rRSU1N17NgxLVq0SOvWrdOkSZOsZ8z37t1b3bt31/Tp0xUVFaUdO3Zo4cKFeuutt/KVMwAAACDl/jjksmXLdO+996pp06bZbmfkyJH66aefrLczL7f+n//8R5UrV1bRokU1a9YsHT16VNKNWjo6OloxMTEOyQsAAMCRXLYxPnHixNve//DDD+uzzz6z2/ZuVqxYMSUkJNxxvfXr12dZFh0drejo6FzvCwAAwN1Uq1bNevnxIUOGKCUlRcYYtW3bVpMnT7ZeFnzw4MEaNWqUWrdurdTUVO3fv19169bV2LFj9dFHHyk+Pl6NGjVS//79szSmcyMgIEAJCQkaP368unfv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iIgI1atXT4MGDVJycrI907ote+ecm//FevbsmWWeR40aZe/UbsveeX/00UdZcnr88cdt1vG0uc7u9WqxWDR69GjrOu4214sXL9Zzzz2nRx55RI888ohiYmKyrO8u79fwfM6oRV2NM+pSV2Pv58HNRo0addsax1U4YgwOHz6sfv36qX79+qpbt666deumU6dOOSqFArP3GFy+fFljxoxRs2bNVLt2bUVFRemf//ynI1MoMGfU8a7GGXW9K3HEcyCTu/QiHDEGDjl+b+AS1qxZY0JCQszSpUvNwYMHzciRI02DBg1McnKys0NDPvTu3dssW7bMHDhwwOzdu9f07dvXPPbYY+by5cvODg12sHPnTtOiRQvTqVMnM27cOGeHg3w6d+6cadGihYmLizM7d+40x48fNxs3bjSJiYnODg359Mknn5hHH33U/Pe//zVJSUlm7dq1pm7dumbevHnODg2wu7zWjj///LOpWbOmmTlzpjl06JB5//33TUhIiNm/f791nRkzZpj69eubb775xuzdu9f069fPtGzZ0ly7ds26Tp8+fcwTTzxhduzYYbZs2WLatGljhg4d6vB8M9k77wsXLpiYmBizZs0ac/jwYbN9+3bTvXt306VLF5vttGjRwkybNs38+eef1p/CquscMdfDhw83ffr0scnn3LlzNtvxtLk2xtjk++eff5qlS5cai8Vijh8/bl3HneZ6586dZuLEieaLL74wTZo0MXPmzMnXNkeNGmWaN29ufvjhB7Nr1y7z9NNPmx49ejgqzTzHd7Pc5Jyb/8Wio6PNyJEjbeb54sWLjkozC0fkHR8fbzp06GCTU0pKis06njbXKSkpNvl+//33pkaNGmbz5s3WddxtrocOHWr+8Y9/mD179phDhw6ZuLg4U79+ffP7779b13GH92t4PmfVoq7EWXWpK3HE8yDTv//9b/PEE0+Ypk2bZvse4CocMQaJiYnm0UcfNZMmTTK//vqrSUxMNOvWrXPZPoEjxmDkyJGmdevWZvPmzSYpKcl8/vnnpmbNmmbdunWFlVaeOKuOdyXOqutdhSPyv3ldd+hFOGIMHHX8nsa4i+jevbsZPXq09XZ6erpp2rSpmTFjhhOjgr2kpKSYGjVqmJ9++snZoaCALl26ZNq2bWu+//57Ex0d7dJvRri9d9991zz77LPODgN29NJLL5nXX3/dZlls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+KJmzJjh7NAAu8pP7ViuXLksZ6PcvH758uWty3Jap1y5cjpz5ozN/devX9f58+etj3ckR+SdKS0tTUOGDNGpU6c0e/bsO56VU6dOHV2/fl0nTpzIRya558icb1alShUFBgYqMTHRug1PnWtJ2rp1q44ePZqrZqErz7U9tlmuXDmlpaXpwoULWdZx9Fw7+v/gvPwvVqdOHUmyvgYcqbD+/y9durSqVaum48ePS/LsuT558qR++OGHbL8a4VbuMtcJCQn69NNPlZCQoIcffti63B3er+H5nFWLuhJXqkudxRFjsHXrVqWkpKhFixbWY28nT57UpEmT1LJlS8ckUgCOGIPAwEAVLVo0y/Gq4OBglzxe5YgxuHbtmt5//329/vrratmypR5++GFFR0crKipKCQkJjkmkAJxVx7sSV6rrncER+btbL8JRzwFHHb+nMe4C/P39FRISok2bNlmXZWRkaNOmTapXr54TI0N+GWM0ZswYffPNN5o3b56qVKni7JBQQA0bNtTq1au1cuVK609oaKg6deqklStXytfX19khIo/Cw8Ot30Wd6dixY6pUqZKTIkJBXbt2Lcunyn19fWWMcVJEgGPkp3asW7euNm/ebLPshx9+UN26dSVJlStXVvny5W22eenSJe3cudO6zXr16unChQvavXu3dZ3NmzcrIyNDtWvXtld6OXJE3tL/f/AxMTFRc+fOVWBg4B1j2bt3r3x8fLJcJszeHJXzrX7//XedO3fOelDaU+c609KlSxUSEmLTbMqJK8+1PbYZGhoqPz8/m3WOHDmiU6dO3fY5Yw+O+j84P/+L7d27V5IKpWlYWP//X758WUlJSdacPHGuMy1fvlxBQUF67LHH7riuO8z1zJkz9fHHH2vWrFk23xMuucf7NTyfs2pRV+JKdamzOGIMnnzySa1atcrm2FuFChXUp08fzZo1y2G55JcjxsDf319hYWFuc7zKEWNw/fp1paWluc3xHWfV8a7Elep6Z3BE/u7Wi3DUc8Bhx+8NXMKaNWtMaGioWb58uTl06JB58803TYMGDczp06edHRry4a233jL169c3P/74o/nzzz+tP1evXnV2aLCj6OhoM27cOGeHgXzauXOnqVWrlvnkk0/MsWPHzKpVq0ydOnXMv/71L2eHhnwaPny4iYyMNP/9739NUlKS+fe//20iIiLM5MmTnR0a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\n"
          },
          "metadata": {}
        }
      ]
    }
  ]
}
</file>

<file path="dashboard/backend/main.py">
# main.py (COM MODELO HÃBRIDO - VERSÃƒO FINAL)

import os
import pickle
import joblib
import pandas as pd
import numpy as np
import shap
from fastapi import FastAPI, Depends, HTTPException, UploadFile, File, status
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError
from sqlalchemy import func
import crud
import models
import schemas
import auth
import database
from sklearn.ensemble import StackingRegressor
from flask_bcrypt import Bcrypt
from core import app
from io import BytesIO

# Cria tabelas no DB (se nÃ£o existirem) ao iniciar
try:
    models.Base.metadata.create_all(bind=database.engine)
except Exception as e:
    print(f"Aviso: NÃ£o foi possÃ­vel criar tabelas do DB na inicializaÃ§Ã£o (pode ser normal se jÃ¡ existirem): {e}")

# --- Carregamento de Artefatos de ML (ATUALIZADO PARA MODELO HÃBRIDO) ---
ARTIFACTS_PATH = os.getenv('ARTIFACTS_PATH', 'ml_artifacts')
MODELS, SCALERS, FEATURES, EXPLAINERS = {}, {}, {}, {}

try:
    # Target 1 (modelo Ãºnico - mantÃ©m compatibilidade)
    MODELS['target1'] = joblib.load(f"{ARTIFACTS_PATH}/modelo_target1.pkl")
    SCALERS['target1'] = joblib.load(f"{ARTIFACTS_PATH}/scaler_target1.pkl")
    with open(f"{ARTIFACTS_PATH}/features_target1.pkl", "rb") as f:
        FEATURES['target1'] = pickle.load(f)
    EXPLAINERS['target1'] = shap.TreeExplainer(MODELS['target1'])

    # Targets 2 e 3 (ensemble de 3 modelos cada - NOVA ESTRUTURA)
    for target in ['target2', 'target3']:
        MODELS[target] = []
        for i in range(3): # Carrega os 3 modelos do ensemble
            model = joblib.load(f"{ARTIFACTS_PATH}/modelo_{target}_ensemble_{i}.pkl")
            MODELS[target].append(model)
        
        SCALERS[target] = joblib.load(f"{ARTIFACTS_PATH}/scaler_{target}.pkl")
        with open(f"{ARTIFACTS_PATH}/features_{target}.pkl", "rb") as f:
            FEATURES[target] = pickle.load(f)
        
        # Cria um explainer para cada modelo do ensemble
        EXPLAINERS[target] = [shap.TreeExplainer(m) for m in MODELS[target]]

    print("âœ… Artefatos de ML e Explainers HÃBRIDOS carregados com sucesso.")
except Exception as e:
    print(f"âŒ ERRO CRÃTICO ao carregar artefatos de ML: {e}")
    MODELS = None # Invalida para a verificaÃ§Ã£o de saÃºde da API

# --- FunÃ§Ãµes de PrÃ©-processamento ATUALIZADAS (Modelo HÃ­brido) ---

def preprocess_target1(df_input):
    """PrÃ©-processamento especÃ­fico para Target 1 (modelo Ãºnico)"""
    df = df_input.copy()
    
    # ConversÃ£o de F0103
    if 'F0103' in df.columns: 
        df['F0103'] = pd.to_numeric(df['F0103'].astype(str).str.replace(',', '.'), errors='coerce')
    
    # IdentificaÃ§Ã£o de colunas
    p_cols = [c for c in df.columns if c.startswith('P') and any(char.isdigit() for char in c)]
    t_cols = [c for c in df.columns if c.startswith('T') and any(char.isdigit() for char in c)]
    f_cols = [c for c in df.columns if c.startswith('F') and len(c) > 1 and any(char.isdigit() for char in c)]
    
    # Engenharia de features - taxas de pulos
    p_minus_ones = sum((df[col] == -1).sum() for col in p_cols if col in df.columns)
    t_minus_ones = sum((df[col] == -1).sum() for col in t_cols if col in df.columns)
    df['taxa_pulos_P'] = p_minus_ones / len(p_cols) if len(p_cols) > 0 else 0
    df['taxa_pulos_T'] = t_minus_ones / len(t_cols) if len(t_cols) > 0 else 0
    df['taxa_pulos_geral'] = (p_minus_ones + t_minus_ones) / (len(p_cols) + len(t_cols)) if (len(p_cols) + len(t_cols)) > 0 else 0

    # Processamento de colunas numÃ©ricas
    for col in p_cols + t_cols + f_cols:
        if col in df.columns:
            df[col] = pd.to_numeric(df[col], errors='coerce').replace(-1, np.nan)
            df[col].fillna(df[col].median(), inplace=True)
            
    # Features de sono
    if 'QtdHorasDormi' in df.columns and 'Acordar' in df.columns:
        df['sono_total'] = df['QtdHorasDormi']
        df['sono_x_acordar'] = df['QtdHorasDormi'] * df['Acordar']
        df['sono_squared'] = df['QtdHorasDormi'] ** 2
        df['sono_irregular'] = np.abs(df['QtdHorasDormi'] - df['QtdHorasDormi'].median())

    # EstatÃ­sticas das colunas P
    if p_cols: 
        df['P_mean'] = df[p_cols].mean(axis=1)
        df['P_std'] = df[p_cols].std(axis=1)
        df['P_min'] = df[p_cols].min(axis=1)
        df['P_max'] = df[p_cols].max(axis=1)
        df['P_range'] = df['P_max'] - df['P_min']
        df['P_late'] = df[['P09', 'P12', 'P13', 'P15']].mean(axis=1) if all(c in df.columns for c in ['P09', 'P12', 'P13', 'P15']) else 0
        df['P_early'] = df[['P01', 'P02', 'P03', 'P04']].mean(axis=1) if all(c in df.columns for c in ['P01', 'P02', 'P03', 'P04']) else 0
    
    # EstatÃ­sticas das colunas T
    if t_cols: 
        df['T_mean'] = df[t_cols].mean(axis=1)
        df['T_std'] = df[t_cols].std(axis=1)
        df['T_min'] = df[t_cols].min(axis=1)
        df['T_max'] = df[t_cols].max(axis=1)
        
    # Features especÃ­ficas das colunas F
    f_perfil = [c for c in f_cols if c.startswith('F01') or c.startswith('F02')]
    if f_perfil: 
        df['F_perfil_mean'] = df[f_perfil].mean(axis=1)
        df['F_perfil_std'] = df[f_perfil].std(axis=1)

    f_sono = [c for c in f_cols if c.startswith('F07')]
    if f_sono: 
        df['F_sono_mean'] = df[f_sono].mean(axis=1)
        df['F_sono_std'] = df[f_sono].std(axis=1)
    
    f_final = [c for c in f_cols if c.startswith('F11')]
    if f_final: 
        df['F_final_mean'] = df[f_final].mean(axis=1)
        df['F_final_std'] = df[f_final].std(axis=1)

    df['F_mean_geral'] = df[f_cols].mean(axis=1)

    # InteraÃ§Ãµes entre as top 3 features
    top3 = [f for f in FEATURES['target1'] if '_X_' not in f][:3]
    for i, f1 in enumerate(top3):
        for f2 in top3[i+1:]:
            df[f'{f1}_X_{f2}'] = df.get(f1, 0) * df.get(f2, 0)
    
    # Garante todas as features esperadas pelo modelo
    df_final = df.reindex(columns=FEATURES['target1'], fill_value=0)
    return SCALERS['target1'].transform(df_final)

def preprocess_target2(df_input):
    """PrÃ©-processamento especÃ­fico para Target 2 (ensemble)"""
    df = df_input.copy()
    
    if 'F0103' in df.columns: 
        df['F0103'] = pd.to_numeric(df['F0103'].astype(str).str.replace(',', '.'), errors='coerce')
    
    # IdentificaÃ§Ã£o de colunas
    p_cols = [c for c in df.columns if c.startswith('P') and any(char.isdigit() for char in c)]
    t_cols = [c for c in df.columns if c.startswith('T') and any(char.isdigit() for char in c)]
    f_cols = [c for c in df.columns if c.startswith('F') and len(c) > 1 and any(char.isdigit() for char in c)]

    # Processamento de colunas numÃ©ricas
    for col in p_cols + t_cols + f_cols:
        if col in df.columns:
            df[col] = pd.to_numeric(df[col], errors='coerce').replace(-1, np.nan)
            df[col].fillna(df[col].median(), inplace=True)
            
    # Features bÃ¡sicas de sono
    if 'QtdHorasDormi' in df.columns and 'Acordar' in df.columns:
        df['sono_total'] = df['QtdHorasDormi']
        df['acordar'] = df['Acordar']

    # MÃ©dias especÃ­ficas
    f_sono = [c for c in f_cols if c.startswith('F07')]
    if f_sono: 
        df['F_sono_mean'] = df[f_sono].mean(axis=1)

    f_final = [c for c in f_cols if c.startswith('F11')]
    if f_final: 
        df['F_final_mean'] = df[f_final].mean(axis=1)

    if p_cols: 
        df['P_mean'] = df[p_cols].mean(axis=1)
    
    # InteraÃ§Ã£o entre as duas principais features
    base_features = [f for f in FEATURES['target2'] if '_X_' not in f]
    if len(base_features) >= 2:
        f1, f2 = base_features[0], base_features[1]
        interaction_name = f'{f1}_X_{f2}'
        if interaction_name in FEATURES['target2']:
            df[interaction_name] = df[f1] * df[f2]

    # Garante todas as features esperadas pelo modelo
    df_final = df.reindex(columns=FEATURES['target2'], fill_value=0)
    return SCALERS['target2'].transform(df_final)

def preprocess_target3(df_input):
    """PrÃ©-processamento especÃ­fico para Target 3 (ensemble)"""
    df = df_input.copy()

    if 'F0103' in df.columns: 
        df['F0103'] = pd.to_numeric(df['F0103'].astype(str).str.replace(',', '.'), errors='coerce')

    # IdentificaÃ§Ã£o de colunas
    p_cols = [c for c in df.columns if c.startswith('P') and any(char.isdigit() for char in c)]
    t_cols = [c for c in df.columns if c.startswith('T') and any(char.isdigit() for char in c)]
    f_cols = [c for c in df.columns if c.startswith('F') and len(c) > 1 and any(char.isdigit() for char in c)]

    # Processamento de colunas numÃ©ricas
    for col in p_cols + t_cols + f_cols:
        if col in df.columns:
            df[col] = pd.to_numeric(df[col], errors='coerce').replace(-1, np.nan)
            df[col].fillna(df[col].median(), inplace=True)
    
    # EstatÃ­sticas avanÃ§adas das colunas P
    if p_cols:
        df['P_mean'] = df[p_cols].mean(axis=1)
        df['P_std'] = df[p_cols].std(axis=1)
        df['P_late'] = df[['P09', 'P12', 'P13', 'P15']].mean(axis=1) if all(c in df.columns for c in ['P09', 'P12', 'P13', 'P15']) else 0
        df['P_early'] = df[['P01', 'P02', 'P03', 'P04']].mean(axis=1) if all(c in df.columns for c in ['P01', 'P02', 'P03', 'P04']) else 0

    # EstatÃ­sticas das colunas T
    if t_cols:
        df['T_mean'] = df[t_cols].mean(axis=1)
        df['T_std'] = df[t_cols].std(axis=1)

    # Features de sono avanÃ§adas
    if 'QtdHorasSono' in df.columns:
        f_sono = [c for c in f_cols if '07' in c]
        if f_sono:
            df['F_sono_mean'] = df[f_sono].mean(axis=1)
            df['F_sono_std'] = df[f_sono].std(axis=1)
            df['F_sono_max'] = df[f_sono].max(axis=1)
        if 'Acordar' in df.columns:
            df['sono_x_acordar'] = df['QtdHorasSono'] * df['Acordar']
            df['acordar_squared'] = df['Acordar'] ** 2
    
    # Features finais
    f_final = [c for c in f_cols if '11' in c]
    if f_final: 
        df['F_final_mean'] = df[f_final].mean(axis=1)

    # InteraÃ§Ã£o especÃ­fica para Target 3
    if 'F1103' in df.columns and 'P_mean' in df.columns and 'F1103_X_P_mean' in FEATURES['target3']:
        df['F1103_X_P_mean'] = df['F1103'] * df['P_mean']
    
    # Garante todas as features esperadas pelo modelo
    df_final = df.reindex(columns=FEATURES['target3'], fill_value=0)
    return SCALERS['target3'].transform(df_final)

# --- Rotas da API (ATUALIZADAS) ---
@app.get("/health", status_code=status.HTTP_200_OK)
def health_check():
    """Endpoint de health check para o Docker Compose."""
    if MODELS is None:
        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail="Modelos de ML nÃ£o carregados.")
    return {"status": "ok"}

@app.post("/register", status_code=status.HTTP_201_CREATED)
def register(user: schemas.UserCreate, db: Session = Depends(database.get_db)):
    db_user = crud.get_user_by_username(db, username=user.username)
    if db_user:
        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail="UsuÃ¡rio jÃ¡ existe")
    try:
        crud.create_user(db=db, user_schema=user)
        return {"msg": "UsuÃ¡rio registrado com sucesso"}
    except IntegrityError: # Captura erro de corrida (race condition)
        db.rollback()
        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail="UsuÃ¡rio jÃ¡ existe")

@app.post("/login", response_model=schemas.Token)
def login(form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(database.get_db)):
    user = crud.get_user_by_username(db, username=form_data.username)
    if not user or not auth.verify_password(form_data.password, user.password_hash):
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Credenciais invÃ¡lidas")
    access_token = auth.create_access_token(data={"sub": str(user.id)})
    return {"access_token": access_token, "token_type": "bearer"}

@app.post("/predict")
async def predict(file: UploadFile = File(...), user_id: str = Depends(auth.get_current_user_id), db: Session = Depends(database.get_db)):
    if MODELS is None:
        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail="Modelos de ML nÃ£o estÃ£o disponÃ­veis.")
    
    try:
        contents = await file.read()
        buffer = BytesIO(contents)
        df_new = pd.read_excel(buffer)
        if 'CÃ³digo de Acesso' not in df_new.columns:
            print("Coluna 'CÃ³digo de Acesso' nÃ£o encontrada no arquivo.")
            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Coluna 'CÃ³digo de Acesso' nÃ£o encontrada no arquivo.")
    except Exception as e:
        print(f"Erro ao ler o arquivo Excel: {e}")
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=f"Erro ao ler o arquivo Excel: {e}")

    df_results = df_new.copy()
    shap_data = {}

    try:
        # PrevisÃ£o T1 (modelo Ãºnico)
        X_scaled_t1 = preprocess_target1(df_new)
        df_results['PrevisÃ£o T1'] = MODELS['target1'].predict(X_scaled_t1).round(2)
        
        # PrevisÃ£o T2 (ensemble - mÃ©dia dos 3 modelos)
        X_scaled_t2 = preprocess_target2(df_new)
        preds_t2 = [model.predict(X_scaled_t2) for model in MODELS['target2']]
        df_results['PrevisÃ£o T2'] = np.mean(preds_t2, axis=0).round(2)
        
        # PrevisÃ£o T3 (ensemble - mÃ©dia dos 3 modelos)
        X_scaled_t3 = preprocess_target3(df_new)
        preds_t3 = [model.predict(X_scaled_t3) for model in MODELS['target3']]
        df_results['PrevisÃ£o T3'] = np.mean(preds_t3, axis=0).round(2)

        # CÃ¡lculo SHAP - ATUALIZADO PARA ENSEMBLE
        # T1 (modelo Ãºnico)
        shap_values_t1 = EXPLAINERS['target1'].shap_values(X_scaled_t1)
        
        # T2 (mÃ©dia dos SHAP values dos 3 modelos do ensemble)
        shap_values_list_t2 = [explainer.shap_values(X_scaled_t2) for explainer in EXPLAINERS['target2']]
        shap_values_t2 = np.mean(shap_values_list_t2, axis=0)

        # T3 (mÃ©dia dos SHAP values dos 3 modelos do ensemble)
        shap_values_list_t3 = [explainer.shap_values(X_scaled_t3) for explainer in EXPLAINERS['target3']]
        shap_values_t3 = np.mean(shap_values_list_t3, axis=0)

        # Estrutura dos dados SHAP para resposta
        for i, j_id in enumerate(df_results['CÃ³digo de Acesso']):
            shap_data[str(j_id)] = {
                'T1': {
                    'shap_values': shap_values_t1[i].tolist(), 
                    'feature_names': FEATURES['target1']
                },
                'T2': {
                    'shap_values': shap_values_t2[i].tolist(), 
                    'feature_names': FEATURES['target2']
                },
                'T3': {
                    'shap_values': shap_values_t3[i].tolist(), 
                    'feature_names': FEATURES['target3']
                }
            }
            
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"Erro durante o pipeline de previsÃ£o: {e}")

    # Salvar no DB
    try:
        for _, row in df_results.iterrows():
            db.add(models.Prediction(
                user_id=int(user_id), 
                jogador_id=str(row['CÃ³digo de Acesso']), 
                pred_t1=row['PrevisÃ£o T1'], 
                pred_t2=row['PrevisÃ£o T2'], 
                pred_t3=row['PrevisÃ£o T3']
            ))
        db.commit()
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"Erro ao salvar previsÃ£o no banco de dados: {e}")

    return {
        "predictions": df_results[['CÃ³digo de Acesso', 'PrevisÃ£o T1', 'PrevisÃ£o T2', 'PrevisÃ£o T3']].to_dict('records'),
        "shap_data": shap_data
    }

@app.get("/history")
def get_history(user_id: str = Depends(auth.get_current_user_id), db: Session = Depends(database.get_db)):
    query = db.query(
        models.Prediction.upload_timestamp, 
        func.count(models.Prediction.id).label('num_jogadores')
    ).filter(models.Prediction.user_id == int(user_id)).group_by(models.Prediction.upload_timestamp).order_by(models.Prediction.upload_timestamp.desc()).all()
    return [{"timestamp": r.upload_timestamp.strftime("%Y-%m-%d %H:%M:%S"), "num_jogadores": r.num_jogadores} for r in query]

@app.get("/feature_importance")
def get_feature_importance(user_id: str = Depends(auth.get_current_user_id)):
    if MODELS is None:
        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail="Modelos de ML nÃ£o carregados.")
    
    importances_data = {}
    try:
        # Target 1 (modelo Ãºnico)
        if hasattr(MODELS['target1'], 'feature_importances_'):
            df_imp_t1 = pd.DataFrame({
                'feature': FEATURES['target1'], 
                'importance': MODELS['target1'].feature_importances_
            }).sort_values(by='importance', ascending=False).head(20)
            importances_data['Target1'] = df_imp_t1.to_dict('records')
        else:
            importances_data['Target1'] = []

        # Targets 2 e 3 (mÃ©dia das importÃ¢ncias dos ensembles)
        for target_key, target_name in [('target2', 'Target2'), ('target3', 'Target3')]:
            all_importances = []
            for model in MODELS[target_key]:
                if hasattr(model, 'feature_importances_'):
                    all_importances.append(model.feature_importances_)
            
            if all_importances:
                avg_importance = np.mean(all_importances, axis=0)
                df_imp = pd.DataFrame({
                    'feature': FEATURES[target_key],
                    'importance': avg_importance
                }).sort_values(by='importance', ascending=False).head(20)
                importances_data[target_name] = df_imp.to_dict('records')
            else:
                importances_data[target_name] = []
                
        return importances_data
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"Erro ao calcular feature importance: {e}")
</file>

<file path="README.md">
# ðŸ“Š DocumentaÃ§Ã£o do projeto

**PropÃ³sito do Projeto**

<small>

Este projeto foi desenvolvido para realizar um ciclo completo de anÃ¡lise de dados, desde a limpeza e preparaÃ§Ã£o atÃ© a modelagem preditiva e avaliaÃ§Ã£o de performance. O objetivo principal Ã© transformar um conjunto de dados brutos de jogadores em insights acionÃ¡veis e modelos de _machine learning_ robustos, capazes de prever trÃªs mÃ©tricas-alvo distintas (`Target1`, `Target2` e `Target3`).

O processo Ã© dividido em duas fases principais:

1.  **Fase de Limpeza e PreparaÃ§Ã£o (V1)**: Focada em garantir a qualidade e a consistÃªncia dos dados. Nesta etapa, sÃ£o aplicadas tÃ©cnicas como tratamento de valores ausentes, remoÃ§Ã£o de _outliers_, _feature engineering_ e seleÃ§Ã£o de variÃ¡veis para criar um _dataset_ otimizado e confiÃ¡vel.

2.  **Fase de Modelagem (V2)**: Utiliza o _dataset_ limpo para treinar, avaliar e comparar diversos algoritmos de regressÃ£o, como _Random Forest_, _XGBoost_ e _LightGBM_. O objetivo Ã© identificar os modelos com melhor desempenho para cada uma das variÃ¡veis-alvo, salvando-os para futura implementaÃ§Ã£o em produÃ§Ã£o.

Ao final, o projeto entrega nÃ£o apenas os modelos treinados, mas tambÃ©m anÃ¡lises visuais e relatÃ³rios que facilitam a interpretaÃ§Ã£o dos resultados e a identificaÃ§Ã£o das variÃ¡veis mais influentes.

</small>

<details>

<summary> ðŸ“Š Fase V1 - Limpeza</summary>

### ðŸ§© **CÃ©lula 1/2 - ConfiguraÃ§Ã£o do Ambiente e ImportaÃ§Ãµes**

<small>
ðŸ“– ExplicaÃ§Ã£o:

Esta cÃ©lula inicializa o ambiente de trabalho. Primeiro, realiza a instalaÃ§Ã£o silenciosa das dependÃªncias externas necessÃ¡rias para a manipulaÃ§Ã£o de planilhas e para a aplicaÃ§Ã£o de tÃ©cnicas de aprendizado de mÃ¡quina. Em seguida, importa as bibliotecas e mÃ³dulos que serÃ£o utilizados ao longo das etapas de limpeza, transformaÃ§Ã£o e anÃ¡lise de dados.

<details>

<summary> Bibliotecas utilizadas: </summary>

<small>

- **xlsxwriter e openpyxl**:

DependÃªncias utilizadas pelo Pandas para ler e escrever arquivos no formato Excel (.xlsx). A instalaÃ§Ã£o garante a compatibilidade com essas operaÃ§Ãµes.

- **scikit-learn**:

Uma das principais bibliotecas de aprendizado de mÃ¡quina em Python, que fornece ferramentas eficientes para prÃ©-processamento, modelagem e avaliaÃ§Ã£o de dados.

- **pandas**:

Fundamental para a manipulaÃ§Ã£o e anÃ¡lise de dados. Ã‰ utilizada para carregar os dados em estruturas conhecidas como DataFrames, que facilitam a limpeza e a transformaÃ§Ã£o.

- **numpy**:

Essencial para computaÃ§Ã£o numÃ©rica, oferece suporte a arrays e matrizes multidimensionais, alÃ©m de uma vasta coleÃ§Ã£o de funÃ§Ãµes matemÃ¡ticas de alto desempenho.

- **SimpleImputer**:

Uma classe do Scikit-learn usada para tratar dados ausentes (NaN), permitindo preenchÃª-los com uma estratÃ©gia definida (como a mÃ©dia, mediana ou a moda da coluna).

- **StandardScaler**:

Uma classe do Scikit-learn utilizada para padronizar as features numÃ©ricas, redimensionando-as para que tenham mÃ©dia zero e desvio padrÃ£o igual a um, o que Ã© crucial para muitos algoritmos de machine learning.

- **datetime**:

MÃ³dulo padrÃ£o do Python para manipulaÃ§Ã£o de datas e horas.

- **warnings**:

MÃ³dulo para controlar a exibiÃ§Ã£o de mensagens de aviso. A linha warnings.filterwarnings('ignore') Ã© usada para suprimir esses avisos e manter a saÃ­da do cÃ³digo mais limpa e focada nos resultados.
</small>

</details>

---

### ðŸ§© **CÃ©lula 3 - DEFINIÃ‡Ã•ES**

<details>

<summary> Trecho do codigo em Python </summary>

```python
COLUNAS_CATEGORICAS = [
    'Cor0202', 'Cor0204', 'Cor0206', 'Cor0208', 'Cor0209Outro',
    'P01', 'P02', 'P03', 'P04', 'P05', 'P07', 'P08', 'P09', 'P10',
    'P12', 'P13', 'P15', 'P12_1', 'P02_1', 'P03_1', 'P09_1'
]

COLUNAS_TARGETS = ['Target1', 'Target2', 'Target3']

COLUNAS_IGNORAR = [
    'CÃ³digo de Acesso', 'Data/Hora Ãšltimo',
    'L0210 (nÃ£o likert)',
    'F0299 - ExplicaÃ§Ã£o Tempo', 'T0499 - ExplicaÃ§Ã£o Tempo',
    'PTempoTotalExpl', 'T1199Expl', 'T1205Expl', 'T1210Expl',
    'TempoTotalExpl'
]

print(f"ðŸ“‹ CategÃ³ricas: {len(COLUNAS_CATEGORICAS)} | Targets: {len(COLUNAS_TARGETS)}")
```

</details>
<small> ðŸ“– ExplicaÃ§Ã£o:

Esta cÃ©lula centraliza as **definiÃ§Ãµes estruturais** do dataset, classificando as colunas em grupos conforme seu papel no processamento:

- **`COLUNAS_CATEGORICAS`**: lista de variÃ¡veis qualitativas ou de mÃºltipla escolha, normalmente representadas por cÃ³digos (`P01`, `P02`, etc.).
- **`COLUNAS_TARGETS`**: define as variÃ¡veis-alvo (targets) utilizadas em anÃ¡lises ou modelagem.
- **`COLUNAS_IGNORAR`**: contÃ©m variÃ¡veis irrelevantes ou auxiliares, como identificadores, timestamps e campos descritivos.
  </small>

---

### ðŸ§© **CÃ©lula 4 - Carregando Dataset Recebido**

<details>

<summary> Trecho do codigo em Python </summary>

```python
import pandas as pd

df_original = pd.read_excel('JogadoresV1.xlsx')
df = df_original.copy()
print(f"Dados carregados: {df.shape[0]} linhas, {df.shape[1]} colunas")
```

</details>
<small>
ðŸ“– ExplicaÃ§Ã£o:

Nesta cÃ©lula, realizamos a leitura do arquivo Excel contendo o dataset bruto e criamos uma cÃ³pia para preservar o original.

- `pd.read_excel()` carrega o arquivo no formato Excel.
- `.copy()` evita modificaÃ§Ãµes acidentais no dataset original.  
  </small>

---

### ðŸ§© **CÃ©lula 5 - TRATAMENTO F0103**

<details>

<summary> Trecho do codigo em Python </summary>

```python
if 'F0103' in df.columns and df['F0103'].dtype == 'object':
    print("\nðŸ”§ Convertendo F0103 (vÃ­rgula â†’ ponto)")
    df['F0103'] = df['F0103'].str.replace(',', '.').astype(float)
    print("   âœ… Convertido!")
```

</details>

<small> ðŸ“– ExplicaÃ§Ã£o:

Nesta cÃ©lula, corrigimos a coluna chamada `F0103` para garantir que os nÃºmeros estejam em um formato que o Python consegue entender corretamente.

- Primeiro verificamos se a coluna `F0103` existe na tabela e se ela estÃ¡ como texto.

- Em seguida, substituÃ­mos todas as vÃ­rgulas `,` por pontos `.` â€” isso Ã© importante porque em alguns arquivos, nÃºmeros decimais vÃªm escritos como `3,14` em vez de `3.14`.
- Por fim, transformamos essa coluna em nÃºmeros de ponto flutuante (`float`), para que possa ser usada em cÃ¡lculos, anÃ¡lises e modelos sem causar erros.

Esse passo garante que a informaÃ§Ã£o da coluna `F0103` seja precisa e utilizÃ¡vel em todas as etapas seguintes do processamento de dados.
</small>

---

### ðŸ§© **CÃ©lula 6 â€” REMOÃ‡ÃƒO DE NEGATIVOS**

<details>

<summary> Trecho do codigo em Python </summary>

```python
print("\n" + "=" * 80)
print("ETAPA 1: REMOÃ‡ÃƒO DE NEGATIVOS â†’ NaN")
print("=" * 80)

colunas_numericas = df.select_dtypes(include=[np.number]).columns.tolist()
colunas_numericas = [col for col in colunas_numericas if col not in COLUNAS_TARGETS]

contador = 0
for col in colunas_numericas:
    negativos = (df[col] < 0).sum()
    if negativos > 0:
        df.loc[df[col] < 0, col] = np.nan
        contador += negativos

print(f"âœ… {contador} negativos convertidos â†’ NaN")

```

</details>

<small> ðŸ“– ExplicaÃ§Ã£o:

Nesta cÃ©lula, identificamos todas as colunas numÃ©ricas e substituÃ­mos valores negativos por valores vazios (NaN).

- Primeiro, usamos `df.select_dtypes(include=[np.number])` para selecionar todas as colunas que contÃªm nÃºmeros.

- Em seguida, removemos da lista as colunas-alvo definidas em `COLUNAS_TARGETS`, pois essas nÃ£o devem ser modificadas nesse passo.

- Para cada coluna numÃ©rica restante, verificamos quantos valores sÃ£o negativos usando `(df[col] < 0).sum()`.

- Quando valores negativos sÃ£o encontrados, usamos `df.loc[df[col] < 0, col] = np.nan` para substituÃ­-los.

- Ao final, imprimimos a quantidade total de valores negativos convertidos.

</small>

---

### ðŸ§© **CÃ©lula 7 - RemoÃ§Ã£o de Colunas com Muito Missing**

<details>

<summary> Trecho do codigo em Python </summary>

```python
print("\n" + "=" * 80)
print("ETAPA 2: ANÃLISE DE MISSING")
print("=" * 80)

missing_info = pd.DataFrame({
    'Coluna': df.columns,
    'Missing': df.isna().sum(),
    'Percentual': (df.isna().sum() / len(df) * 100).round(2)
})
missing_info = missing_info[missing_info['Missing'] > 0].sort_values('Percentual', ascending=False)

threshold = 70
colunas_remover = missing_info[missing_info['Percentual'] > threshold]['Coluna'].tolist()

if colunas_remover:
    print(f"ðŸ—‘ï¸  Removendo {len(colunas_remover)} colunas (>{threshold}% missing)")
    df = df.drop(columns=colunas_remover)

print(f"âœ… Shape: {df.shape}")

```

</details>

<small> ðŸ“– ExplicaÃ§Ã£o:

Nesta cÃ©lula, realizamos uma anÃ¡lise de dados faltantes (`missing values`) em cada coluna e removemos aquelas que possuem um percentual alto de ausÃªncia de dados.

- Usamos `df.isna().sum()` para contar quantos valores estÃ£o faltando em cada coluna.

- Calculamos o percentual de valores faltantes dividindo pela quantidade total de linhas (`len(df)`).

- Criamos o DataFrame `missing_info`, que contÃ©m o nome da coluna, quantidade de valores ausentes e percentual de ausÃªncia.

- Ordenamos `missing_info` pelo percentual de ausÃªncia em ordem decrescente para focar nas colunas com mais dados faltantes.

- Definimos um limite (`threshold`) de 70%. Isso significa que qualquer coluna com mais de 70% de valores faltantes serÃ¡ removida.

- Usamos `df.drop(columns=colunas_remover)` para eliminar essas colunas do dataset.

- Por fim, imprimimos quantas colunas foram removidas e o novo formato da tabela (`df.shape`).

</small>

---

### ðŸ§© **CÃ©lula 8 - RemoÃ§Ã£o de Jogadores sem Targets**

<details>

<summary> Trecho do codigo em Python </summary>

```python
print("\n" + "=" * 80)
print("ETAPA 3: REMOÃ‡ÃƒO DE JOGADORES SEM TARGETS")
print("=" * 80)

antes = len(df)
df = df.dropna(subset=COLUNAS_TARGETS, how='all')
depois = len(df)

print(f"âœ… Jogadores mantidos: {depois} (removidos: {antes-depois})")

```

</details>

<small> ðŸ“– ExplicaÃ§Ã£o:

Nesta cÃ©lula, garantimos que todos os registros (linhas) do dataset contenham pelo menos uma informaÃ§Ã£o nos campos-alvo definidos em `COLUNAS_TARGETS`.

- Usamos `len(df)` para contar quantas linhas existem antes da limpeza (antes).

- O comando `df.dropna(subset=COLUNAS_TARGETS, how='all')` remove todas as linhas em que todos os campos de target estejam vazios (`NaN`).

- Calculamos novamente o tamanho do dataset (`depois`) para saber quantos registros restaram.

- Imprimimos a quantidade de jogadores mantidos e removidos apÃ³s o filtro.

</small>

---

### **ðŸ§© CÃ©lula 9 - ImputaÃ§Ã£o de Valores Faltantes**

<details>

<summary> Trecho do codigo em Python </summary>

```python
# NumÃ©ricas: MEDIANA
colunas_num_imputar = [
    col for col in df.select_dtypes(include=[np.number]).columns
    if col not in COLUNAS_TARGETS and col not in COLUNAS_IGNORAR
]

if colunas_num_imputar:
    imputer_num = SimpleImputer(strategy='median')
    df[colunas_num_imputar] = imputer_num.fit_transform(df[colunas_num_imputar])
    print(f"âœ… {len(colunas_num_imputar)} numÃ©ricas imputadas (mediana)")

# CategÃ³ricas: MODA
colunas_cat_imputar = [col for col in COLUNAS_CATEGORICAS if col in df.columns]

if colunas_cat_imputar:
    imputer_cat = SimpleImputer(strategy='most_frequent')
    df[colunas_cat_imputar] = imputer_cat.fit_transform(df[colunas_cat_imputar])
    print(f"âœ… {len(colunas_cat_imputar)} categÃ³ricas imputadas (moda)")


```

</details>

<small> ðŸ“– ExplicaÃ§Ã£o:

Nesta cÃ©lula, tratamos os valores faltantes no dataset usando imputaÃ§Ã£o â€” ou seja, substituÃ­mos valores ausentes (`NaN`) por valores calculados com base nos dados disponÃ­veis.

- Colunas numÃ©ricas:

  - Identificamos todas as colunas numÃ©ricas usando `df.select_dtypes(include=[np.number])`.

  - Removemos as colunas-alvo (`COLUNAS_TARGETS`) e as colunas marcadas para ignorar (`COLUNAS_IGNORAR`).

  - Criamos um imputador (`SimpleImputer`) usando a estratÃ©gia `median` para substituir valores ausentes pela mediana daquela coluna.

  - Aplicamos a imputaÃ§Ã£o usando `fit_transform`.

- Colunas categÃ³ricas:

  - Identificamos as colunas categÃ³ricas presentes (`COLUNAS_CATEGORICAS`).

  - Criamos um imputador usando a estratÃ©gia `most_frequent` para substituir valores ausentes pelo valor mais frequente da coluna (moda).

  - Aplicamos a imputaÃ§Ã£o usando fit_transform.

</small>

---

### **ðŸ§© CÃ©lula 10 - Tratamento de Outliers (IQR + Mediana)**

<details>

<summary> Trecho do codigo em Python </summary>

```python
colunas_outliers = [
    col for col in colunas_num_imputar
    if col not in ['QtdHorasSono', 'QtdHorasDormi', 'Acordar']
]

outliers_tratados = 0
for col in colunas_outliers:
    Q1 = df[col].quantile(0.25)
    Q3 = df[col].quantile(0.75)
    IQR = Q3 - Q1

    limite_inf = Q1 - 1.5 * IQR
    limite_sup = Q3 + 1.5 * IQR

    outliers_mask = (df[col] < limite_inf) | (df[col] > limite_sup)
    n_outliers = outliers_mask.sum()

    if n_outliers > 0:
        mediana = df[col].median()
        df.loc[outliers_mask, col] = mediana
        outliers_tratados += n_outliers

print(f"âœ… {outliers_tratados} outliers tratados (substituÃ­dos por mediana)")

```

</details>

<small> ðŸ“– ExplicaÃ§Ã£o:

Nesta cÃ©lula, detectamos e tratamos outliers â€” valores extremos que podem distorcer anÃ¡lises e modelos â€” utilizando o mÃ©todo do Intervalo InterquartÃ­lico (IQR) e substituindo-os pela mediana da coluna.

- Primeiro identificamos as colunas numÃ©ricas a serem tratadas (`colunas_outliers`), excluindo colunas especÃ­ficas como `QtdHorasSono`, `QtdHorasDormi` e `Acordar`.

- Para cada coluna:

  - Calculamos o **primeiro quartil** (`Q1`) e o **terceiro quartil** (`Q3`).

  - Determinamos o **Intervalo InterquartÃ­lico (IQR)** como `Q3 - Q1`.

  - Definimos limites inferior (`limite_inf`) e superior (`limite_sup`) como `Q1 - 1.5*IQR` e `Q3 + 1.5*IQR`, respectivamente.

  - Criamos uma mÃ¡scara (`outliers_mask`) identificando valores fora desses limites.

  - Quando outliers sÃ£o encontrados, substituÃ­mos esses valores pela mediana da coluna.

  - Contabilizamos quantos outliers foram tratados.

</small>

---

### **ðŸ§© CÃ©lula 11 - One-Hot Encoding**

<details>

<summary> Trecho do codigo em Python </summary>

```python
colunas_cat_presentes = [col for col in COLUNAS_CATEGORICAS if col in df.columns]

if colunas_cat_presentes:
    colunas_antes = df.shape[1]
    df = pd.get_dummies(df, columns=colunas_cat_presentes, prefix=colunas_cat_presentes, drop_first=False)
    colunas_depois = df.shape[1]

    print(f"âœ… One-Hot concluÃ­do: {colunas_antes} â†’ {colunas_depois} colunas")

```

</details>

<small> ðŸ“– ExplicaÃ§Ã£o:

Nesta cÃ©lula, aplicamos a tÃ©cnica de One-Hot Encoding, que transforma colunas categÃ³ricas em variÃ¡veis numÃ©ricas binÃ¡rias, permitindo que algoritmos de machine learning trabalhem com esses dados.

- Identificamos as colunas categÃ³ricas presentes no dataset (`colunas_cat_presentes`) comparando `COLUNAS_CATEGORICAS` com as colunas reais do `df`.

- Guardamos o nÃºmero inicial de colunas (`colunas_antes`).

- Usamos `pd.get_dummies()` para criar colunas binÃ¡rias para cada categoria, mantendo o prefixo original para identificaÃ§Ã£o.

- NÃ£o usamos `drop_first=True` para preservar todas as categorias.

- Calculamos o nÃºmero final de colunas (`colunas_depois`) apÃ³s a transformaÃ§Ã£o.

- Imprimimos quantas colunas foram adicionadas no processo.

</small>

---

### **ðŸ§© CÃ©lula 12 - Feature Engineering (AgregaÃ§Ãµes)**

<details>

<summary> Trecho do codigo em Python </summary>

```python
# AgregaÃ§Ã£o F11*
f11_cols = [c for c in df.columns if c.startswith('F11') and pd.api.types.is_numeric_dtype(df[c])]
if len(f11_cols) > 2:
    df['F11_mean'] = df[f11_cols].mean(axis=1)
    print(f"âœ… F11_mean criada ({len(f11_cols)} colunas)")

# AgregaÃ§Ã£o F07*
f07_cols = [c for c in df.columns if c.startswith('F07') and pd.api.types.is_numeric_dtype(df[c])]
if len(f07_cols) > 2:
    df['F07_mean'] = df[f07_cols].mean(axis=1)
    print(f"âœ… F07_mean criada ({len(f07_cols)} colunas)")
```

</details>

<small> ðŸ“– ExplicaÃ§Ã£o:

Nesta cÃ©lula, realizamos Feature Engineering, criando novas colunas que representam agregaÃ§Ãµes de variÃ¡veis relacionadas, para facilitar a anÃ¡lise e potencialmente melhorar a performance de modelos.

- **AgregaÃ§Ã£o F11**:

  - Identificamos colunas cujo nome comeÃ§a com "`F11`" e que sÃ£o numÃ©ricas.

  - Se existirem mais de duas colunas nesse grupo, calculamos a mÃ©dia delas linha a linha (`mean(axis=1)`), criando a nova coluna `F11_mean`.

  - Exibimos quantas colunas foram utilizadas para essa agregaÃ§Ã£o.

- **AgregaÃ§Ã£o F07**:

  - De forma semelhante, identificamos colunas que comeÃ§am com "`F07`" e que sÃ£o numÃ©ricas.

  - Se houver mais de duas, calculamos a mÃ©dia e criamos `F07_mean`.

  - Exibimos quantas colunas contribuÃ­ram para essa agregaÃ§Ã£o.

</small>

---

### **ðŸ§© CÃ©lula 13 - ðŸ”§ CorreÃ§Ã£o 1 - Converter BOOL â†’ INT**

<details>

<summary> Trecho do codigo em Python </summary>

```python
bool_cols = df.select_dtypes(include=['bool']).columns.tolist()

if bool_cols:
    print(f"ðŸ“‹ Convertendo {len(bool_cols)} colunas booleanas...")
    df[bool_cols] = df[bool_cols].astype(int)
    print(f"âœ… VERDADEIRO/FALSO â†’ 1/0")
    print(f"   Exemplo: {bool_cols[:3]}")
else:
    print("â„¹ï¸  Nenhuma coluna booleana encontrada")
```

</details>

<small> ðŸ“– ExplicaÃ§Ã£o:

Nesta cÃ©lula, corrigimos o formato das colunas booleanas do dataset, transformando valores `True`/`False` em `1/0`. Isso Ã© necessÃ¡rio porque muitos algoritmos de machine learning requerem que todos os dados sejam numÃ©ricos.

- Usamos `df.select_dtypes(include=['bool'])` para identificar todas as colunas que contÃªm valores booleanos (`True` ou `False`).

- Se houver colunas booleanas (`bool_cols`), exibimos quantas serÃ£o convertidas.

- Aplicamos `.astype(int)` para transformar os valores em nÃºmeros inteiros (`1` para `True`, `0` para `False`).

- Exibimos alguns exemplos de colunas convertidas para confirmar a aÃ§Ã£o.

- Caso nÃ£o existam colunas booleanas, uma mensagem informativa Ã© exibida.

</small>

---

### **ðŸ§© CÃ©lula 14 - Feature Selection por CorrelaÃ§Ã£o**

<details>

<summary> Trecho do codigo em Python </summary>

```python
print("\n" + "=" * 80)
print("ETAPA 8: FEATURE SELECTION")
print("=" * 80)

features_numericas_finais = [
    col for col in df.columns
    if col not in COLUNAS_TARGETS
    and col not in COLUNAS_IGNORAR
    and pd.api.types.is_numeric_dtype(df[col])
]

print(f"ðŸ“Š Features disponÃ­veis: {len(features_numericas_finais)}")

corr_t1 = df[features_numericas_finais].corrwith(df['Target1']).abs()
corr_t2 = df[features_numericas_finais].corrwith(df['Target2']).abs()
corr_t3 = df[features_numericas_finais].corrwith(df['Target3']).abs()

corr_mean = (corr_t1 + corr_t2 + corr_t3) / 3

threshold = 0.20
features_selecionadas = corr_mean[corr_mean > threshold].index.tolist()

print(f"âœ… Features mantidas: {len(features_selecionadas)} (threshold={threshold})")
print(f"âœ… Features removidas: {len(features_numericas_finais) - len(features_selecionadas)}")

# Top 10
print(f"\nðŸ† TOP 10 FEATURES:")
top10 = corr_mean.sort_values(ascending=False).head(10)
for idx, (feat, corr) in enumerate(top10.items(), 1):
    print(f"   {idx:2d}. {feat:30s} | Corr: {corr:.4f}")
```

</details>

<small> ðŸ“– ExplicaÃ§Ã£o:

Nesta cÃ©lula, realizamos a **seleÃ§Ã£o de features** com base na correlaÃ§Ã£o entre variÃ¡veis numÃ©ricas e os targets (`Target1`, `Target2`, `Target3`). O objetivo Ã© manter apenas as colunas que tÃªm relevÃ¢ncia estatÃ­stica para o modelo.

- Definimos `features_numericas_finais` como todas as colunas numÃ©ricas que nÃ£o sÃ£o targets nem estÃ£o na lista `COLUNAS_IGNORAR`.

- Calculamos a correlaÃ§Ã£o absoluta (`.abs()`) entre cada feature e cada target (`corr_t1`, `corr_t2`, `corr_t3`).

- Obtemos a mÃ©dia das correlaÃ§Ãµes (`corr_mean`) para avaliar a importÃ¢ncia geral da feature em relaÃ§Ã£o a todos os targets.

- Definimos um **threshold** (limite) de 0.20; apenas features com correlaÃ§Ã£o mÃ©dia acima desse valor sÃ£o mantidas (`features_selecionadas`).

- Informamos quantas features foram mantidas e quantas removidas.

- Exibimos as **Top 10 features** com maior correlaÃ§Ã£o mÃ©dia, ordenadas do maior para o menor valor, para referÃªncia.

</small>

---

### **ðŸ§© CÃ©lula 15 - Criar DataFrames Finais**

<details>

<summary> Trecho do codigo em Python </summary>

```python
df_final_nao_normalizado = df[features_selecionadas + COLUNAS_TARGETS].copy()
print(f"âœ… DataFrame NÃƒO-NORMALIZADO: {df_final_nao_normalizado.shape}")

df_final_normalizado = df_final_nao_normalizado.copy()

# Identificar categÃ³ricas (One-Hot) para NÃƒO normalizar
features_cat_onehot = [
    col for col in features_selecionadas
    if any(cat in col for cat in COLUNAS_CATEGORICAS)
]

features_numericas_normalizar = [
    col for col in features_selecionadas
    if col not in features_cat_onehot
]

print(f"ðŸ”¢ NumÃ©ricas a normalizar: {len(features_numericas_normalizar)}")
print(f"ðŸ“ CategÃ³ricas (preservadas): {len(features_cat_onehot)}")

if features_numericas_normalizar:
    scaler = StandardScaler()
    df_final_normalizado[features_numericas_normalizar] = scaler.fit_transform(
        df_final_normalizado[features_numericas_normalizar]
    )
    print(f"âœ… NormalizaÃ§Ã£o concluÃ­da!")

print(f"âœ… DataFrame NORMALIZADO: {df_final_normalizado.shape}")
```

</details>

<small> ðŸ“– ExplicaÃ§Ã£o:

Nesta cÃ©lula, preparamos os **DataFrames finais** para anÃ¡lise e modelagem, criando versÃµes normalizadas e nÃ£o-normalizadas.

- Criamos `df_final_nao_normalizado` contendo apenas as **features selecionadas** e os **targets**, preservando o formato original.

- Criamos uma cÃ³pia chamada `df_final_normalizado` para aplicar normalizaÃ§Ã£o sem alterar o original.

- Identificamos colunas categÃ³ricas geradas pelo **One-Hot Encoding** (`features_cat_onehot`) para garantir que elas nÃ£o sejam normalizadas.

- Definimos `features_numericas_normalizar` como todas as features numÃ©ricas restantes.

- Informamos quantas features numÃ©ricas serÃ£o normalizadas e quantas categÃ³ricas serÃ£o preservadas.

- Aplicamos o `StandardScaler` Ã s features numÃ©ricas, padronizando-as para mÃ©dia zero e desvio padrÃ£o igual a um.

- Exibimos o tamanho final de cada DataFrame, garantindo que ambos estejam prontos para uso posterior.

</small>

---

### **ðŸ§© CÃ©lula 16 - Exportar para Excel**

<details>

<summary> Trecho do codigo em Python </summary>

```python
output_file = 'Dados_Otimizados_V4.xlsx'

writer = pd.ExcelWriter(output_file, engine='xlsxwriter')
workbook = writer.book

header_format = workbook.add_format({
    'bold': True, 'text_wrap': True, 'valign': 'vcenter',
    'align': 'center', 'fg_color': '#1F4E78',
    'font_color': 'white', 'border': 1
})

title_format = workbook.add_format({
    'bold': True, 'font_size': 16,
    'fg_color': '#4472C4', 'font_color': 'white',
    'align': 'center', 'valign': 'vcenter', 'border': 2
})

# Aba 1: Dados nÃ£o-normalizados
df_final_nao_normalizado.to_excel(writer, sheet_name='Dados_Para_Analise', index=False, startrow=2)
worksheet1 = writer.sheets['Dados_Para_Analise']
worksheet1.merge_range('A1:Z1', 'ðŸ“‹ DADOS LIMPOS - VersÃ£o Otimizada', title_format)
worksheet1.freeze_panes(3, 0)

# Aba 2: Dados normalizados
df_final_normalizado.to_excel(writer, sheet_name='Dados_Para_Modelo', index=False, startrow=2)
worksheet2 = writer.sheets['Dados_Para_Modelo']
worksheet2.merge_range('A1:Z1', 'ðŸ“Š DADOS NORMALIZADOS - Para ML', title_format)
worksheet2.freeze_panes(3, 0)

# Aba 3: Resumo estatÃ­stico
summary = df_final_nao_normalizado[COLUNAS_TARGETS].describe().T
summary.to_excel(writer, sheet_name='Resumo_Estatistico', startrow=2)
worksheet3 = writer.sheets['Resumo_Estatistico']
worksheet3.merge_range('A1:I1', 'ðŸ“Š RESUMO ESTATÃSTICO', title_format)

# Aba 4: CorrelaÃ§Ãµes
correlations_df = pd.DataFrame({
    'Feature': corr_mean.index,
    'Corr_Target1': corr_t1.values,
    'Corr_Target2': corr_t2.values,
    'Corr_Target3': corr_t3.values,
    'Corr_Media': corr_mean.values,
    'Mantida': ['âœ…' if f in features_selecionadas else 'âŒ' for f in corr_mean.index]
}).sort_values('Corr_Media', ascending=False)

correlations_df.to_excel(writer, sheet_name='Correlacoes', index=False, startrow=2)
worksheet4 = writer.sheets['Correlacoes']
worksheet4.merge_range('A1:F1', 'ðŸ” ANÃLISE DE CORRELAÃ‡Ã•ES', title_format)

writer.close()

print(f"âœ… Arquivo '{output_file}' criado!")
```

</details>

<small> ðŸ“– ExplicaÃ§Ã£o:

Nesta cÃ©lula, exportamos os resultados finais para um arquivo Excel estruturado, criando mÃºltiplas abas para facilitar a anÃ¡lise e utilizaÃ§Ã£o dos dados.

- Definimos o nome do arquivo de saÃ­da como `Dados_Otimizados_V4.xlsx`.

- Criamos um escritor Excel (`pd.ExcelWriter`) usando o engine `xlsxwriter`.

- Definimos formataÃ§Ãµes personalizadas para cabeÃ§alhos (`header_format`) e tÃ­tulos (`title_format`) para melhor visualizaÃ§Ã£o.

**Aba 1 â€“ Dados nÃ£o-normalizados:**

- Exporta `df_final_nao_normalizado`.

- Inclui um tÃ­tulo e congela a visualizaÃ§Ã£o para facilitar navegaÃ§Ã£o.

**Aba 2 â€“ Dados normalizados:**

- Exporta `df_final_normalizado`.

- Inclui tÃ­tulo e congelamento de linhas.

**Aba 3 â€“ Resumo estatÃ­stico:**

- Cria resumo com estatÃ­sticas descritivas dos targets (`describe().T`).

**Aba 4 â€“ CorrelaÃ§Ãµes:**

- Exporta tabela contendo correlaÃ§Ãµes mÃ©dias entre features e targets.

- Indica quais features foram mantidas na seleÃ§Ã£o.

- Fecha o arquivo Excel (`writer.close()`) e confirma a criaÃ§Ã£o.

Essa celula entrega um arquivo organizado e documentado, pronto para anÃ¡lise e uso em modelos de machine learning.

</small>

---

### âœ… **Resumo Geral da Etapa de Limpeza**

ApÃ³s a execuÃ§Ã£o de todas as cÃ©lulas, o dataset estarÃ¡ pronto para ser utilizado nas prÃ³ximas fases do projeto, com:

- CÃ³digos invÃ¡lidos convertidos em `NaN`.
- Colunas pouco informativas removidas.
- Targets completos e consistentes.
- Estrutura final reduzida, porÃ©m mais confiÃ¡vel e analisÃ¡vel.

---

</details>

<details>

<summary> ðŸ“Š Fase V2 - Modelagem </summary>

### **ðŸ§© CÃ©lula 1 - InstalaÃ§Ã£o de Bibliotecas**

<details>

<summary> Trecho do codigo em Python </summary>

```python
!pip install xgboost lightgbm catboost scikit-learn pandas matplotlib seaborn plotly -q
print("âœ… Bibliotecas instaladas com sucesso!")
```

</details>

<small> ðŸ“– ExplicaÃ§Ã£o:

Esta cÃ©lula instala todas as bibliotecas necessÃ¡rias para rodar o projeto de modelagem avanÃ§ada e visualizaÃ§Ãµes.

O comando `!pip install` funciona dentro de notebooks Jupyter ou Google Colab e serve para instalar pacotes Python diretamente no ambiente.  
Aqui, estamos instalando:

- **xgboost, lightgbm, catboost** â†’ algoritmos de aprendizado de mÃ¡quina muito eficientes para regressÃ£o e classificaÃ§Ã£o.
- **scikit-learn** â†’ biblioteca com ferramentas para prÃ©-processamento, modelagem e avaliaÃ§Ã£o de dados.
- **pandas** â†’ manipulaÃ§Ã£o e anÃ¡lise de dados em tabelas.
- **matplotlib, seaborn** â†’ geraÃ§Ã£o de grÃ¡ficos e visualizaÃ§Ãµes.
- **plotly** â†’ criaÃ§Ã£o de grÃ¡ficos interativos.

</small>

---

### **ðŸ§© CÃ©lula 2 - ImportaÃ§Ã£o de Bibliotecas**

<details>

<summary> Trecho do codigo em Python </summary>

```python
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.linear_model import LinearRegression, Ridge
from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
import xgboost as xgb
import lightgbm as lgb
from catboost import CatBoostRegressor
import pickle

warnings.filterwarnings('ignore')
sns.set_style('whitegrid')

print("\n" + "=" * 80)
print("     FASE 3 COMPLETA: MODELAGEM AVANÃ‡ADA + VISUALIZAÃ‡Ã•ES")
print("=" * 80)

```

</details>

<small> ðŸ“– ExplicaÃ§Ã£o:

Nesta cÃ©lula, carregamos todas as bibliotecas necessÃ¡rias para manipulaÃ§Ã£o, anÃ¡lise, modelagem e visualizaÃ§Ã£o dos dados.

- **pandas** e **numpy**: manipulaÃ§Ã£o e cÃ¡lculo de dados.
- **matplotlib.pyplot** e **seaborn**: criaÃ§Ã£o de grÃ¡ficos estÃ¡ticos.
- **warnings**: para suprimir mensagens de aviso indesejadas.
- **sklearn.model_selection**: funÃ§Ãµes para divisÃ£o dos dados e validaÃ§Ã£o cruzada.
- **sklearn.linear_model**: modelos de regressÃ£o Linear e Ridge.
- **sklearn.ensemble**: algoritmos ensemble como Random Forest e Gradient Boosting.
- **sklearn.metrics**: cÃ¡lculo de mÃ©tricas de avaliaÃ§Ã£o como RMSE e RÂ².
- **xgboost, lightgbm, catboost**: algoritmos de machine learning de alta performance.
- **pickle**: salvar e carregar modelos treinados.

As Ãºltimas linhas configuram o estilo dos grÃ¡ficos (`sns.set_style('whitegrid')`) e imprimem um tÃ­tulo indicando o inÃ­cio da fase 3.

</small>

---

### **ðŸ§© CÃ©lula 3 - Carregamento dos Dados**

<details>

<summary> Trecho do codigo em Python </summary>

```python
df = pd.read_excel('Dados_para_modelo.xlsx')

print(f"âœ… Dados carregados com sucesso. Shape: {df.shape}")
print(f"   Total de Jogadores: {len(df)}")
print(f"   Total de Colunas: {len(df.columns)}")

```

</details>

<small> ðŸ“– ExplicaÃ§Ã£o:

Esta cÃ©lula carrega os dados de um arquivo Excel chamado `'Dados_para_modelo.xlsx'` usando a biblioteca **pandas** e armazena em um DataFrame chamado `df`.

O DataFrame Ã© uma estrutura de dados semelhante a uma tabela, muito utilizada em anÃ¡lise de dados.

- `df.shape` retorna uma tupla (nÃºmero de linhas, nÃºmero de colunas) para verificar o tamanho do dataset.
- `len(df)` retorna o nÃºmero total de linhas, representando a quantidade de jogadores.
- `len(df.columns)` retorna o nÃºmero total de colunas, representando as variÃ¡veis disponÃ­veis.

Essas impressÃµes garantem que os dados foram carregados corretamente antes de prosseguir.

</small>

---

### **ðŸ§© CÃ©lula 4 - SeparaÃ§Ã£o de Features (X) e Targets (y)**

<details>

<summary> Trecho do codigo em Python </summary>

```python
targets = ['Target1', 'Target2', 'Target3']
X = df.drop(columns=targets)
y1 = df['Target1']
y2 = df['Target2']
y3 = df['Target3']

print(f"âœ… Features (X) separadas. Total de features: {X.shape[1]}")
print(f"âœ… Targets (y1, y2, y3) separados.")
```

</details>

<small> ðŸ“– ExplicaÃ§Ã£o:

Nesta cÃ©lula, o dataset Ã© separado em duas partes principais:

- **Features (X)**: as variÃ¡veis de entrada que serÃ£o usadas para prever algo.
- **Targets (y)**: as variÃ¡veis que queremos prever.

No cÃ³digo:

- `targets` Ã© uma lista com os nomes das colunas alvo (`Target1`, `Target2`, `Target3`).
- `X` contÃ©m todas as colunas exceto as targets, obtido com `df.drop(columns=targets)`.
- `y1`, `y2` e `y3` contÃªm cada uma das targets separadamente.

</small>

---

### **ðŸ§© CÃ©lula 5 - DivisÃ£o em Dados de Treino e Teste (80/20)**

<details>

<summary> Trecho do codigo em Python </summary>

```python
X_train, X_test, y1_train, y1_test = train_test_split(X, y1, test_size=0.2, random_state=42)
_, _, y2_train, y2_test = train_test_split(X, y2, test_size=0.2, random_state=42)
_, _, y3_train, y3_test = train_test_split(X, y3, test_size=0.2, random_state=42)

print(f"âœ… Dados divididos em 80% treino e 20% teste.")
print(f"   Tamanho do treino: {len(X_train)} jogadores")
print(f"   Tamanho do teste:  {len(X_test)} jogadores")
```

</details>

<small> ðŸ“– ExplicaÃ§Ã£o:

Esta cÃ©lula divide os dados em conjuntos de treino e teste usando a funÃ§Ã£o `train_test_split` do **scikit-learn**.

- `test_size=0.2` significa que 20% dos dados serÃ£o usados para teste e 80% para treino.
- `random_state=42` garante que a divisÃ£o seja reproduzÃ­vel (sempre igual).

Para cada target (`y1`, `y2`, `y3`), sÃ£o criados conjuntos separados:

- `X_train`, `X_test`: dados de entrada para treino e teste.
- `y1_train`, `y1_test`, etc.: valores alvo correspondentes.

</small>

---

### **ðŸ§© CÃ©lula 6 - DefiniÃ§Ã£o dos Modelos a Serem Testados**

<details>

<summary> Trecho do codigo em Python </summary>

```python
modelos = {
    'Linear Regression': LinearRegression(),
    'Ridge': Ridge(alpha=1.0),
    'Random Forest': RandomForestRegressor(n_estimators=100, max_depth=10, random_state=42, n_jobs=-1),
    'Gradient Boosting': GradientBoostingRegressor(n_estimators=100, max_depth=5, random_state=42),
    'XGBoost': xgb.XGBRegressor(n_estimators=100, max_depth=6, learning_rate=0.1, random_state=42, n_jobs=-1),
    'LightGBM': lgb.LGBMRegressor(n_estimators=100, max_depth=6, learning_rate=0.1, random_state=42, n_jobs=-1, verbose=-1),
    'CatBoost': CatBoostRegressor(iterations=100, depth=6, learning_rate=0.1, random_state=42, verbose=False)
}
print(f"âœ… {len(modelos)} modelos definidos para teste.")
```

</details>

<small> ðŸ“– ExplicaÃ§Ã£o:

Nesta cÃ©lula definimos um dicionÃ¡rio chamado `modelos` contendo vÃ¡rios algoritmos de machine learning para serem testados no projeto.

Cada chave Ã© o nome do modelo e cada valor Ã© uma instÃ¢ncia do modelo com parÃ¢metros definidos:

- **Linear Regression** e **Ridge**: modelos lineares bÃ¡sicos.
- **Random Forest**: modelo ensemble baseado em Ã¡rvores, com parÃ¢metros como `n_estimators` (nÃºmero de Ã¡rvores) e `max_depth` (profundidade mÃ¡xima).
- **Gradient Boosting**: modelo ensemble que ajusta sequencialmente as Ã¡rvores para reduzir erros.
- **XGBoost, LightGBM, CatBoost**: algoritmos avanÃ§ados e muito eficientes para regressÃ£o, com parÃ¢metros como `learning_rate`, `max_depth` e nÃºmero de iteraÃ§Ãµes (`n_estimators` ou `iterations`).

</small>

---

### **ðŸ§© CÃ©lula 7 - FunÃ§Ã£o de Treinamento e AvaliaÃ§Ã£o**

<details>

<summary> Trecho do codigo em Python </summary>

```python
def treinar_avaliar_modelo(modelo, X_train, X_test, y_train, y_test):
    """FunÃ§Ã£o para treinar, prever e avaliar um modelo, retornando as mÃ©tricas e o modelo treinado."""
    modelo.fit(X_train, y_train)
    y_pred = modelo.predict(X_test)
    r2 = r2_score(y_test, y_pred)
    rmse = np.sqrt(mean_squared_error(y_test, y_pred))
    mae = mean_absolute_error(y_test, y_pred)
    return {'modelo': modelo, 'y_pred': y_pred, 'r2': r2, 'rmse': rmse, 'mae': mae}

```

</details>

<small> ðŸ“– ExplicaÃ§Ã£o:

Esta cÃ©lula define uma funÃ§Ã£o chamada `treinar_avaliar_modelo` que serve para treinar um modelo de machine learning e avaliar seu desempenho.

ParÃ¢metros da funÃ§Ã£o:

- `modelo`: objeto do modelo a ser treinado.
- `X_train`, `X_test`: dados de entrada para treino e teste.
- `y_train`, `y_test`: valores alvo para treino e teste.

O processo realizado dentro da funÃ§Ã£o:

1. `modelo.fit(X_train, y_train)` â†’ treina o modelo com os dados de treino.
2. `modelo.predict(X_test)` â†’ faz previsÃµes com os dados de teste.
3. Calcula mÃ©tricas de avaliaÃ§Ã£o:
   - **RÂ² (r2_score)**: mede a qualidade da previsÃ£o (quanto mais prÃ³ximo de 1, melhor).
   - **RMSE (root mean squared error)**: erro mÃ©dio quadrÃ¡tico.
   - **MAE (mean absolute error)**: erro absoluto mÃ©dio.

A funÃ§Ã£o retorna um dicionÃ¡rio com o modelo treinado, previsÃµes e mÃ©tricas calculadas.

</small>

---

### **ðŸ§© CÃ©lula 8 - Treinamento e AvaliaÃ§Ã£o de Todos os Modelos**

<details>

<summary> Trecho do codigo em Python </summary>

```python
print("\n" + "=" * 80)
print("ETAPA 5: TREINAMENTO E AVALIAÃ‡ÃƒO DOS MODELOS")
print("=" * 80)

# --- Target 1 ---
resultados_t1 = {}
for nome, modelo in modelos.items():
    resultados_t1[nome] = treinar_avaliar_modelo(type(modelo)(**modelo.get_params()), X_train, X_test, y1_train, y1_test)
melhor_t1 = max(resultados_t1.items(), key=lambda x: x[1]['r2'])
print(f"ðŸŽ¯ Target 1 | Melhor Modelo: {melhor_t1[0]:<20} | RÂ² = {melhor_t1[1]['r2']:.4f}")

# --- Target 2 ---
resultados_t2 = {}
for nome, modelo in modelos.items():
    resultados_t2[nome] = treinar_avaliar_modelo(type(modelo)(**modelo.get_params()), X_train, X_test, y2_train, y2_test)
melhor_t2 = max(resultados_t2.items(), key=lambda x: x[1]['r2'])
print(f"ðŸŽ¯ Target 2 | Melhor Modelo: {melhor_t2[0]:<20} | RÂ² = {melhor_t2[1]['r2']:.4f}")

# --- Target 3 ---
resultados_t3 = {}
for nome, modelo in modelos.items():
    resultados_t3[nome] = treinar_avaliar_modelo(type(modelo)(**modelo.get_params()), X_train, X_test, y3_train, y3_test)
melhor_t3 = max(resultados_t3.items(), key=lambda x: x[1]['r2'])
print(f"ðŸŽ¯ Target 3 | Melhor Modelo: {melhor_t3[0]:<20} | RÂ² = {melhor_t3[1]['r2']:.4f}")
```

</details>

<small> ðŸ“– ExplicaÃ§Ã£o:

Esta cÃ©lula realiza o treinamento e avaliaÃ§Ã£o de todos os modelos definidos para cada target (Target1, Target2, Target3).

O processo Ã© feito em trÃªs blocos:

1. Para cada target, criamos um dicionÃ¡rio (`resultados_t1`, `resultados_t2`, `resultados_t3`) para armazenar os resultados.
2. Usamos um loop `for` para percorrer cada modelo definido no dicionÃ¡rio `modelos`.
   - `type(modelo)(**modelo.get_params())` cria uma nova instÃ¢ncia do modelo com os mesmos parÃ¢metros.
   - Chamamos a funÃ§Ã£o `treinar_avaliar_modelo` para treinar e avaliar o modelo.
3. Usamos `max(..., key=lambda x: x[1]['r2'])` para selecionar o modelo com melhor RÂ² para cada target.

Ao final, imprimimos o nome do melhor modelo e seu RÂ² para cada target.  
Isso ajuda a identificar qual modelo performou melhor para cada variÃ¡vel alvo.

</small>

---

### **ðŸ§© CÃ©lula 9 - VisualizaÃ§Ã£o 1: Previsto vs. Real (GrÃ¡fico de DispersÃ£o)**

<details>

<summary> Trecho do codigo em Python </summary>

```python
fig, axes = plt.subplots(1, 3, figsize=(18, 5))
fig.suptitle('AnÃ¡lise de PrevisÃ£o vs. Valor Real para os Melhores Modelos', fontsize=16, fontweight='bold')

# GrÃ¡fico para Target 1
y1_pred = melhor_t1[1]['y_pred']
axes[0].scatter(y1_test, y1_pred, alpha=0.7, color='blue', edgecolors='k')
axes[0].plot([y1_test.min(), y1_test.max()], [y1_test.min(), y1_test.max()], 'r--', lw=2, label='Linha Perfeita')
axes[0].set_xlabel('Valores Reais', fontsize=12)
axes[0].set_ylabel('Valores Previstos', fontsize=12)
axes[0].set_title(f'Target 1 - {melhor_t1[0]}\nRÂ²={melhor_t1[1]["r2"]:.3f}', fontsize=14)
axes[0].legend()
axes[0].grid(True)

# GrÃ¡fico para Target 2
y2_pred = melhor_t2[1]['y_pred']
axes[1].scatter(y2_test, y2_pred, alpha=0.7, color='green', edgecolors='k')
axes[1].plot([y2_test.min(), y2_test.max()], [y2_test.min(), y2_test.max()], 'r--', lw=2, label='Linha Perfeita')
axes[1].set_xlabel('Valores Reais', fontsize=12)
axes[1].set_ylabel('Valores Previstos', fontsize=12)
axes[1].set_title(f'Target 2 - {melhor_t2[0]}\nRÂ²={melhor_t2[1]["r2"]:.3f}', fontsize=14)
axes[1].legend()
axes[1].grid(True)

# GrÃ¡fico para Target 3
y3_pred = melhor_t3[1]['y_pred']
axes[2].scatter(y3_test, y3_pred, alpha=0.7, color='purple', edgecolors='k')
axes[2].plot([y3_test.min(), y3_test.max()], [y3_test.min(), y3_test.max()], 'r--', lw=2, label='Linha Perfeita')
axes[2].set_xlabel('Valores Reais', fontsize=12)
axes[2].set_ylabel('Valores Previstos', fontsize=12)
axes[2].set_title(f'Target 3 - {melhor_t3[0]}\nRÂ²={melhor_t3[1]["r2"]:.3f}', fontsize=14)
axes[2].legend()
axes[2].grid(True)

plt.tight_layout(rect=[0, 0, 1, 0.96])
plt.savefig('grafico_dispersao_previsto_vs_real.png', dpi=300, bbox_inches='tight')
print("âœ… GrÃ¡fico de DispersÃ£o (Previsto vs. Real) salvo como 'grafico_dispersao_previsto_vs_real.png'")
```

</details>

<small> ðŸ“– ExplicaÃ§Ã£o:

Esta cÃ©lula cria grÃ¡ficos de dispersÃ£o comparando valores previstos pelos melhores modelos com os valores reais para cada target (Target1, Target2, Target3).

O processo inclui:

- CriaÃ§Ã£o de uma figura com trÃªs subplots (`plt.subplots(1, 3, figsize=(18, 5))`).
- Para cada target:
  - Plotar valores reais (`y_test`) vs. valores previstos (`y_pred`) usando `scatter()`.
  - Adicionar uma linha pontilhada (`plot()`) representando a previsÃ£o perfeita (quando previsto = real).
  - Configurar tÃ­tulo, rÃ³tulos e legenda.
- `plt.tight_layout()` ajusta o espaÃ§amento entre grÃ¡ficos.
- `plt.savefig()` salva a figura como `'grafico_dispersao_previsto_vs_real.png'`.

Esse tipo de grÃ¡fico ajuda a visualizar a precisÃ£o do modelo e identificar padrÃµes ou desvios.

</small>

---

### **ðŸ§© CÃ©lula 10 - VisualizaÃ§Ã£o 2: ImportÃ¢ncia das Features**

<details>

<summary> Trecho do codigo em Python </summary>

```python
def plotar_importancia(melhor_modelo_info, target_name, feature_names, ax):
    """FunÃ§Ã£o auxiliar para plotar a importÃ¢ncia das features em um eixo do matplotlib."""
    nome_modelo = melhor_modelo_info[0]
    modelo = melhor_modelo_info[1]['modelo']

    if hasattr(modelo, 'feature_importances_'):
        importances = modelo.feature_importances_
    else: # CatBoost
        importances = modelo.get_feature_importance()

    df_importances = pd.DataFrame({'feature': feature_names, 'importance': importances}).sort_values('importance', ascending=True).tail(15)

    ax.barh(df_importances['feature'], df_importances['importance'], color='darkcyan')
    ax.set_title(f'Top 15 Features - {target_name}\n(Modelo: {nome_modelo})', fontsize=14)
    ax.set_xlabel('ImportÃ¢ncia')

fig, axes = plt.subplots(1, 3, figsize=(20, 8))
fig.suptitle('AnÃ¡lise de ImportÃ¢ncia das Features para os Melhores Modelos', fontsize=16, fontweight='bold')

plotar_importancia(melhor_t1, 'Target 1', X.columns, axes[0])
plotar_importancia(melhor_t2, 'Target 2', X.columns, axes[1])
plotar_importancia(melhor_t3, 'Target 3', X.columns, axes[2])

plt.tight_layout(rect=[0, 0, 1, 0.95])
plt.savefig('grafico_feature_importance.png', dpi=300, bbox_inches='tight')
print("âœ… GrÃ¡fico de ImportÃ¢ncia das Features salvo como 'grafico_feature_importance.png'")
```

</details>

<small> ðŸ“– ExplicaÃ§Ã£o:

Esta cÃ©lula cria grÃ¡ficos mostrando a importÃ¢ncia das features para os melhores modelos de cada target.

O processo inclui:

- DefiniÃ§Ã£o da funÃ§Ã£o `plotar_importancia()`, que:

  - Recebe informaÃ§Ãµes do melhor modelo (`melhor_modelo_info`), o nome do target, os nomes das features e um eixo (`ax`) para plotagem.
  - Verifica se o modelo possui atributo `feature_importances_` (mÃ©todo comum em modelos de Ã¡rvore). Caso seja CatBoost, usa `get_feature_importance()`.
  - Cria um DataFrame com nomes e importÃ¢ncias das features, ordenando e selecionando as 15 mais importantes.
  - Plota um grÃ¡fico de barras horizontais (`barh`).

- CriaÃ§Ã£o de uma figura com trÃªs subplots para cada target.
- Chamadas da funÃ§Ã£o `plotar_importancia` para cada target.
- Ajuste de layout e salvamento do grÃ¡fico como `'grafico_feature_importance.png'`.

Esses grÃ¡ficos ajudam a entender quais variÃ¡veis tÃªm maior influÃªncia na previsÃ£o do modelo.

</small>

---

### **ðŸ§© CÃ©lula 11 - Salvando os Melhores Modelos**

<details>

<summary> Trecho do codigo em Python </summary>

```python
with open('modelo_target1_final.pkl', 'wb') as f: pickle.dump(melhor_t1[1]['modelo'], f)
print(f"âœ… Modelo para Target 1 ({melhor_t1[0]}) salvo como 'modelo_target1_final.pkl'")

with open('modelo_target2_final.pkl', 'wb') as f: pickle.dump(melhor_t2[1]['modelo'], f)
print(f"âœ… Modelo para Target 2 ({melhor_t2[0]}) salvo como 'modelo_target2_final.pkl'")

with open('modelo_target3_final.pkl', 'wb') as f: pickle.dump(melhor_t3[1]['modelo'], f)
print(f"âœ… Modelo para Target 3 ({melhor_t3[0]}) salvo como 'modelo_target3_final.pkl'")
```

</details>

<small> ðŸ“– ExplicaÃ§Ã£o:

Esta cÃ©lula salva os melhores modelos encontrados para cada target usando a biblioteca **pickle**.

O processo:

- Para cada target, abrimos um arquivo `.pkl` em modo de escrita binÃ¡ria (`'wb'`).
- Usamos `pickle.dump()` para salvar o modelo treinado (`melhor_tX[1]['modelo']`).
- Cada arquivo recebe um nome correspondente ao target (`modelo_target1_final.pkl`, etc.).
- Mensagens confirmam que os modelos foram salvos com sucesso.

Esses arquivos `.pkl` podem ser carregados posteriormente para fazer previsÃµes sem precisar treinar novamente o modelo.

</small>

---

### **ðŸ§© CÃ©lula 12 - RelatÃ³rio Final dos Resultados**

<details>

<summary> Trecho do codigo em Python </summary>

```python
print("\n" + "=" * 80)
print("ðŸŽ‰ FASE 3 COMPLETA - RELATÃ“RIO FINAL ðŸŽ‰")
print("=" * 80)

print("\nðŸ“Š RESUMO DOS MELHORES MODELOS:\n")

print(f"  TARGET 1")
print(f"  - Melhor Modelo: {melhor_t1[0]}")
print(f"  - RÂ² (R-quadrado): {melhor_t1[1]['r2']:.4f}  (Explica ~{melhor_t1[1]['r2']:.1%} da variÃ¢ncia)")
print(f"  - RMSE (Erro MÃ©dio): {melhor_t1[1]['rmse']:.2f} pontos")
print(f"  - MAE (Erro Absoluto MÃ©dio): {melhor_t1[1]['mae']:.2f} pontos\n")

print(f"  TARGET 2")
print(f"  - Melhor Modelo: {melhor_t2[0]}")
print(f"  - RÂ² (R-quadrado): {melhor_t2[1]['r2']:.4f}  (Explica ~{melhor_t2[1]['r2']:.1%} da variÃ¢ncia)")
print(f"  - RMSE (Erro MÃ©dio): {melhor_t2[1]['rmse']:.2f} pontos")
print(f"  - MAE (Erro Absoluto MÃ©dio): {melhor_t2[1]['mae']:.2f} pontos\n")

print(f"  TARGET 3")
print(f"  - Melhor Modelo: {melhor_t3[0]}")
print(f"  - RÂ² (R-quadrado): {melhor_t3[1]['r2']:.4f}  (Explica ~{melhor_t3[1]['r2']:.1%} da variÃ¢ncia)")
print(f"  - RMSE (Erro MÃ©dio): {melhor_t3[1]['rmse']:.2f} pontos")
print(f"  - MAE (Erro Absoluto MÃ©dio): {melhor_t3[1]['mae']:.2f} pontos\n")

print("ðŸ“ ARQUIVOS GERADOS:")
print("  âœ… modelo_target1_final.pkl")
print("  âœ… modelo_target2_final.pkl")
print("  âœ… modelo_target3_final.pkl")
print("  âœ… grafico_dispersao_previsto_vs_real.png")
print("  âœ… grafico_feature_importance.png")

print("\nðŸš€ PRÃ“XIMOS PASSOS:")
print("  1. Usar os arquivos '.pkl' salvos para carregar os modelos no seu backend (Node.js/FastAPI).")
print("  2. Criar as rotas da API que recebem novos dados de jogadores e usam os modelos para prever os targets.")
print("  3. Desenvolver o dashboard interativo que consome essa API e exibe os resultados e insights.")
print("  4. Preparar a apresentaÃ§Ã£o de slides contando a histÃ³ria do projeto, dos dados aos resultados.")

print("\nâœ¨ Excelente trabalho! A etapa de modelagem e anÃ¡lise estÃ¡ concluÃ­da. âœ¨")
```

</details>

<small> ðŸ“– ExplicaÃ§Ã£o:

Esta cÃ©lula gera um relatÃ³rio final resumindo os resultados obtidos na fase de modelagem.

O conteÃºdo inclui:

- **Resumo dos Melhores Modelos** para cada target, exibindo:
  - Nome do modelo com melhor performance.
  - RÂ² (R-quadrado): mede a qualidade da previsÃ£o.
  - RMSE: erro mÃ©dio quadrÃ¡tico.
  - MAE: erro absoluto mÃ©dio.
- **Lista dos arquivos gerados** no processo, incluindo modelos `.pkl` e grÃ¡ficos.
- **PrÃ³ximos passos sugeridos**, como integrar os modelos salvos a uma API e criar dashboards interativos.

</small>

---

</details>

---

**ðŸ“ˆ VisÃ£o Geral dos Resultados da Modelagem**

<small>
Nesta fase, o dataset limpo e otimizado foi utilizado para treinar e avaliar **7 algoritmos de regressÃ£o diferentes**, com o objetivo de encontrar o melhor modelo para prever cada uma das trÃªs mÃ©tricas-alvo.

ApÃ³s o treinamento e a validaÃ§Ã£o, os modelos com melhor desempenho, medido pelo coeficiente de determinaÃ§Ã£o (RÂ²), foram:

- **Target 1**: **CatBoost**, com **RÂ² = 0.577**. Isso indica que o modelo consegue explicar aproximadamente **57,7%** da variaÃ§Ã£o nos dados.
- **Target 2**: **Random Forest**, com **RÂ² = 0.406**, explicando cerca de **40,6%** da variÃ¢ncia.
- **Target 3**: **Random Forest**, com **RÂ² = 0.420**, explicando aproximadamente **42,0%** da variÃ¢ncia.

A imagem abaixo apresenta uma anÃ¡lise visual da performance desses trÃªs modelos. Cada grÃ¡fico de dispersÃ£o compara os **valores reais** (eixo X) com os **valores previstos** pelo modelo (eixo Y). A "Linha Perfeita" (tracejada em vermelho) representa o cenÃ¡rio ideal, onde a previsÃ£o Ã© exatamente igual ao valor real.

Quanto mais prÃ³ximos os pontos estiverem dessa linha, mais precisas sÃ£o as previsÃµes do modelo. Essa visualizaÃ§Ã£o ajuda a entender rapidamente a capacidade preditiva dos modelos escolhidos.
</small>

![alt text](data/processed/02_model_ready/grafico_dispersao_previsto_vs_real.png)
</file>

<file path="dashboard/frontend/Dockerfile">
FROM python:3.10-slim

WORKDIR /app

# Instala dependÃªncias
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copia o cÃ³digo da aplicaÃ§Ã£o
COPY dashboard_dash.py .

# Expor a porta do Dash (8050 Ã© o padrÃ£o do Plotly Dash)
EXPOSE 8050

# Comando para rodar a aplicaÃ§Ã£o Dash
# O Dash Ã© executado como um script Python normal (dashboard_dash.py), 
# onde a porta 8050 e o host 0.0.0.0 jÃ¡ estÃ£o definidos internamente.
CMD ["python", "dashboard_dash.py"]
</file>

<file path="dashboard/frontend/requirements.txt">
requests # Para fazer chamadas HTTP ao Flask
pandas
plotly-express
plotly
xlsxwriter
shap
matplotlib
dash 
dash-bootstrap-components 
dash-core-components 
dash-html-components 
dash-table 
numpy 
shap
</file>

<file path="dashboard/docker-compose.yml">
version: '3.8'

services:
  # 1. SERVIÃ‡O DO BANCO DE DADOS (PostgreSQL)
  db:
    image: postgres:15-alpine
    restart: always
    environment:
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}
    ports:
      - "5433:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data/
    networks:
      - daruma_net

  # 2. SERVIÃ‡O DA API (Flask/FastAPI)
  backend:
    build: ./backend
    restart: always
    environment:
      # VariÃ¡veis de ambiente para o Flask se conectar ao DB
      DATABASE_URL: postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@db:5432/${POSTGRES_DB}
      JWT_SECRET_KEY: ${JWT_SECRET_KEY}
    depends_on:
      - db
    networks:
      - daruma_net

  # 3. SERVIÃ‡O DO DASHBOARD (PLOTLY DASH)
  frontend:
    build:
      context: ./frontend  # Assumindo que o Dockerfile e o cÃ³digo estÃ£o em uma pasta 'frontend'
    restart: always
    environment:
      # VariÃ¡vel para o Dash saber onde estÃ¡ o Backend
      BACKEND_URL: http://backend:5000
    depends_on:
      - backend
    ports:
      # CORREÃ‡ÃƒO: Mapeando a porta padrÃ£o do Dash (8050)
      - "127.0.0.1:8050:8050"
    networks:
      - daruma_net

networks:
  daruma_net:
    driver: bridge

volumes:
  postgres_data:
</file>

<file path="dashboard/backend/Dockerfile">
FROM python:3.10-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copia todos os arquivos da aplicaÃ§Ã£o
COPY . .

EXPOSE 5000

# Comando para rodar a aplicaÃ§Ã£o com Uvicorn (servidor ASGI para FastAPI)
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "5000"]
</file>

<file path="dashboard/backend/requirements.txt">
fastapi
uvicorn[standard]
python-multipart
sqlalchemy
psycopg2-binary
python-jose[cryptography]
pandas
scikit-learn==1.7.2 # Fixando a versÃ£o para consistÃªncia
joblib
openpyxl
catboost
shap
Flask-Bcrypt 
optuna
lightgbm
xgboost
</file>

<file path="dashboard/frontend/dashboard_dash.py">
import dash
from dash import dcc, html, dash_table
from dash.dependencies import Input, Output, State
import dash_bootstrap_components as dbc
import requests
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go # Import necessÃ¡rio para o grÃ¡fico SHAP
import os
from io import BytesIO
import base64

# --- ConfiguraÃ§Ã£o ---
BACKEND_URL = os.getenv('BACKEND_URL', 'http://localhost:5000') 
app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP], suppress_callback_exceptions=True)
app.title = "ðŸŽ¯ Projeto Daruma: Dashboard de PrevisÃ£o"
server = app.server # Para o Gunicorn

# =============================================================================
# FUNÃ‡Ã•ES DE API E UTILITÃRIAS
# =============================================================================

def login_api(username, password):
    """Chama a API de login do backend FastAPI."""
    try:
        # ----> CORREÃ‡ÃƒO AQUI: Trocar 'json=' por 'data=' <----
        # FastAPI com OAuth2PasswordRequestForm espera dados de formulÃ¡rio.
        login_data = {'username': username, 'password': password}
        response = requests.post(f"{BACKEND_URL}/login", data=login_data)
        
        if response.status_code == 200:
            return response.json().get('access_token'), None
        else:
            # Tenta extrair a mensagem de erro detalhada do FastAPI
            detail = response.json().get('detail', 'Erro desconhecido no login.')
            return None, detail
            
    except requests.exceptions.RequestException as e:
        return None, f"Erro de conexÃ£o com o backend: {e}"
    
def register_api(username, password):
    """Chama a API de registro do backend."""
    try:
        response = requests.post(f"{BACKEND_URL}/register", json={'username': username, 'password': password})
        return (True, response.json().get('msg')) if response.status_code == 201 else (False, response.json().get('msg', 'Erro desconhecido'))
    except requests.exceptions.RequestException as e:
        return False, f"Erro de conexÃ£o com o backend: {e}"

def parse_contents(contents):
    """Decodifica o conteÃºdo do arquivo enviado via dcc.Upload."""
    _, content_string = contents.split(',')
    decoded = base64.b64decode(content_string)
    return decoded

def convert_df_to_excel(df):
    """Converte um DataFrame para um arquivo Excel em memÃ³ria e o codifica em base64."""
    output = BytesIO()
    with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
        df.to_excel(writer, index=False, sheet_name='Previsoes')
    excel_data = output.getvalue()
    return base64.b64encode(excel_data).decode('utf-8')

# =============================================================================
# COMPONENTES DE LAYOUT
# =============================================================================

store = dcc.Store(id='session-store', storage_type='session', data={'logged_in': False, 'token': None, 'username': None, 'last_results': None})
upload_data_store = dcc.Store(id='upload-data-store', storage_type='memory')

auth_layout = dbc.Container(
    dbc.Row(
        dbc.Col(
            dbc.Card(
                dbc.CardBody([
                    html.H3("ðŸŽ¯ Bem-vindo ao Projeto Daruma", className="text-center mb-4"),
                    dbc.Alert(id='auth-message', color='danger', is_open=False),
                    dbc.RadioItems(
                        id='auth-mode',
                        options=[
                            {'label': 'Login', 'value': 'login'},
                            {'label': 'Registrar', 'value': 'register'}
                        ],
                        value='login',
                        inline=True,
                        className="mb-3 d-flex justify-content-center"
                    ),
                    dbc.Input(id='username-input', placeholder='UsuÃ¡rio', type='text', className="mb-3"),
                    dbc.Input(id='password-input', placeholder='Senha', type='password', className="mb-3"),
                    dbc.Button("Acessar", id='auth-button', color='primary', n_clicks=0, className="w-100")
                ])
            ),
            width=4
        ),
        justify="center",
        align="center",
        className="vh-100"
    ),
    fluid=True
)

main_dashboard_layout = dbc.Container([
    dbc.Row([
        dbc.Col(html.H2("ðŸŽ¯ Projeto Daruma: Dashboard de PrevisÃ£o"), width='auto'),
        dbc.Col(html.Div(id='welcome-user-message'), className="text-center my-auto"),
        dbc.Col(dbc.Button("Logout", id='logout-button', color='danger'), width='auto', className="ms-auto")
    ], className="mb-4 align-items-center"),
    
    dbc.Tabs([
        dbc.Tab(label="ðŸ“Š Nova PrevisÃ£o", tab_id="predict-tab", children=[
            dcc.Upload(
                id='upload-data',
                children=html.Div(['Arraste e solte ou ', html.A('Selecione um Arquivo Excel (.xlsx)')]),
                style={'width': '100%', 'height': '60px', 'lineHeight': '60px', 'borderWidth': '1px', 'borderStyle': 'dashed', 'borderRadius': '5px', 'textAlign': 'center', 'margin': '20px 0'},
                multiple=False
            ),
            html.Div(id='upload-status', className="mb-3"),
            dbc.Button("Executar PrevisÃ£o", id='predict-button', color='success', className="mb-4", disabled=True),
            dcc.Loading(id="loading-output", type="default", children=[
                html.Div(id='prediction-results-output'),
                html.Div(id='shap-analysis-output', className="mt-4")
            ])
        ]),
        dbc.Tab(label="ðŸ§  AnÃ¡lise do Modelo", tab_id="analysis-tab", children=[
            html.H3("Ranking de ImportÃ¢ncia das Features", className="mt-3"),
            html.P("Este grÃ¡fico mostra as 20 features mais importantes que o modelo utiliza para fazer as previsÃµes para cada target."),
            dbc.Button("Carregar AnÃ¡lise", id='load-analysis-button', color='primary', className="mb-3"),
            dcc.Loading(id="loading-analysis", type="default", children=html.Div(id='feature-importance-output'))
        ]),
        dbc.Tab(label="â³ HistÃ³rico", tab_id="history-tab", children=[
            html.H3("HistÃ³rico de Uploads", className="mt-3"),
            dbc.Button("Carregar HistÃ³rico", id='load-history-button', color='secondary', className="mb-3"),
            html.Div(id='history-output')
        ]),
    ], id="tabs", active_tab="predict-tab"),
], fluid=True)

app.layout = html.Div([dcc.Location(id='url', refresh=False), store, upload_data_store, html.Div(id='page-content')])

# =============================================================================
# FUNÃ‡Ã•ES DE RENDERIZAÃ‡ÃƒO
# =============================================================================

def render_prediction_results(predictions_data):
    """
    ### FUNÃ‡ÃƒO SIMPLIFICADA ###
    Gera o layout dos resultados da previsÃ£o com tabela ordenÃ¡vel e grÃ¡fico de barras.
    """
    if not predictions_data:
        return dbc.Alert("Nenhuma previsÃ£o retornada.", color="warning")

    df_output = pd.DataFrame(predictions_data)
    excel_base64 = convert_df_to_excel(df_output)

    # GrÃ¡fico de barras das previsÃµes
    # O melt transforma as colunas de previsÃ£o em linhas, facilitando a plotagem
    df_melted = df_output.melt(
        id_vars='CÃ³digo de Acesso', 
        value_vars=['PrevisÃ£o T1', 'PrevisÃ£o T2', 'PrevisÃ£o T3'], 
        var_name='Target', 
        value_name='Valor Previsto'
    )
    fig_bar = px.bar(
        df_melted, 
        x='CÃ³digo de Acesso', 
        y='Valor Previsto', 
        color='Target', 
        title="PrevisÃµes dos Targets por Jogador", 
        barmode='group',
        labels={'CÃ³digo de Acesso': 'Jogador', 'Valor Previsto': 'Valor da PrevisÃ£o'}
    )
    fig_bar.update_layout(xaxis={'categoryorder':'total descending'}) # Ordena o grÃ¡fico pelo valor total

    return html.Div([
        html.H4("Resultados da PrevisÃ£o", className="mt-4"),
        # A tabela agora Ã© ordenÃ¡vel pelo usuÃ¡rio clicando nos cabeÃ§alhos
        dash_table.DataTable(
            id='predictions-table',
            columns=[{"name": i, "id": i} for i in df_output.columns],
            data=df_output.to_dict('records'),
            style_table={'overflowX': 'auto'},
            sort_action="native",  # Habilita a ordenaÃ§Ã£o pelo frontend
            filter_action="native", # Habilita filtros simples
            page_action="native",
            page_current=0,
            page_size=10,
            style_header={'backgroundColor': 'rgb(230, 230, 230)', 'fontWeight': 'bold'}
        ),
        html.A(
            dbc.Button("ðŸ“¥ Baixar Resultados (.xlsx)", color="info", className="mt-3"),
            id='download-link',
            href=f"data:application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;base64,{excel_base64}",
            download="previsoes_daruma.xlsx"
        ),
        html.H4("ComparaÃ§Ã£o Visual", className="mt-4"),
        dcc.Graph(id='bar-chart', figure=fig_bar)
    ])

# =============================================================================
# CALLBACKS (SEM ALTERAÃ‡Ã•ES NAS SEÃ‡Ã•ES DE AUTENTICAÃ‡ÃƒO E UPLOAD)
# =============================================================================

@app.callback(
    Output('page-content', 'children'),
    [Input('session-store', 'data'), Input('url', 'pathname')]
)
def render_page_content(data, pathname):
    is_logged_in = data and data.get('logged_in')

    if pathname == '/dashboard' and is_logged_in:
        return main_dashboard_layout
    elif pathname == '/logout':
        # Limpa os dados da sessÃ£o ao fazer logout
        data['logged_in'] = False
        data['token'] = None
        data['username'] = None
        data['last_results'] = None
        return auth_layout
    elif is_logged_in:
        # Se estiver logado mas a URL for a raiz ('/'), mostra o dashboard
        return main_dashboard_layout
    else:
        # Se nÃ£o estiver logado, sempre mostra a tela de login
        return auth_layout
@app.callback(
    [
        Output('url', 'pathname', allow_duplicate=True), # <-- ADICIONE ESTA LINHA
        Output('session-store', 'data'),
        Output('auth-message', 'children'),
        Output('auth-message', 'is_open')
    ],
    [Input('auth-button', 'n_clicks')],
    [
        State('auth-mode', 'value'),
        State('username-input', 'value'),
        State('password-input', 'value'),
        State('session-store', 'data')
    ],
    prevent_initial_call=True
)
def handle_auth(n_clicks, auth_mode, username, password, data):
    if not username or not password:
        # dash.no_update para a URL, pois nÃ£o queremos redirecionar
        return dash.no_update, dash.no_update, "UsuÃ¡rio e senha sÃ£o obrigatÃ³rios.", True

    if auth_mode == 'login':
        token, error = login_api(username, password)
        if token:
            data.update({'logged_in': True, 'token': token, 'username': username})
            # Redireciona para /dashboard em caso de sucesso
            return '/dashboard', data, "", False
        # Se o login falhar, nÃ£o redireciona
        return dash.no_update, dash.no_update, error, True
        
    elif auth_mode == 'register':
        success, message = register_api(username, password)
        # NÃ£o redireciona no registro, apenas mostra a mensagem
        return dash.no_update, dash.no_update, message, True
        
    return dash.no_update, dash.no_update, "", False

@app.callback(Output('welcome-user-message', 'children'), Input('session-store', 'data'))
def update_welcome_message(data):
    return f"Bem-vindo(a), {data.get('username')}!" if data and data.get('logged_in') else ""

@app.callback(
    [Output('url', 'pathname', allow_duplicate=True),
     Output('session-store', 'data', allow_duplicate=True)],
    [Input('logout-button', 'n_clicks')],
    [State('session-store', 'data')],
    prevent_initial_call=True
)
def handle_logout(n_clicks, data):
    if n_clicks:
        data.update({'logged_in': False, 'token': None, 'username': None, 'last_results': None})
        return '/logout', data
    return dash.no_update, dash.no_update

@app.callback(
    [Output('upload-data-store', 'data'), Output('upload-status', 'children'), Output('predict-button', 'disabled')],
    [Input('upload-data', 'contents')],
    [State('upload-data', 'filename')],
    prevent_initial_call=True
)
def handle_upload(contents, filename):
    if contents:
        decoded_content = parse_contents(contents)
        stored_data = {'filename': filename, 'contents': base64.b64encode(decoded_content).decode('utf-8')}
        return stored_data, html.Div(['Arquivo selecionado: ', html.B(filename)]), False
    return None, "", True

# --- CALLBACK DE PREVISÃƒO (Simplificado) ---
@app.callback(
    [Output('prediction-results-output', 'children'), Output('session-store', 'data', allow_duplicate=True)],
    [Input('predict-button', 'n_clicks')],
    [State('session-store', 'data'), State('upload-data-store', 'data')],
    prevent_initial_call=True
)
def run_prediction(n_clicks, session_data, upload_data):
    if not n_clicks or not upload_data or not session_data.get('token'):
        raise dash.exceptions.PreventUpdate

    headers = {'Authorization': f'Bearer {session_data["token"]}'}
    files = {'file': (upload_data['filename'], base64.b64decode(upload_data['contents']), 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')}
    
    try:
        response = requests.post(f"{BACKEND_URL}/predict", headers=headers, files=files)
        if response.status_code == 200:
            response_json = response.json()
            predictions_list = response_json.get('predictions')
            session_data['last_results'] = response_json
            return render_prediction_results(predictions_list), session_data
        else:
            return dbc.Alert(f"Erro na API: {response.json().get('msg')}", color="danger"), dash.no_update
    except requests.exceptions.RequestException as e:
        return dbc.Alert(f"Erro de conexÃ£o com o backend: {e}", color="danger"), dash.no_update

# --- CALLBACKS DE HISTÃ“RICO E ANÃLISE (Sem alteraÃ§Ãµes) ---
@app.callback(
    Output('history-output', 'children'),
    Input('load-history-button', 'n_clicks'),
    State('session-store', 'data'),
    prevent_initial_call=True
)
def load_history(n_clicks, data):
    if not data or not data.get('token'):
        return dbc.Alert("SessÃ£o invÃ¡lida.", color="danger")
    
    headers = {'Authorization': f'Bearer {data["token"]}'}
    try:
        response = requests.get(f"{BACKEND_URL}/history", headers=headers)
        if response.status_code == 200:
            history_data = response.json()
            if not history_data:
                return dbc.Alert("Nenhum histÃ³rico encontrado.", color="info")
            df_history = pd.DataFrame(history_data)
            return dash_table.DataTable(
                columns=[{'name': 'Data do Upload', 'id': 'timestamp'}, {'name': 'NÂº de Jogadores Previstos', 'id': 'num_jogadores'}],
                data=df_history.to_dict('records'),
                sort_action="native"
            )
        else:
            print(f"Erro ao buscar histÃ³rico: {response.json().get('msg')}")
            return dbc.Alert(f"Erro ao buscar histÃ³rico: {response.json().get('msg')}", color="danger")
    except requests.exceptions.RequestException as e:
        return dbc.Alert(f"Erro de conexÃ£o com o backend: {e}", color="danger")

@app.callback(
    Output('feature-importance-output', 'children'),
    Input('load-analysis-button', 'n_clicks'),
    State('session-store', 'data'),
    prevent_initial_call=True
)
def load_feature_importance(n_clicks, data):
    if not data or not data.get('token'):
        return dbc.Alert("SessÃ£o invÃ¡lida.", color="danger")

    headers = {'Authorization': f'Bearer {data["token"]}'}
    try:
        response = requests.get(f"{BACKEND_URL}/feature_importance", headers=headers)
        if response.status_code == 200:
            importances = response.json()
            graphs = []
            for target, features in importances.items():
                if not features: continue
                df_importance = pd.DataFrame(features)
                fig = px.bar(df_importance, x='importance', y='feature', orientation='h', title=f"ImportÃ¢ncia para o {target}")
                fig.update_layout(yaxis={'categoryorder':'total ascending'})
                graphs.append(dcc.Graph(figure=fig))
            return html.Div(graphs) if graphs else dbc.Alert("Nenhuma informaÃ§Ã£o de importÃ¢ncia de feature disponÃ­vel.", color="info")
        else:
            return dbc.Alert(f"Erro ao buscar dados: {response.json().get('msg')}", color="danger")
    except requests.exceptions.RequestException as e:
        return dbc.Alert(f"Erro de conexÃ£o com o backend: {e}", color="danger")

# --- CALLBACK DO SHAP (Sem alteraÃ§Ãµes) ---
@app.callback(
    Output('shap-analysis-output', 'children'),
    Input('session-store', 'data') # Dispara quando os resultados da sessÃ£o sÃ£o atualizados
)
def render_shap_analysis(session_data):
    if not session_data or 'last_results' not in session_data or not session_data['last_results']:
        return None

    shap_data = session_data['last_results'].get('shap_data')
    if not shap_data:
        return None # NÃ£o renderiza nada se nÃ£o houver dados SHAP

    # Pega a lista de jogadores (as chaves do dicionÃ¡rio shap_data)
    jogadores = list(shap_data.keys())
    
    return html.Div([
        html.H4("AnÃ¡lise de ContribuiÃ§Ã£o das Features (SHAP)", className="mt-5"),
        html.P("Selecione um jogador para ver como cada feature contribuiu para a sua previsÃ£o. Valores positivos empurram a previsÃ£o para cima, e valores negativos, para baixo."),
        
        dbc.Row([
            dbc.Col(
                dcc.Dropdown(
                    id='shap-player-dropdown',
                    options=[{'label': j, 'value': j} for j in jogadores],
                    value=jogadores[0], # Seleciona o primeiro jogador por padrÃ£o
                    clearable=False
                ),
                width=12, md=6, lg=4
            )
        ], className="mb-4"),

        # Este Div receberÃ¡ os grÃ¡ficos do jogador selecionado
        dcc.Loading(html.Div(id='shap-graphs-container'))
    ])

@app.callback(
    Output('shap-graphs-container', 'children'),
    Input('shap-player-dropdown', 'value'),
    State('session-store', 'data')
)
def update_shap_graphs(selected_player, session_data):
    if not selected_player or not session_data or not session_data.get('last_results'):
        return None

    all_predictions = session_data['last_results'].get('predictions', [])
    shap_data = session_data['last_results'].get('shap_data', {})
    
    # Encontra os dados de previsÃ£o para o jogador selecionado
    player_predictions = next((p for p in all_predictions if p['CÃ³digo de Acesso'] == selected_player), None)
    
    # Encontra os dados SHAP para o jogador selecionado
    player_shap_data = shap_data.get(selected_player)

    if not player_shap_data or not player_predictions:
        return dbc.Alert("Dados nÃ£o encontrados para o jogador selecionado.", color="warning")

    # --- ### NOVA SEÃ‡ÃƒO: CRIAÃ‡ÃƒO DOS CARTÃ•ES DE RESULTADO (KPIs) ### ---
    kpi_cards = dbc.Row([
        dbc.Col(dbc.Card([
            dbc.CardHeader("PrevisÃ£o Target 1"),
            dbc.CardBody(html.H4(f"{player_predictions.get('PrevisÃ£o T1', 'N/A')}", className="card-title"))
        ], color="primary", inverse=True), md=4),
        dbc.Col(dbc.Card([
            dbc.CardHeader("PrevisÃ£o Target 2"),
            dbc.CardBody(html.H4(f"{player_predictions.get('PrevisÃ£o T2', 'N/A')}", className="card-title"))
        ], color="success", inverse=True), md=4),
        dbc.Col(dbc.Card([
            dbc.CardHeader("PrevisÃ£o Target 3"),
            dbc.CardBody(html.H4(f"{player_predictions.get('PrevisÃ£o T3', 'N/A')}", className="card-title"))
        ], color="info", inverse=True), md=4)
    ], className="mb-4")


    # --- GeraÃ§Ã£o dos grÃ¡ficos de barras SHAP (lÃ³gica existente) ---
    graphs = []
    for target_key, data in player_shap_data.items():
        if not all(k in data for k in ['feature_names', 'shap_values']):
            continue
            
        df_shap = pd.DataFrame({
            'feature': data['feature_names'],
            'shap_value': data['shap_values']
        }).sort_values(by='shap_value', key=abs, ascending=False).head(15)

        fig = px.bar(
            df_shap,
            x='shap_value',
            y='feature',
            orientation='h',
            title=f"ContribuiÃ§Ãµes (SHAP) para {target_key} do Jogador: {selected_player}",
            labels={'shap_value': 'Impacto na PrevisÃ£o', 'feature': 'Feature'}
        )
        fig.update_layout(yaxis={'categoryorder': 'total ascending'})
        graphs.append(dcc.Graph(figure=fig))
    
    # --- Retorna os cartÃµes e os grÃ¡ficos juntos ---
    return html.Div([kpi_cards] + graphs) if graphs else html.Div(kpi_cards)

if __name__ == '__main__':
    # Use 'debug=False' para produÃ§Ã£o com Gunicorn
    app.run(debug=True, host='0.0.0.0', port=8050)
</file>

</files>
