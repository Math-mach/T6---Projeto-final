This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.repomixignore
dashboard/backend/auth.py
dashboard/backend/core.py
dashboard/backend/crud.py
dashboard/backend/database.py
dashboard/backend/Dockerfile
dashboard/backend/export_artifacts_cluster.py
dashboard/backend/export_artifacts_target1.py
dashboard/backend/export_artifacts_target2.py
dashboard/backend/export_artifacts_target3.py
dashboard/backend/export_hibrido_target1.py
dashboard/backend/export_hibrido_target2.py
dashboard/backend/export_hibrido_target3.py
dashboard/backend/main.py
dashboard/backend/models.py
dashboard/backend/README.md
dashboard/backend/repomix-output.xml
dashboard/backend/requirements.txt
dashboard/backend/schemas.py
dashboard/docker-compose.yml
dashboard/frontend/dashboard_dash.py
dashboard/frontend/Dockerfile
dashboard/frontend/README.md
dashboard/frontend/requirements.txt
dashboard/README.md
notebooks/PROJETOFINAL.ipynb
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".repomixignore">
# Arquivos de configura√ß√£o de ambiente e exemplos
dashboard/.env.example
.env

# Arquivos gerados pelo Git e editores
.gitignore

# Dados de treinamento e artefatos de ML (gerados pelos scripts)
# √â melhor ignor√°-los se a l√≥gica principal est√° nos scripts de exporta√ß√£o
# e no notebook. O repomix j√° ignora bin√°rios como .pkl por padr√£o.
dashboard/backend/ml_artifacts/
*.pkl
*.joblib

# Dados brutos e intermedi√°rios (se existirem)
notebooks/JogadoresV1.xlsx
Dados_Otimizados_V4.xlsx
Dados_para_modelo.xlsx

# Arquivos de cache e logs do treinamento do CatBoost
dashboard/backend/catboost_info/

# Arquivos de cache do Python
__pycache__/
*.pyc

# Pontos de verifica√ß√£o de notebooks
.ipynb_checkpoints/
</file>

<file path="dashboard/backend/auth.py">
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from datetime import datetime, timedelta
import os
from core import bcrypt # <--- IMPORTA√á√ÉO CHAVE

SECRET_KEY = os.getenv('JWT_SECRET_KEY', 'default_secret_key')
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="login")

def verify_password(plain_password, hashed_password):
    """Verifica a senha usando bcrypt."""
    # A biblioteca Flask-Bcrypt espera que o hash seja um bytes-like object
    return bcrypt.check_password_hash(hashed_password.encode('utf-8'), plain_password)

def get_password_hash(password):
    """Gera o hash da senha usando bcrypt."""
    return bcrypt.generate_password_hash(password).decode('utf-8')

def create_access_token(data: dict):
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

async def get_current_user_id(token: str = Depends(oauth2_scheme)):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        user_id: str = payload.get("sub")
        if user_id is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception
    return user_id
</file>

<file path="dashboard/backend/core.py">
from fastapi import FastAPI
from flask_bcrypt import Bcrypt

app = FastAPI(title="API do Projeto Daruma")

# Instancia o Bcrypt diretamente, sem associar a um app Flask.
bcrypt = Bcrypt()
</file>

<file path="dashboard/backend/crud.py">
# crud.py
from sqlalchemy.orm import Session
import models
import auth

def get_user_by_username(db: Session, username: str):
    return db.query(models.User).filter(models.User.username == username).first()

def create_user(db: Session, user_schema: models.User):
    hashed_password = auth.get_password_hash(user_schema.password)
    db_user = models.User(username=user_schema.username, password_hash=hashed_password)
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user
</file>

<file path="dashboard/backend/database.py">
# database.py
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
import os

SQLALCHEMY_DATABASE_URL = os.getenv('DATABASE_URL', 'postgresql://user:password@db:5432/daruma_db')

engine = create_engine(SQLALCHEMY_DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

# Dependency para obter a sess√£o do DB
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
</file>

<file path="dashboard/backend/export_artifacts_cluster.py">
import pandas as pd
import numpy as np
import joblib
import pickle
import os
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA
from sklearn.metrics import silhouette_score

print("="*80)
print("INICIANDO EXPORTA√á√ÉO DE ARTEFATOS DE CLUSTERING")
print("="*80)

# --- 1. CONFIGURA√á√ïES ---
ARTIFACTS_PATH = "ml_artifacts"
# Garanta que o arquivo de dados usado aqui √© o mesmo dos outros scripts de exporta√ß√£o
RAW_DATA_FILE = 'JogadoresV3.xlsx' 
RANDOM_STATE = 42

if not os.path.exists(ARTIFACTS_PATH):
    os.makedirs(ARTIFACTS_PATH)

# --- 2. CARREGAMENTO E FEATURE ENGINEERING ---
print(f"\n[FASE 1] Carregando e processando dados de '{RAW_DATA_FILE}'...")
try:
    df = pd.read_excel(RAW_DATA_FILE)
except FileNotFoundError:
    print(f"‚ùå ERRO: Arquivo '{RAW_DATA_FILE}' n√£o encontrado. Certifique-se de que ele est√° na pasta 'backend'.")
    exit()

# L√≥gica de pr√©-processamento e feature engineering para o clustering
if 'F0103' in df.columns:
    df['F0103'] = pd.to_numeric(df['F0103'].astype(str).str.replace(',', '.'), errors='coerce')

p_cols = [c for c in df.columns if c.startswith('P') and any(char.isdigit() for char in c)]
t_cols = [c for c in df.columns if c.startswith('T') and any(char.isdigit() for char in c)]
f_cols = [c for c in df.columns if c.startswith('F') and len(c) > 1 and any(char.isdigit() for char in c)]

for col in p_cols + t_cols + f_cols:
    if col in df.columns:
        df[col] = pd.to_numeric(df[col], errors='coerce').replace(-1, np.nan)
        if df[col].isnull().sum() > 0:
            df[col].fillna(df[col].median(), inplace=True)

# Cria√ß√£o das features que ser√£o usadas no clustering
if p_cols:
    df['P_mean'] = df[p_cols].mean(axis=1)
    df['P_std'] = df[p_cols].std(axis=1)
    df['P_max'] = df[p_cols].max(axis=1)
if t_cols:
    df['T_mean'] = df[t_cols].mean(axis=1)
    df['T_total'] = df[t_cols].sum(axis=1)

f_sono = [c for c in f_cols if c.startswith('F07')]
if f_sono: df['F_sono_mean'] = df[f_sono].mean(axis=1)

f_final = [c for c in f_cols if c.startswith('F11')]
if f_final: df['F_final_mean'] = df[f_final].mean(axis=1)

# Lista final de features para clustering
cluster_features = ['P_mean', 'P_std', 'T_mean', 'F_sono_mean', 'F_final_mean']
# Garante que s√≥ usaremos features que realmente existem no DataFrame
cluster_features = [f for f in cluster_features if f in df.columns]

X_cluster = df[cluster_features].fillna(df[cluster_features].median())

print(f"‚úÖ Features para clustering selecionadas: {cluster_features}")

# --- 3. TREINAMENTO E EXPORTA√á√ÉO DOS ARTEFATOS DE CLUSTERING ---
print("\n[FASE 2] Treinando e salvando modelos de clustering...")

# Scaler
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X_cluster)
joblib.dump(scaler, f'{ARTIFACTS_PATH}/scaler_cluster.pkl')
print("üíæ Scaler de clustering salvo.")

# K-Means
kmeans = KMeans(n_clusters=2, random_state=RANDOM_STATE, n_init=10)
clusters = kmeans.fit_predict(X_scaled)
joblib.dump(kmeans, f'{ARTIFACTS_PATH}/kmeans_model.pkl')
print(f"üíæ Modelo KMeans treinado e salvo (Silhouette Score: {silhouette_score(X_scaled, clusters):.3f}).")

# PCA
pca = PCA(n_components=2, random_state=RANDOM_STATE)
pca.fit(X_scaled) # Apenas 'fit' √© necess√°rio para salvar o modelo treinado
joblib.dump(pca, f'{ARTIFACTS_PATH}/pca_model.pkl')
print(f"üíæ Modelo PCA treinado e salvo (Vari√¢ncia explicada: {sum(pca.explained_variance_ratio_)*100:.1f}%).")

# Nomes dos Clusters (para consist√™ncia na API)
df['Cluster'] = clusters
cluster_names = {}
# Define o nome baseado na performance m√©dia (P_mean)
if df.groupby('Cluster')['P_mean'].mean()[0] > df.groupby('Cluster')['P_mean'].mean()[1]:
    cluster_names[0] = "Perfil A (Alto Desempenho)"
    cluster_names[1] = "Perfil B (Desempenho Moderado)"
else:
    cluster_names[1] = "Perfil A (Alto Desempenho)"
    cluster_names[0] = "Perfil B (Desempenho Moderado)"

with open(f'{ARTIFACTS_PATH}/cluster_names.pkl', 'wb') as f:
    pickle.dump(cluster_names, f)
print(f"üíæ Nomes dos clusters salvos: {cluster_names}")

# Lista de Features
with open(f'{ARTIFACTS_PATH}/cluster_features.pkl', 'wb') as f:
    pickle.dump(cluster_features, f)
print("üíæ Lista de features de clustering salva.")
print("\n--- Conclu√≠do ---")
</file>

<file path="dashboard/backend/export_artifacts_target1.py">
# export_artifacts_target1.py

import pandas as pd
import numpy as np
import os
import pickle
import joblib
import optuna
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import RobustScaler
from sklearn.feature_selection import VarianceThreshold
from sklearn.metrics import r2_score
from catboost import CatBoostRegressor

print("="*80)
print("INICIANDO EXPORTA√á√ÉO DE ARTEFATOS PARA O TARGET 1")
print("="*80)

# --- 1. CONFIGURA√á√ïES ---
ARTIFACTS_PATH = "ml_artifacts"
if not os.path.exists(ARTIFACTS_PATH):
    os.makedirs(ARTIFACTS_PATH)
TARGET = 'Target1'
RAW_DATA_FILE = 'JogadoresV1.xlsx'
RANDOM_STATE = 42

# --- 2. CARREGAMENTO E FEATURE ENGINEERING (L√≥gica do Notebook Fase 2) ---
print(f"\n[FASE 1] Carregando e processando dados de '{RAW_DATA_FILE}'...")
try:
    df = pd.read_excel(RAW_DATA_FILE)
except FileNotFoundError:
    print(f"‚ùå ERRO: Arquivo '{RAW_DATA_FILE}' n√£o encontrado.")
    exit()

df.dropna(subset=[TARGET], inplace=True)

# Limpeza e convers√£o de tipos
if 'F0103' in df.columns:
    df['F0103'] = pd.to_numeric(df['F0103'].astype(str).str.replace(',', '.'), errors='coerce')

p_cols = [c for c in df.columns if c.startswith('P') and any(char.isdigit() for char in c)]
t_cols = [c for c in df.columns if c.startswith('T') and any(char.isdigit() for char in c)]
f_cols = [c for c in df.columns if c.startswith('F') and len(c) > 1 and any(char.isdigit() for char in c)]

for col in p_cols + t_cols + f_cols:
    df[col] = pd.to_numeric(df[col], errors='coerce')
    df[col].replace(-1, np.nan, inplace=True)

# Imputa√ß√£o com mediana
for col in p_cols + t_cols + f_cols:
    if df[col].isnull().sum() > 0:
        df[col].fillna(df[col].median(), inplace=True)

# Feature Engineering
if 'QtdHorasDormi' in df.columns and 'Acordar' in df.columns:
    df['sono_total'] = df['QtdHorasDormi']
    df['sono_x_acordar'] = df['QtdHorasDormi'] * df['Acordar']

if p_cols:
    df['P_mean'] = df[p_cols].mean(axis=1)
    df['P_std'] = df[p_cols].std(axis=1)

if t_cols:
    df['T_mean'] = df[t_cols].mean(axis=1)

# Agrega√ß√µes conceituais de F
f_sono = [c for c in f_cols if c.startswith('F07')]
if f_sono:
    df['F_sono_mean'] = df[f_sono].mean(axis=1)

print("‚úÖ Dados processados e features criadas.")

# --- 3. SELE√á√ÉO DE FEATURES ---
print("\n[FASE 2] Selecionando as melhores features...")
numeric_features = df.select_dtypes(include=np.number).columns.tolist()
features_to_exclude = ['Target1', 'Target2', 'Target3']
feature_candidates = [f for f in numeric_features if f not in features_to_exclude]

X_temp = df[feature_candidates].fillna(0)
selector = VarianceThreshold(threshold=0.01)
selector.fit(X_temp)
feature_cols_var = X_temp.columns[selector.get_support()].tolist()

correlations = [(col, abs(df[col].corr(df[TARGET]))) for col in feature_cols_var]
correlations = [corr for corr in correlations if not np.isnan(corr[1])]
correlations.sort(key=lambda x: x[1], reverse=True)

TOP_K = 30
selected_features = [col for col, _ in correlations[:TOP_K]]

# Intera√ß√µes
top3_features = selected_features[:3]
for i, f1 in enumerate(top3_features):
    for f2 in top3_features[i+1:]:
        interaction_name = f'{f1}_X_{f2}'
        df[interaction_name] = df[f1] * df[f2]
        selected_features.append(interaction_name)

selected_features = list(dict.fromkeys(selected_features))
print(f"‚úÖ {len(selected_features)} features finais selecionadas para {TARGET}.")

# --- 4. PREPARA√á√ÉO FINAL E SALVAMENTO DE ARTEFATOS ---
X = df[selected_features]
y = df[TARGET]

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=RANDOM_STATE)

# Scaler
scaler = RobustScaler()
X_train_scaled = scaler.fit_transform(X_train)
joblib.dump(scaler, f'{ARTIFACTS_PATH}/scaler_{TARGET.lower()}.pkl')
print(f"üíæ Scaler para {TARGET} salvo em: {ARTIFACTS_PATH}/scaler_{TARGET.lower()}.pkl")

# Lista de Features
with open(f'{ARTIFACTS_PATH}/features_{TARGET.lower()}.pkl', 'wb') as f:
    pickle.dump(selected_features, f)
print(f"üíæ Lista de features para {TARGET} salva em: {ARTIFACTS_PATH}/features_{TARGET.lower()}.pkl")

# --- 5. OTIMIZA√á√ÉO E TREINAMENTO DO MODELO (L√≥gica do Notebook Fase 3) ---
print(f"\n[FASE 3] Otimizando e treinando o modelo para {TARGET}...")

def objective_t1(trial):
    params = {
        'iterations': 500,
        'learning_rate': trial.suggest_float('learning_rate', 0.01, 0.1, log=True),
        'depth': trial.suggest_int('depth', 3, 6),
        'l2_leaf_reg': trial.suggest_float('l2_leaf_reg', 10, 100, log=True),
        'verbose': False,
        'random_seed': RANDOM_STATE
    }
    model = CatBoostRegressor(**params)
    model.fit(X_train_scaled, y_train, eval_set=[(scaler.transform(X_test), y_test)], early_stopping_rounds=50, verbose=False)
    preds = model.predict(scaler.transform(X_test))
    return r2_score(y_test, preds)

study = optuna.create_study(direction='maximize')
study.optimize(objective_t1, n_trials=50) # 50 trials for a good balance
best_params = study.best_params
best_params['iterations'] = 500 # Re-set iterations
best_params['verbose'] = False
best_params['random_seed'] = RANDOM_STATE

final_model = CatBoostRegressor(**best_params)
final_model.fit(X_train_scaled, y_train)

print(f"‚úÖ Modelo {TARGET} treinado com R¬≤ de {study.best_value:.4f} na otimiza√ß√£o.")

# Salvamento do Modelo
joblib.dump(final_model, f'{ARTIFACTS_PATH}/modelo_{TARGET.lower()}.pkl')
print(f"üíæ Modelo para {TARGET} salvo em: {ARTIFACTS_PATH}/modelo_{TARGET.lower()}.pkl")
print("\n--- Conclu√≠do para Target 1 ---")
</file>

<file path="dashboard/backend/export_artifacts_target2.py">
# export_artifacts_target2.py

import pandas as pd
import numpy as np
import os
import pickle
import joblib
import optuna
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.preprocessing import RobustScaler, PolynomialFeatures
from sklearn.ensemble import RandomForestRegressor, StackingRegressor
from sklearn.linear_model import Ridge
from catboost import CatBoostRegressor
import lightgbm as lgb
import xgboost as xgb

print("="*80)
print("INICIANDO EXPORTA√á√ÉO DE ARTEFATOS PARA O TARGET 2")
print("="*80)

# --- 1. CONFIGURA√á√ïES ---
ARTIFACTS_PATH = "ml_artifacts"
if not os.path.exists(ARTIFACTS_PATH):
    os.makedirs(ARTIFACTS_PATH)
TARGET = 'Target2'
RAW_DATA_FILE = 'JogadoresV1.xlsx'
RANDOM_STATE = 42

# --- 2. CARREGAMENTO E FEATURE ENGINEERING ---
print(f"\n[FASE 1] Carregando e processando dados de '{RAW_DATA_FILE}'...")
try:
    df = pd.read_excel(RAW_DATA_FILE)
except FileNotFoundError:
    print(f"‚ùå ERRO: Arquivo '{RAW_DATA_FILE}' n√£o encontrado.")
    exit()

df.dropna(subset=[TARGET], inplace=True)

# Limpeza e FE simples
if 'F0103' in df.columns:
    df['F0103'] = pd.to_numeric(df['F0103'].astype(str).str.replace(',', '.'), errors='coerce')
if 'QtdHorasDormi' in df.columns and 'Acordar' in df.columns:
    df['sono_total'] = df['QtdHorasDormi']
    df['sono_x_acordar'] = df['QtdHorasDormi'] * df['Acordar']

p_cols = [c for c in df.columns if c.startswith('P') and any(char.isdigit() for char in c)]
t_cols = [c for c in df.columns if c.startswith('T') and any(char.isdigit() for char in c)]
f_cols = [c for c in df.columns if c.startswith('F') and len(c) > 1 and any(char.isdigit() for char in c)]

for col in p_cols + t_cols + f_cols:
    df[col] = pd.to_numeric(df[col], errors='coerce')

if p_cols:
    df['P_mean'] = df[p_cols].mean(axis=1)
if t_cols:
    df['T_mean'] = df[t_cols].mean(axis=1)
if f_cols:
    df['F_mean'] = df[f_cols].mean(axis=1)

# Imputa√ß√£o final antes de separar
numeric_cols = df.select_dtypes(include=np.number).columns
for col in numeric_cols:
    df[col].fillna(df[col].median(), inplace=True)

print("‚úÖ Dados processados e features base criadas.")

# --- 3. PREPARA√á√ÉO E SEPARA√á√ÉO DE DADOS ---
features_to_exclude = ['Target1', 'Target2', 'Target3', 'C√≥digo de Acesso', 'Data/Hora √öltimo']
initial_features = [col for col in df.columns if col not in features_to_exclude and pd.api.types.is_numeric_dtype(df[col])]

X = df[initial_features]
y = df[TARGET]

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=RANDOM_STATE)

# --- 4. FEATURE ENGINEERING AVAN√áADA E SELE√á√ÉO ---
print("\n[FASE 2] Criando features polinomiais e selecionando as melhores...")
# Features Polinomiais
rf_poly_selector = RandomForestRegressor(n_estimators=100, random_state=RANDOM_STATE, n_jobs=-1)
rf_poly_selector.fit(X_train, y_train)
importances = pd.Series(rf_poly_selector.feature_importances_, index=X_train.columns).sort_values(ascending=False)
top_features_for_poly = importances.head(15).index.tolist()

poly = PolynomialFeatures(degree=2, include_bias=False, interaction_only=True)
X_train_poly = poly.fit_transform(X_train[top_features_for_poly])
poly_names = [f"poly_{name}" for name in poly.get_feature_names_out(top_features_for_poly)]
X_train_poly_df = pd.DataFrame(X_train_poly, columns=poly_names, index=X_train.index)
X_train_expanded = X_train.join(X_train_poly_df)

# Sele√ß√£o H√≠brida
correlations = X_train_expanded.corrwith(y_train).abs().sort_values(ascending=False)
top_corr_features = correlations.head(60).index.tolist()
rf_final_selector = RandomForestRegressor(n_estimators=100, random_state=RANDOM_STATE, n_jobs=-1)
rf_final_selector.fit(X_train_expanded, y_train)
importances_final = pd.Series(rf_final_selector.feature_importances_, index=X_train_expanded.columns).sort_values(ascending=False)
top_rf_features = importances_final.head(60).index.tolist()

final_feature_list = list(set(top_corr_features + top_rf_features))
X_train_selected = X_train_expanded[final_feature_list]

print(f"‚úÖ {len(final_feature_list)} features finais selecionadas para {TARGET}.")

# --- 5. SALVAMENTO DE ARTEFATOS DE PR√â-PROCESSAMENTO ---
# Scaler
scaler = RobustScaler()
scaler.fit(X_train_selected)
joblib.dump(scaler, f'{ARTIFACTS_PATH}/scaler_{TARGET.lower()}.pkl')
print(f"üíæ Scaler para {TARGET} salvo.")

# Transformador Polinomial e sua lista de features
joblib.dump(poly, f'{ARTIFACTS_PATH}/poly_transformer_{TARGET.lower()}.pkl')
with open(f'{ARTIFACTS_PATH}/poly_features_list_{TARGET.lower()}.pkl', 'wb') as f:
    pickle.dump(top_features_for_poly, f)
print(f"üíæ Transformador polinomial e lista de features para {TARGET} salvos.")

# Lista final de Features
with open(f'{ARTIFACTS_PATH}/features_{TARGET.lower()}.pkl', 'wb') as f:
    pickle.dump(final_feature_list, f)
print(f"üíæ Lista final de features para {TARGET} salva.")


# --- 6. OTIMIZA√á√ÉO E TREINAMENTO DO MODELO STACKING ---
print(f"\n[FASE 3] Otimizando modelos base e treinando o Stacking para {TARGET}...")

def tune_model(model_name, X, y):
    def objective(trial):
        if model_name == 'catboost':
            params = {'iterations': trial.suggest_int('iterations', 100, 500), 'depth': trial.suggest_int('depth', 3, 7), 'learning_rate': trial.suggest_float('learning_rate', 0.01, 0.3, log=True), 'l2_leaf_reg': trial.suggest_float('l2_leaf_reg', 2, 20, log=True), 'verbose': 0}
            model = CatBoostRegressor(**params, random_state=RANDOM_STATE)
        # Adicione lgb e xgb se necess√°rio
        score = cross_val_score(model, X, y, cv=3, scoring='r2', n_jobs=-1).mean()
        return score
    
    study = optuna.create_study(direction='maximize')
    study.optimize(objective, n_trials=30)
    print(f"  - Melhor R¬≤ CV para {model_name}: {study.best_value:.4f}")
    return study.best_params

best_catboost_params = tune_model('catboost', scaler.transform(X_train_selected), y_train)

base_models = [
    ('catboost', CatBoostRegressor(**best_catboost_params, verbose=0, random_state=RANDOM_STATE)),
    ('random_forest', RandomForestRegressor(n_estimators=150, random_state=RANDOM_STATE))
]
meta_model = Ridge(random_state=RANDOM_STATE)
stacking_model = StackingRegressor(estimators=base_models, final_estimator=meta_model, cv=5, n_jobs=-1)

stacking_model.fit(scaler.transform(X_train_selected), y_train)
print(f"‚úÖ Modelo Stacking para {TARGET} treinado.")

# Salvamento do Modelo
joblib.dump(stacking_model, f'{ARTIFACTS_PATH}/modelo_{TARGET.lower()}.pkl')
print(f"üíæ Modelo para {TARGET} salvo em: {ARTIFACTS_PATH}/modelo_{TARGET.lower()}.pkl")
print("\n--- Conclu√≠do para Target 2 ---")
</file>

<file path="dashboard/backend/export_artifacts_target3.py">
# export_artifacts_target3.py

import pandas as pd
import numpy as np
import os
import pickle
import joblib
import optuna
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.preprocessing import RobustScaler, PolynomialFeatures
from sklearn.ensemble import RandomForestRegressor, StackingRegressor
from sklearn.linear_model import Ridge
from catboost import CatBoostRegressor
import lightgbm as lgb
import xgboost as xgb

print("="*80)
print("INICIANDO EXPORTA√á√ÉO DE ARTEFATOS PARA O TARGET 3")
print("="*80)

# --- 1. CONFIGURA√á√ïES ---
ARTIFACTS_PATH = "ml_artifacts"
if not os.path.exists(ARTIFACTS_PATH):
    os.makedirs(ARTIFACTS_PATH)
TARGET = 'Target3' # <- ALTERADO
RAW_DATA_FILE = 'JogadoresV1.xlsx'
RANDOM_STATE = 42

# --- 2. CARREGAMENTO E FEATURE ENGINEERING ---
print(f"\n[FASE 1] Carregando e processando dados de '{RAW_DATA_FILE}'...")
try:
    df = pd.read_excel(RAW_DATA_FILE)
except FileNotFoundError:
    print(f"‚ùå ERRO: Arquivo '{RAW_DATA_FILE}' n√£o encontrado.")
    exit()

df.dropna(subset=[TARGET], inplace=True)

# Limpeza e FE simples
if 'F0103' in df.columns:
    df['F0103'] = pd.to_numeric(df['F0103'].astype(str).str.replace(',', '.'), errors='coerce')
if 'QtdHorasDormi' in df.columns and 'Acordar' in df.columns:
    df['sono_total'] = df['QtdHorasDormi']
    df['sono_x_acordar'] = df['QtdHorasDormi'] * df['Acordar']

p_cols = [c for c in df.columns if c.startswith('P') and any(char.isdigit() for char in c)]
t_cols = [c for c in df.columns if c.startswith('T') and any(char.isdigit() for char in c)]
f_cols = [c for c in df.columns if c.startswith('F') and len(c) > 1 and any(char.isdigit() for char in c)]

for col in p_cols + t_cols + f_cols:
    df[col] = pd.to_numeric(df[col], errors='coerce')

if p_cols:
    df['P_mean'] = df[p_cols].mean(axis=1)
if t_cols:
    df['T_mean'] = df[t_cols].mean(axis=1)
if f_cols:
    df['F_mean'] = df[f_cols].mean(axis=1)

# Imputa√ß√£o final antes de separar
numeric_cols = df.select_dtypes(include=np.number).columns
for col in numeric_cols:
    df[col].fillna(df[col].median(), inplace=True)

print("‚úÖ Dados processados e features base criadas.")

# --- 3. PREPARA√á√ÉO E SEPARA√á√ÉO DE DADOS ---
features_to_exclude = ['Target1', 'Target2', 'Target3', 'C√≥digo de Acesso', 'Data/Hora √öltimo']
initial_features = [col for col in df.columns if col not in features_to_exclude and pd.api.types.is_numeric_dtype(df[col])]

X = df[initial_features]
y = df[TARGET]

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=RANDOM_STATE)

# --- 4. FEATURE ENGINEERING AVAN√áADA E SELE√á√ÉO ---
print("\n[FASE 2] Criando features polinomiais e selecionando as melhores...")
# Features Polinomiais
rf_poly_selector = RandomForestRegressor(n_estimators=100, random_state=RANDOM_STATE, n_jobs=-1)
rf_poly_selector.fit(X_train, y_train)
importances = pd.Series(rf_poly_selector.feature_importances_, index=X_train.columns).sort_values(ascending=False)
top_features_for_poly = importances.head(15).index.tolist()

poly = PolynomialFeatures(degree=2, include_bias=False, interaction_only=True)
X_train_poly = poly.fit_transform(X_train[top_features_for_poly])
poly_names = [f"poly_{name}" for name in poly.get_feature_names_out(top_features_for_poly)]
X_train_poly_df = pd.DataFrame(X_train_poly, columns=poly_names, index=X_train.index)
X_train_expanded = X_train.join(X_train_poly_df)

# Sele√ß√£o H√≠brida
correlations = X_train_expanded.corrwith(y_train).abs().sort_values(ascending=False)
top_corr_features = correlations.head(60).index.tolist()
rf_final_selector = RandomForestRegressor(n_estimators=100, random_state=RANDOM_STATE, n_jobs=-1)
rf_final_selector.fit(X_train_expanded, y_train)
importances_final = pd.Series(rf_final_selector.feature_importances_, index=X_train_expanded.columns).sort_values(ascending=False)
top_rf_features = importances_final.head(60).index.tolist()

final_feature_list = list(set(top_corr_features + top_rf_features))
X_train_selected = X_train_expanded[final_feature_list]

print(f"‚úÖ {len(final_feature_list)} features finais selecionadas para {TARGET}.")

# --- 5. SALVAMENTO DE ARTEFATOS DE PR√â-PROCESSAMENTO ---
# Scaler
scaler = RobustScaler()
scaler.fit(X_train_selected)
joblib.dump(scaler, f'{ARTIFACTS_PATH}/scaler_{TARGET.lower()}.pkl') # <- NOME ALTERADO
print(f"üíæ Scaler para {TARGET} salvo.")

# Transformador Polinomial e sua lista de features
joblib.dump(poly, f'{ARTIFACTS_PATH}/poly_transformer_{TARGET.lower()}.pkl') # <- NOME ALTERADO
with open(f'{ARTIFACTS_PATH}/poly_features_list_{TARGET.lower()}.pkl', 'wb') as f: # <- NOME ALTERADO
    pickle.dump(top_features_for_poly, f)
print(f"üíæ Transformador polinomial e lista de features para {TARGET} salvos.")

# Lista final de Features
with open(f'{ARTIFACTS_PATH}/features_{TARGET.lower()}.pkl', 'wb') as f: # <- NOME ALTERADO
    pickle.dump(final_feature_list, f)
print(f"üíæ Lista final de features para {TARGET} salva.")


# --- 6. OTIMIZA√á√ÉO E TREINAMENTO DO MODELO STACKING ---
print(f"\n[FASE 3] Otimizando modelos base e treinando o Stacking para {TARGET}...")

def tune_model(model_name, X, y):
    def objective(trial):
        if model_name == 'catboost':
            params = {'iterations': trial.suggest_int('iterations', 100, 500), 'depth': trial.suggest_int('depth', 3, 7), 'learning_rate': trial.suggest_float('learning_rate', 0.01, 0.3, log=True), 'l2_leaf_reg': trial.suggest_float('l2_leaf_reg', 2, 20, log=True), 'verbose': 0}
            model = CatBoostRegressor(**params, random_state=RANDOM_STATE)
        score = cross_val_score(model, X, y, cv=3, scoring='r2', n_jobs=-1).mean()
        return score
    
    study = optuna.create_study(direction='maximize')
    study.optimize(objective, n_trials=30)
    print(f"  - Melhor R¬≤ CV para {model_name}: {study.best_value:.4f}")
    return study.best_params

best_catboost_params = tune_model('catboost', scaler.transform(X_train_selected), y_train)

base_models = [
    ('catboost', CatBoostRegressor(**best_catboost_params, verbose=0, random_state=RANDOM_STATE)),
    ('random_forest', RandomForestRegressor(n_estimators=150, random_state=RANDOM_STATE))
]
meta_model = Ridge(random_state=RANDOM_STATE)
stacking_model = StackingRegressor(estimators=base_models, final_estimator=meta_model, cv=5, n_jobs=-1)

stacking_model.fit(scaler.transform(X_train_selected), y_train)
print(f"‚úÖ Modelo Stacking para {TARGET} treinado.")

# Salvamento do Modelo
joblib.dump(stacking_model, f'{ARTIFACTS_PATH}/modelo_{TARGET.lower()}.pkl') # <- NOME ALTERADO
print(f"üíæ Modelo para {TARGET} salvo em: {ARTIFACTS_PATH}/modelo_{TARGET.lower()}.pkl")
print("\n--- Conclu√≠do para Target 3 ---")
</file>

<file path="dashboard/backend/export_hibrido_target1.py">
# =============================================================================
# EXPORT H√çBRIDO - TARGET 1 (R1)
# =============================================================================
# Este script replica a SE√á√ÉO 2 do notebook h√≠brido definitivo
# Treina o modelo R1 e salva os artefatos necess√°rios para a API

import pandas as pd
import numpy as np
import warnings
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.preprocessing import RobustScaler
from sklearn.feature_selection import VarianceThreshold
from catboost import CatBoostRegressor
import optuna
import joblib
import pickle
import os

warnings.filterwarnings('ignore')
optuna.logging.set_verbosity(optuna.logging.WARNING)

# Configura√ß√£o de caminhos
ARTIFACTS_PATH = 'ml_artifacts'
os.makedirs(ARTIFACTS_PATH, exist_ok=True)

print("=" * 100)
print("üéØ TREINAMENTO TARGET 1 (R1) - MODELO H√çBRIDO".center(100))
print("=" * 100)

# =============================================================================
# CARREGAMENTO E PR√â-PROCESSAMENTO
# =============================================================================

df_raw = pd.read_excel('JogadoresV3.xlsx')
df = df_raw.copy()

print(f"\n‚úÖ Dados carregados: {len(df)} linhas")

# Converter F0103
if 'F0103' in df.columns:
    df['F0103'] = pd.to_numeric(df['F0103'].astype(str).str.replace(',', '.'), errors='coerce')

# Identificar colunas P, T, F
p_cols = [col for col in df.columns if col.startswith('P') and any(c.isdigit() for c in col)]
t_cols = [col for col in df.columns if col.startswith('T') and any(c.isdigit() for c in col)]
f_cols = [col for col in df.columns if col.startswith('F') and len(col) > 1 and any(c.isdigit() for c in col)]

# Tratar colunas duplicadas
print("\n[1/6] Tratando colunas duplicadas...")
cols = pd.Series(df.columns)
duplicated_cols = cols[cols.duplicated()].unique()

if len(duplicated_cols) > 0:
    for dup in duplicated_cols:
        indices = cols[cols == dup].index.tolist()
        for i, idx in enumerate(indices):
            cols.iloc[idx] = f'{dup}_{i}'
    df.columns = cols
    # Atualizar listas de colunas
    p_cols = [col for col in df.columns if col.startswith('P') and any(c.isdigit() for c in col)]
    t_cols = [col for col in df.columns if col.startswith('T') and any(c.isdigit() for c in col)]
    f_cols = [col for col in df.columns if col.startswith('F') and len(col) > 1 and any(c.isdigit() for c in col)]
    print(f"  ‚úÖ Colunas duplicadas renomeadas")
else:
    print("  ‚úÖ Sem duplicatas")

# Converter para num√©rico
for col in p_cols + t_cols + f_cols:
    if col in df.columns:
        df[col] = pd.to_numeric(df[col], errors='coerce')

# Remover outliers extremos
numeric_cols = [col for col in df.select_dtypes(include=[np.number]).columns if 'Target' not in col]
for col in numeric_cols:
    if col in df.columns:
        df.loc[df[col] < -100, col] = np.nan
        if df[col].max() > 10000:
            df.loc[df[col] > 10000, col] = np.nan

# =============================================================================
# FEATURE ENGINEERING
# =============================================================================

print("\n[2/6] Criando features comportamentais...")

# Taxa de pulos (-1)
p_minus_ones = sum((df[col] == -1).sum() for col in p_cols if col in df.columns)
t_minus_ones = sum((df[col] == -1).sum() for col in t_cols if col in df.columns)

df['taxa_pulos_P'] = p_minus_ones / len(p_cols) if len(p_cols) > 0 else 0
df['taxa_pulos_T'] = t_minus_ones / len(t_cols) if len(t_cols) > 0 else 0
df['taxa_pulos_geral'] = (p_minus_ones + t_minus_ones) / (len(p_cols) + len(t_cols))

# Substituir -1 por NaN e preencher com mediana
for col in p_cols + t_cols + f_cols:
    if col in df.columns:
        df[col] = df[col].replace(-1, np.nan)
        df[col] = df[col].replace(-1.0, np.nan)
        if df[col].isnull().sum() > 0:
            df[col].fillna(df[col].median(), inplace=True)

print("\n[3/6] Feature engineering avan√ßado...")

# Features de SONO
if 'QtdHorasDormi' in df.columns and 'Acordar' in df.columns:
    df['sono_total'] = df['QtdHorasDormi']
    df['sono_x_acordar'] = df['QtdHorasDormi'] * df['Acordar']
    df['sono_squared'] = df['QtdHorasDormi'] ** 2
    df['sono_irregular'] = np.abs(df['QtdHorasDormi'] - df['QtdHorasDormi'].median())
    print(f"  ‚úÖ Sono: 4 features")

# Features de PERFORMANCE
if len(p_cols) > 0:
    df['P_mean'] = df[p_cols].mean(axis=1)
    df['P_std'] = df[p_cols].std(axis=1)
    df['P_min'] = df[p_cols].min(axis=1)
    df['P_max'] = df[p_cols].max(axis=1)
    df['P_range'] = df['P_max'] - df['P_min']
    df['P_late'] = df[['P09', 'P12', 'P13', 'P15']].mean(axis=1) if all(c in df.columns for c in ['P09', 'P12', 'P13', 'P15']) else 0
    df['P_early'] = df[['P01', 'P02', 'P03', 'P04']].mean(axis=1) if all(c in df.columns for c in ['P01', 'P02', 'P03', 'P04']) else 0
    print(f"  ‚úÖ Performance: 7 features")

# Features de TEMPO
if len(t_cols) > 0:
    df['T_mean'] = df[t_cols].mean(axis=1)
    df['T_std'] = df[t_cols].std(axis=1)
    df['T_min'] = df[t_cols].min(axis=1)
    df['T_max'] = df[t_cols].max(axis=1)
    print(f"  ‚úÖ Tempo: 4 features")

# Features de FORMUL√ÅRIOS
f_perfil = [c for c in f_cols if c.startswith('F01') or c.startswith('F02')]
if len(f_perfil) > 0:
    df['F_perfil_mean'] = df[f_perfil].mean(axis=1)
    df['F_perfil_std'] = df[f_perfil].std(axis=1)

f_sono = [c for c in f_cols if c.startswith('F07')]
if len(f_sono) > 0:
    df['F_sono_mean'] = df[f_sono].mean(axis=1)
    df['F_sono_std'] = df[f_sono].std(axis=1)

f_final = [c for c in f_cols if c.startswith('F11')]
if len(f_final) > 0:
    df['F_final_mean'] = df[f_final].mean(axis=1)
    df['F_final_std'] = df[f_final].std(axis=1)

df['F_mean_geral'] = df[f_cols].mean(axis=1)

# =============================================================================
# SELE√á√ÉO DE FEATURES
# =============================================================================

print("\n[4/6] Selecionando TOP features...")

TARGET = 'Target1'
feature_cols = [col for col in df.columns if col not in [TARGET, 'C√≥digo de Acesso', 'Data/Hora √öltimo', 'Target2', 'Target3']
                and pd.api.types.is_numeric_dtype(df[col])]

X = df[feature_cols].fillna(0)
y = df[TARGET]

# Variance Threshold
selector = VarianceThreshold(threshold=0.01)
selector.fit(X)
feature_cols = X.columns[selector.get_support()].tolist()
X = df[feature_cols]

# Correla√ß√£o com target
correlations = []
for col in feature_cols:
    corr = abs(df[col].corr(df[TARGET]))
    if not np.isnan(corr):
        correlations.append((col, corr))

correlations.sort(key=lambda x: x[1], reverse=True)

# TOP 30 features
TOP_K = min(30, len(correlations))
selected_features_r1 = [col for col, _ in correlations[:TOP_K]]

print(f"  ‚úÖ {TOP_K} features selecionadas")

# Criar intera√ß√µes entre TOP 3
top3_features = [col for col, _ in correlations[:3]]
interaction_features = []

for i, f1 in enumerate(top3_features):
    for f2 in top3_features[i+1:]:
        interaction_name = f'{f1}_X_{f2}'
        df[interaction_name] = df[f1] * df[f2]
        interaction_features.append(interaction_name)

selected_features_r1.extend(interaction_features)
selected_features_r1 = list(dict.fromkeys(selected_features_r1))

print(f"  Total com intera√ß√µes: {len(selected_features_r1)}")

# =============================================================================
# PREPARA√á√ÉO DOS DADOS
# =============================================================================

print("\n[5/6] Preparando dados para treinamento...")

# Scaler
scaler_r1 = RobustScaler()
X_final = df[selected_features_r1].copy().fillna(0)
X_scaled = scaler_r1.fit_transform(X_final)

X_r1 = X_scaled
y_r1 = df[TARGET].values

# Remover NaNs
valid_idx = ~np.isnan(y_r1)
X_r1 = X_r1[valid_idx]
y_r1 = y_r1[valid_idx]

# Split
X_train_r1, X_test_r1, y_train_r1, y_test_r1 = train_test_split(X_r1, y_r1, test_size=0.25, random_state=42)

print(f"  Treino: {len(X_train_r1)} | Teste: {len(X_test_r1)}")

# =============================================================================
# OTIMIZA√á√ÉO E TREINAMENTO
# =============================================================================

print("\n[6/6] Otimizando hiperpar√¢metros (100 trials)...")

def objective_r1(trial):
    params = {
        'iterations': 500,
        'learning_rate': trial.suggest_float('learning_rate', 0.01, 0.1, log=True),
        'depth': trial.suggest_int('depth', 3, 6),
        'l2_leaf_reg': trial.suggest_float('l2_leaf_reg', 10, 100, log=True),
        'border_count': trial.suggest_int('border_count', 32, 128),
        'bagging_temperature': trial.suggest_float('bagging_temperature', 0.5, 1.0),
        'random_strength': trial.suggest_float('random_strength', 0.5, 2.0),
        'verbose': False,
        'random_seed': 42
    }
    model = CatBoostRegressor(**params)
    scores = cross_val_score(model, X_train_r1, y_train_r1, cv=5, scoring='r2')
    return scores.mean()

study_r1 = optuna.create_study(direction='maximize')
study_r1.optimize(objective_r1, n_trials=100, show_progress_bar=True)

best_params_r1 = study_r1.best_params
best_params_r1['iterations'] = 500
best_params_r1['verbose'] = False
best_params_r1['random_seed'] = 42

print(f"\n‚úÖ Melhor R¬≤ CV: {study_r1.best_value:.4f}")

# Treinar modelo final
print("\nüîß Treinando modelo final...")
model_r1 = CatBoostRegressor(**best_params_r1)
model_r1.fit(X_train_r1, y_train_r1, verbose=False)

# =============================================================================
# SALVAR ARTEFATOS
# =============================================================================

print("\nüíæ Salvando artefatos...")

# Salvar modelo
joblib.dump(model_r1, f'{ARTIFACTS_PATH}/modelo_target1.pkl')
print(f"  ‚úÖ Modelo salvo: {ARTIFACTS_PATH}/modelo_target1.pkl")

# Salvar scaler
joblib.dump(scaler_r1, f'{ARTIFACTS_PATH}/scaler_target1.pkl')
print(f"  ‚úÖ Scaler salvo: {ARTIFACTS_PATH}/scaler_target1.pkl")

# Salvar lista de features
with open(f'{ARTIFACTS_PATH}/features_target1.pkl', 'wb') as f:
    pickle.dump(selected_features_r1, f)
print(f"  ‚úÖ Features salvas: {ARTIFACTS_PATH}/features_target1.pkl")

print("\n" + "=" * 100)
print("‚úÖ TARGET 1 (R1) - TREINAMENTO COMPLETO!".center(100))
print("=" * 100)
print(f"\nüì¶ Artefatos salvos em: {ARTIFACTS_PATH}/")
print(f"  ‚Ä¢ modelo_target1.pkl")
print(f"  ‚Ä¢ scaler_target1.pkl")
print(f"  ‚Ä¢ features_target1.pkl")
</file>

<file path="dashboard/backend/export_hibrido_target2.py">
# =============================================================================
# EXPORT H√çBRIDO - TARGET 2 (R2)
# =============================================================================
# Este script replica a SE√á√ÉO 3 do notebook h√≠brido definitivo (CORRIGIDO!)
# Treina o ENSEMBLE de 3 modelos R2 e salva os artefatos necess√°rios para a API

import pandas as pd
import numpy as np
import warnings
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.preprocessing import QuantileTransformer
from sklearn.feature_selection import VarianceThreshold
from catboost import CatBoostRegressor
import optuna
import joblib
import pickle
import os

warnings.filterwarnings('ignore')
optuna.logging.set_verbosity(optuna.logging.WARNING)

# Configura√ß√£o de caminhos
ARTIFACTS_PATH = 'ml_artifacts'
os.makedirs(ARTIFACTS_PATH, exist_ok=True)

print("=" * 100)
print("üéØ TREINAMENTO TARGET 2 (R2) - ENSEMBLE H√çBRIDO CORRIGIDO".center(100))
print("=" * 100)

# =============================================================================
# CARREGAMENTO E PR√â-PROCESSAMENTO
# =============================================================================

df_raw = pd.read_excel('JogadoresV3.xlsx')
df = df_raw.copy()

TARGET = 'Target2'

print(f"\n‚úÖ Dados carregados: {len(df)} linhas")

# Converter F0103
if 'F0103' in df.columns:
    df['F0103'] = pd.to_numeric(df['F0103'].astype(str).str.replace(',', '.'), errors='coerce')

# Identificar colunas P, T, F
p_cols = [col for col in df.columns if col.startswith('P') and any(c.isdigit() for c in col)]
t_cols = [col for col in df.columns if col.startswith('T') and any(c.isdigit() for c in col)]
f_cols = [col for col in df.columns if col.startswith('F') and len(col) > 1 and any(c.isdigit() for c in col)]

print("\n[1/5] Tratando valores -1 e NaN...")

# Converter para num√©rico e tratar -1
for col in p_cols + t_cols + f_cols:
    if col in df.columns:
        df[col] = pd.to_numeric(df[col], errors='coerce')
        df[col] = df[col].replace(-1, np.nan)
        if df[col].isnull().sum() > 0:
            df[col].fillna(df[col].median(), inplace=True)

# =============================================================================
# FEATURE ENGINEERING MINIMALISTA
# =============================================================================

print("\n[2/5] Criando features minimalistas para R2...")

# Features de sono
if 'QtdHorasDormi' in df.columns and 'Acordar' in df.columns:
    df['sono_total'] = df['QtdHorasDormi']
    df['acordar'] = df['Acordar']

# Features de formul√°rio sono
f_sono = [c for c in f_cols if c.startswith('F07')]
if len(f_sono) > 0:
    df['F_sono_mean'] = df[f_sono].mean(axis=1)

# Features de formul√°rio final
f_final = [c for c in f_cols if c.startswith('F11')]
if len(f_final) > 0:
    df['F_final_mean'] = df[f_final].mean(axis=1)

# Features de performance
p_cols_exist = [c for c in p_cols if c in df.columns]
if len(p_cols_exist) > 0:
    df['P_mean'] = df[p_cols_exist].mean(axis=1)

# Preencher NaN remanescentes
numeric_cols = df.select_dtypes(include=np.number).columns
for col in numeric_cols:
    if df[col].isnull().sum() > 0:
        df[col].fillna(df[col].median(), inplace=True)

# =============================================================================
# SELE√á√ÉO DE FEATURES CONSERVADORA
# =============================================================================

print("\n[3/5] Sele√ß√£o conservadora (‚â§12 features)...")

feature_cols = [col for col in df.columns if col not in [TARGET, 'C√≥digo de Acesso', 'Data/Hora √öltimo', 'Target1', 'Target3']
                and pd.api.types.is_numeric_dtype(df[col])]

X_pre = df[feature_cols].fillna(0)
y = df[TARGET]

# Variance Threshold
selector = VarianceThreshold(threshold=0.01)
selector.fit(X_pre)
feature_cols_filtered = X_pre.columns[selector.get_support()].tolist()

# Correla√ß√£o com target
correlations = []
for col in feature_cols_filtered:
    corr = df[col].corr(df[TARGET])
    if not np.isnan(corr):
        correlations.append((col, abs(corr)))

correlations.sort(key=lambda x: x[1], reverse=True)

# TOP 12 features
MAX_FEATURES = 12
selected_features_r2 = [col for col, _ in correlations[:MAX_FEATURES]]

print(f"  ‚úÖ {len(selected_features_r2)} features selecionadas")

# Criar uma intera√ß√£o entre TOP 2
if len(selected_features_r2) >= 2:
    f1, f2 = selected_features_r2[0], selected_features_r2[1]
    df[f'{f1}_X_{f2}'] = df[f1] * df[f2]
    selected_features_r2.append(f'{f1}_X_{f2}')

# =============================================================================
# PREPARA√á√ÉO DOS DADOS
# =============================================================================

print("\n[4/5] Preparando dados...")

X_r2 = df[selected_features_r2].copy()
y_r2 = df[TARGET].values

# Remover NaNs
valid_idx = ~np.isnan(y_r2)
X_r2 = X_r2[valid_idx]
y_r2 = y_r2[valid_idx]

print(f"  Dados: {len(X_r2)} amostras √ó {len(selected_features_r2)} features")

# =============================================================================
# OTIMIZA√á√ÉO
# =============================================================================

print("\n[5/5] Otimiza√ß√£o brutal (150 trials)...")

def objective_r2(trial):
    params = {
        'iterations': trial.suggest_int('iterations', 300, 700),
        'learning_rate': trial.suggest_float('learning_rate', 0.001, 0.03, log=True),
        'depth': trial.suggest_int('depth', 2, 3),
        'l2_leaf_reg': trial.suggest_float('l2_leaf_reg', 50, 300, log=True),
        'border_count': trial.suggest_int('border_count', 16, 48),
        'bagging_temperature': trial.suggest_float('bagging_temperature', 0.0, 0.5),
        'random_strength': trial.suggest_float('random_strength', 2.0, 5.0),
        'min_data_in_leaf': trial.suggest_int('min_data_in_leaf', 5, 15),
        'verbose': False,
        'random_seed': 42
    }

    X_tr_opt, X_te_opt, y_tr_opt, y_te_opt = train_test_split(X_r2, y_r2, test_size=0.25, random_state=42)
    scaler_temp = QuantileTransformer(output_distribution='normal', random_state=42)
    X_tr_scaled = scaler_temp.fit_transform(X_tr_opt)

    model = CatBoostRegressor(**params)
    scores = cross_val_score(model, X_tr_scaled, y_tr_opt, cv=5, scoring='r2')
    return scores.mean()

study_r2 = optuna.create_study(direction='maximize')
study_r2.optimize(objective_r2, n_trials=150, show_progress_bar=True)

best_params_r2 = study_r2.best_params
best_params_r2['verbose'] = False
best_params_r2['random_seed'] = 42

print(f"\n‚úÖ Melhor R¬≤ CV: {study_r2.best_value:.4f}")

# =============================================================================
# TREINAMENTO DO ENSEMBLE (3 MODELOS) - VERS√ÉO CORRIGIDA
# =============================================================================

print("\nüöÄ Treinando ensemble (3 modelos)...")
print("  ‚úÖ Cada modelo treina com seed diferente (diversidade)")

# SPLIT BASE COMUM (para consist√™ncia do scaler)
X_train_base, X_test_base, y_train_base, y_test_base = train_test_split(
    X_r2, y_r2, test_size=0.25, random_state=42
)

# SCALER BASE COMUM
scaler_base = QuantileTransformer(output_distribution='normal', random_state=42)
X_train_base_scaled = scaler_base.fit_transform(X_train_base)
X_test_base_scaled = scaler_base.transform(X_test_base)

models_r2 = []

for i, seed in enumerate([42, 123, 456], 1):
    print(f"\n  Treinando Modelo {i} (seed={seed})...")
    
    # Cada modelo treina com seed diferente para diversidade
    X_tr_div, X_te_div, y_tr_div, y_te_div = train_test_split(X_r2, y_r2, test_size=0.25, random_state=seed)
    scaler_div = QuantileTransformer(output_distribution='normal', random_state=42)
    X_tr_div_scaled = scaler_div.fit_transform(X_tr_div)
    
    # Treinar modelo
    params_i = best_params_r2.copy()
    params_i['random_seed'] = seed
    model_i = CatBoostRegressor(**params_i)
    model_i.fit(X_tr_div_scaled, y_tr_div, verbose=False)
    
    models_r2.append(model_i)
    print(f"  ‚úÖ Modelo {i} treinado!")

# =============================================================================
# SALVAR ARTEFATOS
# =============================================================================

print("\nüíæ Salvando artefatos...")

# Salvar os 3 modelos do ensemble
for i, model in enumerate(models_r2):
    joblib.dump(model, f'{ARTIFACTS_PATH}/modelo_target2_ensemble_{i}.pkl')
    print(f"  ‚úÖ Modelo {i+1} salvo: {ARTIFACTS_PATH}/modelo_target2_ensemble_{i}.pkl")

# Salvar o scaler (QuantileTransformer)
joblib.dump(scaler_base, f'{ARTIFACTS_PATH}/scaler_target2.pkl')
print(f"  ‚úÖ Scaler salvo: {ARTIFACTS_PATH}/scaler_target2.pkl")

# Salvar a lista de features
with open(f'{ARTIFACTS_PATH}/features_target2.pkl', 'wb') as f:
    pickle.dump(selected_features_r2, f)
print(f"  ‚úÖ Features salvas: {ARTIFACTS_PATH}/features_target2.pkl")

print("\n" + "=" * 100)
print("‚úÖ TARGET 2 (R2) - ENSEMBLE COMPLETO!".center(100))
print("=" * 100)
print(f"\nüì¶ Artefatos salvos em: {ARTIFACTS_PATH}/")
print(f"  ‚Ä¢ modelo_target2_ensemble_0.pkl")
print(f"  ‚Ä¢ modelo_target2_ensemble_1.pkl")
print(f"  ‚Ä¢ modelo_target2_ensemble_2.pkl")
print(f"  ‚Ä¢ scaler_target2.pkl (QuantileTransformer)")
print(f"  ‚Ä¢ features_target2.pkl")
print(f"\nüí° NOTA: A API far√° a m√©dia das predi√ß√µes dos 3 modelos")
</file>

<file path="dashboard/backend/export_hibrido_target3.py">
# =============================================================================
# EXPORT H√çBRIDO - TARGET 3 (R3)
# =============================================================================
# Este script replica a SE√á√ÉO 4 do notebook h√≠brido definitivo (CORRIGIDO!)
# Treina o ENSEMBLE de 3 modelos R3 e salva os artefatos necess√°rios para a API

import pandas as pd
import numpy as np
import warnings
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.preprocessing import RobustScaler
from catboost import CatBoostRegressor
import optuna
import joblib
import pickle
import os

warnings.filterwarnings('ignore')
optuna.logging.set_verbosity(optuna.logging.WARNING)

# Configura√ß√£o de caminhos
ARTIFACTS_PATH = 'ml_artifacts'
os.makedirs(ARTIFACTS_PATH, exist_ok=True)

print("=" * 100)
print("üéØ TREINAMENTO TARGET 3 (R3) - ENSEMBLE H√çBRIDO CORRIGIDO".center(100))
print("=" * 100)

# =============================================================================
# CARREGAMENTO E PR√â-PROCESSAMENTO
# =============================================================================

df_raw = pd.read_excel('JogadoresV3.xlsx')
df = df_raw.copy()

TARGET = 'Target3'

print(f"\n‚úÖ Dados carregados: {len(df)} linhas")

# Converter F0103
if 'F0103' in df.columns:
    df['F0103'] = pd.to_numeric(df['F0103'].astype(str).str.replace(',', '.'), errors='coerce')

# Identificar colunas P, T, F
p_cols = [col for col in df.columns if col.startswith('P') and any(c.isdigit() for c in col)]
t_cols = [col for col in df.columns if col.startswith('T') and any(c.isdigit() for c in col)]
f_cols = [col for col in df.columns if col.startswith('F') and len(col) > 1 and any(c.isdigit() for c in col)]

print("\n[1/5] Tratando valores -1 e NaN...")

# Converter para num√©rico e tratar -1
for col in p_cols + t_cols + f_cols:
    if col in df.columns:
        df[col] = pd.to_numeric(df[col], errors='coerce')
        df[col] = df[col].replace(-1, np.nan)
        if df[col].isnull().sum() > 0:
            df[col].fillna(df[col].median(), inplace=True)

# =============================================================================
# FEATURE ENGINEERING
# =============================================================================

print("\n[2/5] Feature engineering para R3...")

# Features de Performance
df['P_mean'] = df[p_cols].mean(axis=1)
df['P_std'] = df[p_cols].std(axis=1)
df['P_late'] = df[['P09', 'P12', 'P13', 'P15']].mean(axis=1) if all(c in df.columns for c in ['P09', 'P12', 'P13', 'P15']) else 0
df['P_early'] = df[['P01', 'P02', 'P03', 'P04']].mean(axis=1) if all(c in df.columns for c in ['P01', 'P02', 'P03', 'P04']) else 0

# Features de Tempo
df['T_mean'] = df[t_cols].mean(axis=1)
df['T_std'] = df[t_cols].std(axis=1)

# Features de Sono
if 'QtdHorasSono' in df.columns:
    f_sono = [c for c in f_cols if '07' in c]
    df['F_sono_mean'] = df[f_sono].mean(axis=1)
    df['F_sono_std'] = df[f_sono].std(axis=1)
    df['F_sono_max'] = df[f_sono].max(axis=1)
    if 'Acordar' in df.columns:
        df['sono_x_acordar'] = df['QtdHorasSono'] * df['Acordar']
        df['acordar_squared'] = df['Acordar'] ** 2

# Features de Formul√°rio Final
f_final = [c for c in f_cols if '11' in c]
df['F_final_mean'] = df[f_final].mean(axis=1)

print("  ‚úÖ Features criadas!")

# =============================================================================
# SELE√á√ÉO DE FEATURES
# =============================================================================

print("\n[3/5] Sele√ß√£o TOP 15 features...")

# Pool de features com correla√ß√£o > 0.35
feature_pool = []
for col in df.columns:
    if col not in [TARGET, 'C√≥digo de Acesso', 'Target1', 'Target2'] and df[col].dtype in ['float64', 'int64']:
        corr = abs(df[col].corr(df[TARGET]))
        if not np.isnan(corr) and corr > 0.35:
            feature_pool.append((col, corr))

feature_pool.sort(key=lambda x: x[1], reverse=True)
selected_features_r3 = [f[0] for f in feature_pool[:15]]

print(f"  ‚úÖ {len(selected_features_r3)} features selecionadas")

# Criar intera√ß√£o
if 'F1103' in selected_features_r3 and 'P_mean' in selected_features_r3:
    df['F1103_X_P_mean'] = df['F1103'] * df['P_mean']
    selected_features_r3.append('F1103_X_P_mean')

# =============================================================================
# PREPARA√á√ÉO DOS DADOS
# =============================================================================

print("\n[4/5] Preparando dados...")

X_r3 = df[selected_features_r3].fillna(df[selected_features_r3].median())
y_r3 = df[TARGET].values

print(f"  Dados: {len(X_r3)} amostras √ó {len(selected_features_r3)} features")

# =============================================================================
# OTIMIZA√á√ÉO
# =============================================================================

print("\n[5/5] Otimiza√ß√£o (100 trials)...")

def objective_r3(trial):
    X_tr_opt, X_te_opt, y_tr_opt, y_te_opt = train_test_split(X_r3, y_r3, test_size=0.25, random_state=42)
    scaler_temp = RobustScaler()
    X_tr_scaled = scaler_temp.fit_transform(X_tr_opt)

    params = {
        'iterations': trial.suggest_int('iterations', 200, 800),
        'learning_rate': trial.suggest_float('learning_rate', 0.005, 0.05, log=True),
        'depth': 2,
        'l2_leaf_reg': trial.suggest_float('l2_leaf_reg', 120, 180),
        'border_count': trial.suggest_int('border_count', 16, 128),
        'bagging_temperature': trial.suggest_float('bagging_temperature', 0, 1),
        'random_strength': trial.suggest_float('random_strength', 0.5, 5),
        'min_data_in_leaf': trial.suggest_int('min_data_in_leaf', 8, 15),
        'random_seed': 42,
        'verbose': False
    }
    model = CatBoostRegressor(**params)
    scores = cross_val_score(model, X_tr_scaled, y_tr_opt, cv=3, scoring='r2')
    return scores.mean()

study_r3 = optuna.create_study(direction='maximize')
study_r3.optimize(objective_r3, n_trials=100, show_progress_bar=True)

best_params_r3 = study_r3.best_params
best_params_r3['depth'] = 2
best_params_r3['verbose'] = False
best_params_r3['random_seed'] = 42

print(f"\n‚úÖ Melhor R¬≤ CV: {study_r3.best_value:.4f}")

# =============================================================================
# TREINAMENTO DO ENSEMBLE (3 MODELOS) - VERS√ÉO CORRIGIDA
# =============================================================================

print("\nüöÄ Treinando ensemble (3 modelos)...")
print("  ‚úÖ Cada modelo treina com seed diferente (diversidade)")

# SPLIT BASE COMUM (para consist√™ncia do scaler)
X_train_base_r3, X_test_base_r3, y_train_base_r3, y_test_base_r3 = train_test_split(
    X_r3, y_r3, test_size=0.25, random_state=42
)

# SCALER BASE COMUM
scaler_base_r3 = RobustScaler()
X_train_base_r3_scaled = scaler_base_r3.fit_transform(X_train_base_r3)
X_test_base_r3_scaled = scaler_base_r3.transform(X_test_base_r3)

models_r3 = []

for i, seed in enumerate([42, 123, 456], 1):
    print(f"\n  Treinando Modelo {i} (seed={seed})...")
    
    # Cada modelo treina com seed diferente para diversidade
    X_tr_div, X_te_div, y_tr_div, y_te_div = train_test_split(X_r3, y_r3, test_size=0.25, random_state=seed)
    scaler_div = RobustScaler()
    X_tr_div_scaled = scaler_div.fit_transform(X_tr_div)
    
    # Treinar modelo
    params_i = best_params_r3.copy()
    params_i['random_seed'] = seed
    model_i = CatBoostRegressor(**params_i)
    model_i.fit(X_tr_div_scaled, y_tr_div, verbose=False)
    
    models_r3.append(model_i)
    print(f"  ‚úÖ Modelo {i} treinado!")

# =============================================================================
# SALVAR ARTEFATOS
# =============================================================================

print("\nüíæ Salvando artefatos...")

# Salvar os 3 modelos do ensemble
for i, model in enumerate(models_r3):
    joblib.dump(model, f'{ARTIFACTS_PATH}/modelo_target3_ensemble_{i}.pkl')
    print(f"  ‚úÖ Modelo {i+1} salvo: {ARTIFACTS_PATH}/modelo_target3_ensemble_{i}.pkl")

# Salvar o scaler (RobustScaler)
joblib.dump(scaler_base_r3, f'{ARTIFACTS_PATH}/scaler_target3.pkl')
print(f"  ‚úÖ Scaler salvo: {ARTIFACTS_PATH}/scaler_target3.pkl")

# Salvar a lista de features
with open(f'{ARTIFACTS_PATH}/features_target3.pkl', 'wb') as f:
    pickle.dump(selected_features_r3, f)
print(f"  ‚úÖ Features salvas: {ARTIFACTS_PATH}/features_target3.pkl")

print("\n" + "=" * 100)
print("‚úÖ TARGET 3 (R3) - ENSEMBLE COMPLETO!".center(100))
print("=" * 100)
print(f"\nüì¶ Artefatos salvos em: {ARTIFACTS_PATH}/")
print(f"  ‚Ä¢ modelo_target3_ensemble_0.pkl")
print(f"  ‚Ä¢ modelo_target3_ensemble_1.pkl")
print(f"  ‚Ä¢ modelo_target3_ensemble_2.pkl")
print(f"  ‚Ä¢ scaler_target3.pkl (RobustScaler)")
print(f"  ‚Ä¢ features_target3.pkl")
print(f"\nüí° NOTA: A API far√° a m√©dia das predi√ß√µes dos 3 modelos")
</file>

<file path="dashboard/backend/models.py">
# models.py
from sqlalchemy import Column, Integer, String, Float, DateTime, ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from database import Base

class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, unique=True, index=True, nullable=False)
    password_hash = Column(String, nullable=False)
    predictions = relationship('Prediction', backref='user', lazy=True)

class Prediction(Base):
    __tablename__ = 'predictions'
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey('users.id'), nullable=False)
    upload_timestamp = Column(DateTime, nullable=False, default=func.now())
    jogador_id = Column(String, nullable=False)
    pred_t1 = Column(Float, nullable=False)
    pred_t2 = Column(Float, nullable=False)
    pred_t3 = Column(Float, nullable=False)
</file>

<file path="dashboard/backend/README.md">
# Backend API (FastAPI)

Esta API serve como o c√©rebro do projeto, lidando com autentica√ß√£o, processamento de dados e previs√µes de Machine Learning.

## Principais Funcionalidades

-   **Autentica√ß√£o JWT:** Sistema de registro (`/register`) e login (`/login`) que gera tokens JWT para proteger os endpoints.
-   **Endpoint de Previs√£o (`/predict`):** Recebe um arquivo `.xlsx` com novos dados de jogadores, aplica o mesmo pipeline de pr√©-processamento dos modelos treinados e retorna as previs√µes para os 3 targets.
-   **An√°lise SHAP:** Junto com as previs√µes, a API calcula os valores SHAP para cada jogador, permitindo entender a contribui√ß√£o de cada feature para o resultado.
-   **Hist√≥rico de Previs√µes (`/history`):** Salva cada lote de previs√µes no banco de dados, associado ao usu√°rio que fez o upload.
-   **An√°lise do Modelo (`/feature_importance`):** Exp√µe a import√¢ncia geral das features para cada modelo.

## Principais Endpoints

-   `POST /register`: Cria um novo usu√°rio.
-   `POST /login`: Autentica um usu√°rio e retorna um token de acesso.
-   `POST /predict`: (Protegido) Recebe um arquivo Excel e retorna as previs√µes e dados SHAP.
-   `GET /history`: (Protegido) Retorna o hist√≥rico de uploads do usu√°rio logado.
-   `GET /feature_importance`: (Protegido) Retorna a import√¢ncia das features para cada modelo.
-   `GET /health`: Verifica a sa√∫de da aplica√ß√£o, incluindo o carregamento dos modelos de ML.
</file>

<file path="dashboard/backend/repomix-output.xml">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
auth.py
catboost_info/catboost_training.json
catboost_info/learn_error.tsv
catboost_info/test_error.tsv
catboost_info/time_left.tsv
core.py
crud.py
database.py
Dockerfile
export_artifacts_target1.py
export_artifacts_target2.py
export_artifacts_target3.py
export_clustering_artifacts.py
export_hibrido_target1.py
export_hibrido_target2.py
export_hibrido_target3.py
main.py
models.py
README.md
requirements.txt
schemas.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="auth.py">
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from datetime import datetime, timedelta
import os
from core import bcrypt # <--- IMPORTA√á√ÉO CHAVE

SECRET_KEY = os.getenv('JWT_SECRET_KEY', 'default_secret_key')
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="login")

def verify_password(plain_password, hashed_password):
    """Verifica a senha usando bcrypt."""
    # A biblioteca Flask-Bcrypt espera que o hash seja um bytes-like object
    return bcrypt.check_password_hash(hashed_password.encode('utf-8'), plain_password)

def get_password_hash(password):
    """Gera o hash da senha usando bcrypt."""
    return bcrypt.generate_password_hash(password).decode('utf-8')

def create_access_token(data: dict):
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

async def get_current_user_id(token: str = Depends(oauth2_scheme)):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        user_id: str = payload.get("sub")
        if user_id is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception
    return user_id
</file>

<file path="catboost_info/catboost_training.json">
{
"meta":{"test_sets":[],"test_metrics":[],"learn_metrics":[{"best_value":"Min","name":"RMSE"}],"launch_mode":"Train","parameters":"","iteration_count":338,"learn_sets":["learn"],"name":"experiment"},
"iterations":[
{"learn":[22.62912629],"iteration":0,"passed_time":0.0005901227796,"remaining_time":0.1988713767},
{"learn":[22.55904783],"iteration":1,"passed_time":0.001105893137,"remaining_time":0.1857900469},
{"learn":[22.45396966],"iteration":2,"passed_time":0.001690344431,"remaining_time":0.1887551282},
{"learn":[22.34197654],"iteration":3,"passed_time":0.002289801272,"remaining_time":0.1911984062},
{"learn":[22.26364277],"iteration":4,"passed_time":0.002876551776,"remaining_time":0.1915783483},
{"learn":[22.18266737],"iteration":5,"passed_time":0.005202257891,"remaining_time":0.2878582699},
{"learn":[22.10177672],"iteration":6,"passed_time":0.005828830165,"remaining_time":0.2756203978},
{"learn":[22.00827781],"iteration":7,"passed_time":0.006266134417,"remaining_time":0.2584780447},
{"learn":[21.8879153],"iteration":8,"passed_time":0.006684786783,"remaining_time":0.2443660946},
{"learn":[21.77915344],"iteration":9,"passed_time":0.00707286833,"remaining_time":0.2319900812},
{"learn":[21.68208858],"iteration":10,"passed_time":0.00745650067,"remaining_time":0.221661429},
{"learn":[21.58770379],"iteration":11,"passed_time":0.008846923598,"remaining_time":0.2403414244},
{"learn":[21.49101501],"iteration":12,"passed_time":0.009405632104,"remaining_time":0.2351408026},
{"learn":[21.40894799],"iteration":13,"passed_time":0.009902390308,"remaining_time":0.2291696043},
{"learn":[21.31034525],"iteration":14,"passed_time":0.01038840161,"remaining_time":0.2236969146},
{"learn":[21.24053315],"iteration":15,"passed_time":0.01084943935,"remaining_time":0.218344967},
{"learn":[21.1884252],"iteration":16,"passed_time":0.01140690587,"remaining_time":0.2153892226},
{"learn":[21.11628445],"iteration":17,"passed_time":0.01194795979,"remaining_time":0.212408174},
{"learn":[21.05137132],"iteration":18,"passed_time":0.0124129365,"remaining_time":0.2084066707},
{"learn":[20.98607817],"iteration":19,"passed_time":0.01296310376,"remaining_time":0.2061133498},
{"learn":[20.92119893],"iteration":20,"passed_time":0.013543705,"remaining_time":0.2044454517},
{"learn":[20.8209076],"iteration":21,"passed_time":0.01404569634,"remaining_time":0.2017472747},
{"learn":[20.77577424],"iteration":22,"passed_time":0.0145653585,"remaining_time":0.1994820838},
{"learn":[20.71303699],"iteration":23,"passed_time":0.01504383977,"remaining_time":0.1968235703},
{"learn":[20.65286172],"iteration":24,"passed_time":0.01552857004,"remaining_time":0.1944176969},
{"learn":[20.5720313],"iteration":25,"passed_time":0.01600428978,"remaining_time":0.1920514774},
{"learn":[20.486344],"iteration":26,"passed_time":0.01645181137,"remaining_time":0.1895004939},
{"learn":[20.41327157],"iteration":27,"passed_time":0.01686961487,"remaining_time":0.186770736},
{"learn":[20.3399392],"iteration":28,"passed_time":0.01732954476,"remaining_time":0.1846492872},
{"learn":[20.26644286],"iteration":29,"passed_time":0.01779938042,"remaining_time":0.1827403056},
{"learn":[20.19166332],"iteration":30,"passed_time":0.01829115133,"remaining_time":0.1811414019},
{"learn":[20.10730211],"iteration":31,"passed_time":0.02013059412,"remaining_time":0.1924988062},
{"learn":[20.03692841],"iteration":32,"passed_time":0.02083562747,"remaining_time":0.1925717084},
{"learn":[19.98503921],"iteration":33,"passed_time":0.02128784334,"remaining_time":0.190338364},
{"learn":[19.90645384],"iteration":34,"passed_time":0.021732356,"remaining_time":0.1881401105},
{"learn":[19.82446263],"iteration":35,"passed_time":0.0223134126,"remaining_time":0.187184739},
{"learn":[19.76739553],"iteration":36,"passed_time":0.02279428817,"remaining_time":0.1854346146},
{"learn":[19.71030814],"iteration":37,"passed_time":0.02328636679,"remaining_time":0.1838397378},
{"learn":[19.65883472],"iteration":38,"passed_time":0.02381799387,"remaining_time":0.1826046197},
{"learn":[19.60894093],"iteration":39,"passed_time":0.02438724828,"remaining_time":0.1816849997},
{"learn":[19.54461878],"iteration":40,"passed_time":0.02503883817,"remaining_time":0.1813789009},
{"learn":[19.49431936],"iteration":41,"passed_time":0.02568696766,"remaining_time":0.1810319625},
{"learn":[19.4565095],"iteration":42,"passed_time":0.02628653389,"remaining_time":0.1803378488},
{"learn":[19.39079518],"iteration":43,"passed_time":0.02683839541,"remaining_time":0.1793292784},
{"learn":[19.34211801],"iteration":44,"passed_time":0.0274766771,"remaining_time":0.1789036976},
{"learn":[19.27800836],"iteration":45,"passed_time":0.0281223945,"remaining_time":0.1785160695},
{"learn":[19.2367765],"iteration":46,"passed_time":0.02876873155,"remaining_time":0.1781212953},
{"learn":[19.19050666],"iteration":47,"passed_time":0.02920764153,"remaining_time":0.1764628343},
{"learn":[19.16504631],"iteration":48,"passed_time":0.02971288261,"remaining_time":0.1752453689},
{"learn":[19.09858418],"iteration":49,"passed_time":0.03013895677,"remaining_time":0.173600391},
{"learn":[19.0383305],"iteration":50,"passed_time":0.03056721185,"remaining_time":0.1720154863},
{"learn":[18.99658065],"iteration":51,"passed_time":0.03122630587,"remaining_time":0.1717446823},
{"learn":[18.96472302],"iteration":52,"passed_time":0.03175290933,"remaining_time":0.1707467766},
{"learn":[18.88910242],"iteration":53,"passed_time":0.03224075443,"remaining_time":0.1695624863},
{"learn":[18.84491235],"iteration":54,"passed_time":0.03274836661,"remaining_time":0.1685052319},
{"learn":[18.78782058],"iteration":55,"passed_time":0.03328911903,"remaining_time":0.1676344922},
{"learn":[18.74950573],"iteration":56,"passed_time":0.03375820864,"remaining_time":0.1664220461},
{"learn":[18.68726581],"iteration":57,"passed_time":0.03426355834,"remaining_time":0.1654102816},
{"learn":[18.65924247],"iteration":58,"passed_time":0.03479373277,"remaining_time":0.1645330753},
{"learn":[18.60662375],"iteration":59,"passed_time":0.03537096405,"remaining_time":0.1638854668},
{"learn":[18.56240041],"iteration":60,"passed_time":0.03678500258,"remaining_time":0.1670400937},
{"learn":[18.49841418],"iteration":61,"passed_time":0.03726322873,"remaining_time":0.1658814698},
{"learn":[18.46776677],"iteration":62,"passed_time":0.03780190458,"remaining_time":0.1650083137},
{"learn":[18.42032929],"iteration":63,"passed_time":0.0382512159,"remaining_time":0.1637630181},
{"learn":[18.36556165],"iteration":64,"passed_time":0.03872165574,"remaining_time":0.1626309541},
{"learn":[18.31134795],"iteration":65,"passed_time":0.03916892761,"remaining_time":0.1614234593},
{"learn":[18.27055254],"iteration":66,"passed_time":0.03960062609,"remaining_time":0.1601756667},
{"learn":[18.23604688],"iteration":67,"passed_time":0.0401069816,"remaining_time":0.1592483093},
{"learn":[18.19564288],"iteration":68,"passed_time":0.04060734633,"remaining_time":0.1583097995},
{"learn":[18.15833046],"iteration":69,"passed_time":0.04123523211,"remaining_time":0.1578720315},
{"learn":[18.12974793],"iteration":70,"passed_time":0.04174650919,"remaining_time":0.1569903937},
{"learn":[18.10009682],"iteration":71,"passed_time":0.04220738768,"remaining_time":0.1559328489},
{"learn":[18.07737895],"iteration":72,"passed_time":0.04261684398,"remaining_time":0.1547049816},
{"learn":[18.04871948],"iteration":73,"passed_time":0.04305897008,"remaining_time":0.1536157851},
{"learn":[17.99982834],"iteration":74,"passed_time":0.04349026191,"remaining_time":0.1525058517},
{"learn":[17.96840211],"iteration":75,"passed_time":0.04394878977,"remaining_time":0.15150767},
{"learn":[17.93087117],"iteration":76,"passed_time":0.04439020307,"remaining_time":0.1504654935},
{"learn":[17.908707],"iteration":77,"passed_time":0.04487923797,"remaining_time":0.1495974599},
{"learn":[17.87695402],"iteration":78,"passed_time":0.04534483393,"remaining_time":0.1486621771},
{"learn":[17.85023579],"iteration":79,"passed_time":0.04588860995,"remaining_time":0.1479907671},
{"learn":[17.82919942],"iteration":80,"passed_time":0.04635197474,"remaining_time":0.1470673766},
{"learn":[17.79442245],"iteration":81,"passed_time":0.04682752131,"remaining_time":0.1461932373},
{"learn":[17.75806215],"iteration":82,"passed_time":0.04727716158,"remaining_time":0.1452491109},
{"learn":[17.71935051],"iteration":83,"passed_time":0.04774597636,"remaining_time":0.144374738},
{"learn":[17.69551252],"iteration":84,"passed_time":0.04824316982,"remaining_time":0.1435943761},
{"learn":[17.67245834],"iteration":85,"passed_time":0.04868299053,"remaining_time":0.1426524839},
{"learn":[17.65789702],"iteration":86,"passed_time":0.04915395144,"remaining_time":0.1418119748},
{"learn":[17.62071453],"iteration":87,"passed_time":0.04963951743,"remaining_time":0.1410213563},
{"learn":[17.57896867],"iteration":88,"passed_time":0.05010682311,"remaining_time":0.1401865051},
{"learn":[17.54827239],"iteration":89,"passed_time":0.05056808544,"remaining_time":0.1393431688},
{"learn":[17.51957115],"iteration":90,"passed_time":0.05105218099,"remaining_time":0.1385702055},
{"learn":[17.48774608],"iteration":91,"passed_time":0.05158736242,"remaining_time":0.1379401213},
{"learn":[17.46792008],"iteration":92,"passed_time":0.05212482798,"remaining_time":0.1373180952},
{"learn":[17.45192224],"iteration":93,"passed_time":0.05261427418,"remaining_time":0.1365732223},
{"learn":[17.43488891],"iteration":94,"passed_time":0.05309613468,"remaining_time":0.1358143235},
{"learn":[17.40251379],"iteration":95,"passed_time":0.05355808237,"remaining_time":0.1350109993},
{"learn":[17.38055767],"iteration":96,"passed_time":0.05410819397,"remaining_time":0.1344337603},
{"learn":[17.34711493],"iteration":97,"passed_time":0.05454304208,"remaining_time":0.1335747969},
{"learn":[17.32091432],"iteration":98,"passed_time":0.05497394194,"remaining_time":0.1327148699},
{"learn":[17.29677259],"iteration":99,"passed_time":0.05550118901,"remaining_time":0.1320928299},
{"learn":[17.27307874],"iteration":100,"passed_time":0.05598859499,"remaining_time":0.1313791783},
{"learn":[17.25646811],"iteration":101,"passed_time":0.05664297231,"remaining_time":0.1310562889},
{"learn":[17.23567678],"iteration":102,"passed_time":0.05716056641,"remaining_time":0.1304148845},
{"learn":[17.22139429],"iteration":103,"passed_time":0.05794867086,"remaining_time":0.1303845094},
{"learn":[17.19746097],"iteration":104,"passed_time":0.05849038115,"remaining_time":0.129792941},
{"learn":[17.16872891],"iteration":105,"passed_time":0.05955872969,"remaining_time":0.1303549555},
{"learn":[17.13966866],"iteration":106,"passed_time":0.06003631223,"remaining_time":0.129611104},
{"learn":[17.11753449],"iteration":107,"passed_time":0.06053562399,"remaining_time":0.1289184585},
{"learn":[17.09590237],"iteration":108,"passed_time":0.06100824205,"remaining_time":0.1281732792},
{"learn":[17.07480181],"iteration":109,"passed_time":0.06153995109,"remaining_time":0.127555535},
{"learn":[17.05738127],"iteration":110,"passed_time":0.06208361733,"remaining_time":0.126963794},
{"learn":[17.03507019],"iteration":111,"passed_time":0.06254142118,"remaining_time":0.1261996535},
{"learn":[17.01558996],"iteration":112,"passed_time":0.06295081796,"remaining_time":0.125344549},
{"learn":[16.98508564],"iteration":113,"passed_time":0.06461097928,"remaining_time":0.1269549067},
{"learn":[16.97127125],"iteration":114,"passed_time":0.06813396512,"remaining_time":0.1321206454},
{"learn":[16.94810725],"iteration":115,"passed_time":0.06872596423,"remaining_time":0.1315272764},
{"learn":[16.92853312],"iteration":116,"passed_time":0.06926679704,"remaining_time":0.1308372833},
{"learn":[16.90254726],"iteration":117,"passed_time":0.06995238878,"remaining_time":0.1304197079},
{"learn":[16.88469378],"iteration":118,"passed_time":0.07056891999,"remaining_time":0.1298705334},
{"learn":[16.87072203],"iteration":119,"passed_time":0.07116070108,"remaining_time":0.1292752736},
{"learn":[16.84716501],"iteration":120,"passed_time":0.07196387408,"remaining_time":0.1290591791},
{"learn":[16.82771963],"iteration":121,"passed_time":0.07271209259,"remaining_time":0.1287361639},
{"learn":[16.8050763],"iteration":122,"passed_time":0.07318767782,"remaining_time":0.1279296807},
{"learn":[16.78685079],"iteration":123,"passed_time":0.07372808542,"remaining_time":0.1272404055},
{"learn":[16.77239707],"iteration":124,"passed_time":0.0746860329,"remaining_time":0.1272650001},
{"learn":[16.74705365],"iteration":125,"passed_time":0.07528941363,"remaining_time":0.1266774261},
{"learn":[16.73883188],"iteration":126,"passed_time":0.07577474691,"remaining_time":0.1258934772},
{"learn":[16.72175591],"iteration":127,"passed_time":0.07621897894,"remaining_time":0.1250467623},
{"learn":[16.69972093],"iteration":128,"passed_time":0.07665591365,"remaining_time":0.1241944648},
{"learn":[16.67237764],"iteration":129,"passed_time":0.07706483574,"remaining_time":0.1233037372},
{"learn":[16.65546848],"iteration":130,"passed_time":0.07757199334,"remaining_time":0.1225755925},
{"learn":[16.64434503],"iteration":131,"passed_time":0.07809110389,"remaining_time":0.12186945},
{"learn":[16.62263409],"iteration":132,"passed_time":0.07874594043,"remaining_time":0.1213753217},
{"learn":[16.60535286],"iteration":133,"passed_time":0.07917493151,"remaining_time":0.1205349704},
{"learn":[16.59631093],"iteration":134,"passed_time":0.07968635354,"remaining_time":0.119824665},
{"learn":[16.57976196],"iteration":135,"passed_time":0.08026934329,"remaining_time":0.1192235834},
{"learn":[16.56071482],"iteration":136,"passed_time":0.08097815595,"remaining_time":0.1188073675},
{"learn":[16.54404295],"iteration":137,"passed_time":0.08148860427,"remaining_time":0.1180994265},
{"learn":[16.53362896],"iteration":138,"passed_time":0.08196032707,"remaining_time":0.1173388855},
{"learn":[16.51655897],"iteration":139,"passed_time":0.08252207117,"remaining_time":0.1167097864},
{"learn":[16.50266489],"iteration":140,"passed_time":0.08309006387,"remaining_time":0.1160903729},
{"learn":[16.47964536],"iteration":141,"passed_time":0.08358056922,"remaining_time":0.1153647293},
{"learn":[16.46523158],"iteration":142,"passed_time":0.08409053782,"remaining_time":0.1146689152},
{"learn":[16.45029137],"iteration":143,"passed_time":0.08462967329,"remaining_time":0.1140149765},
{"learn":[16.42988106],"iteration":144,"passed_time":0.08525338122,"remaining_time":0.1134751902},
{"learn":[16.41202622],"iteration":145,"passed_time":0.08569745978,"remaining_time":0.1126980293},
{"learn":[16.39756015],"iteration":146,"passed_time":0.0861398441,"remaining_time":0.1119231988},
{"learn":[16.38344291],"iteration":147,"passed_time":0.08654491923,"remaining_time":0.1111049639},
{"learn":[16.36760885],"iteration":148,"passed_time":0.08701047112,"remaining_time":0.1103689869},
{"learn":[16.35098488],"iteration":149,"passed_time":0.08751068123,"remaining_time":0.1096800538},
{"learn":[16.34799984],"iteration":150,"passed_time":0.08793962592,"remaining_time":0.1089053645},
{"learn":[16.33462709],"iteration":151,"passed_time":0.08837461318,"remaining_time":0.1081426188},
{"learn":[16.32068485],"iteration":152,"passed_time":0.08883685001,"remaining_time":0.1074171062},
{"learn":[16.30618458],"iteration":153,"passed_time":0.08941305114,"remaining_time":0.106831178},
{"learn":[16.29044882],"iteration":154,"passed_time":0.08994066814,"remaining_time":0.1061880146},
{"learn":[16.28104842],"iteration":155,"passed_time":0.09044942761,"remaining_time":0.1055243322},
{"learn":[16.26304502],"iteration":156,"passed_time":0.09102288035,"remaining_time":0.104937206},
{"learn":[16.24745918],"iteration":157,"passed_time":0.09142054683,"remaining_time":0.1041499901},
{"learn":[16.2309831],"iteration":158,"passed_time":0.0919514731,"remaining_time":0.1035176961},
{"learn":[16.22858712],"iteration":159,"passed_time":0.09237527047,"remaining_time":0.1027674884},
{"learn":[16.21606988],"iteration":160,"passed_time":0.09285567677,"remaining_time":0.1020835701},
{"learn":[16.20142297],"iteration":161,"passed_time":0.09335100551,"remaining_time":0.1014183764},
{"learn":[16.18597306],"iteration":162,"passed_time":0.09386758144,"remaining_time":0.1007780782},
{"learn":[16.17027527],"iteration":163,"passed_time":0.09445106751,"remaining_time":0.1002102789},
{"learn":[16.15692885],"iteration":164,"passed_time":0.09506787395,"remaining_time":0.09967722541},
{"learn":[16.13991977],"iteration":165,"passed_time":0.09568871559,"remaining_time":0.09914734387},
{"learn":[16.12788629],"iteration":166,"passed_time":0.09610639772,"remaining_time":0.09840834736},
{"learn":[16.11130744],"iteration":167,"passed_time":0.0966172349,"remaining_time":0.09776744008},
{"learn":[16.09664531],"iteration":168,"passed_time":0.09710539311,"remaining_time":0.09710539311},
{"learn":[16.08361703],"iteration":169,"passed_time":0.09753632699,"remaining_time":0.09638884079},
{"learn":[16.07239464],"iteration":170,"passed_time":0.09805344989,"remaining_time":0.09575980194},
{"learn":[16.05786586],"iteration":171,"passed_time":0.0985541285,"remaining_time":0.09511619378},
{"learn":[16.04333996],"iteration":172,"passed_time":0.09897982229,"remaining_time":0.09440272068},
{"learn":[16.0292017],"iteration":173,"passed_time":0.09955864849,"remaining_time":0.09383688708},
{"learn":[16.01540527],"iteration":174,"passed_time":0.1000906892,"remaining_time":0.09322732764},
{"learn":[16.00202064],"iteration":175,"passed_time":0.1005489654,"remaining_time":0.09255075225},
{"learn":[15.98625344],"iteration":176,"passed_time":0.1009488778,"remaining_time":0.09182355547},
{"learn":[15.97216232],"iteration":177,"passed_time":0.1015055951,"remaining_time":0.09124098439},
{"learn":[15.96160283],"iteration":178,"passed_time":0.1021074911,"remaining_time":0.09069883289},
{"learn":[15.94752053],"iteration":179,"passed_time":0.1026445929,"remaining_time":0.09009914268},
{"learn":[15.94716544],"iteration":180,"passed_time":0.1031150695,"remaining_time":0.0894423531},
{"learn":[15.94400209],"iteration":181,"passed_time":0.1035346913,"remaining_time":0.08874402114},
{"learn":[15.94270422],"iteration":182,"passed_time":0.1039741974,"remaining_time":0.08806557702},
{"learn":[15.93235761],"iteration":183,"passed_time":0.1045765313,"remaining_time":0.08752600991},
{"learn":[15.91961253],"iteration":184,"passed_time":0.1050871544,"remaining_time":0.08690991685},
{"learn":[15.90709724],"iteration":185,"passed_time":0.1055843811,"remaining_time":0.08628401033},
{"learn":[15.89941905],"iteration":186,"passed_time":0.1066047334,"remaining_time":0.08608189705},
{"learn":[15.88720731],"iteration":187,"passed_time":0.1070620491,"remaining_time":0.08542184766},
{"learn":[15.87715071],"iteration":188,"passed_time":0.1075397584,"remaining_time":0.08478002117},
{"learn":[15.86527816],"iteration":189,"passed_time":0.1079913867,"remaining_time":0.08411960649},
{"learn":[15.85638056],"iteration":190,"passed_time":0.1083921471,"remaining_time":0.08342222843},
{"learn":[15.84520276],"iteration":191,"passed_time":0.1088177744,"remaining_time":0.08274684932},
{"learn":[15.83563554],"iteration":192,"passed_time":0.1092724758,"remaining_time":0.08209590154},
{"learn":[15.82425455],"iteration":193,"passed_time":0.1097956347,"remaining_time":0.08149779074},
{"learn":[15.81519642],"iteration":194,"passed_time":0.1102182261,"remaining_time":0.08082669912},
{"learn":[15.80419142],"iteration":195,"passed_time":0.1106893814,"remaining_time":0.08019332736},
{"learn":[15.79353906],"iteration":196,"passed_time":0.1111999979,"remaining_time":0.0795898462},
{"learn":[15.78131232],"iteration":197,"passed_time":0.111705774,"remaining_time":0.07898388057},
{"learn":[15.77841406],"iteration":198,"passed_time":0.1121743506,"remaining_time":0.07835293837},
{"learn":[15.77554588],"iteration":199,"passed_time":0.1125974615,"remaining_time":0.07769224841},
{"learn":[15.76648752],"iteration":200,"passed_time":0.1130959464,"remaining_time":0.0770852968},
{"learn":[15.75572559],"iteration":201,"passed_time":0.1135670391,"remaining_time":0.07646097683},
{"learn":[15.75535958],"iteration":202,"passed_time":0.1139733868,"remaining_time":0.07579510943},
{"learn":[15.74478907],"iteration":203,"passed_time":0.1144068997,"remaining_time":0.07514963021},
{"learn":[15.74444293],"iteration":204,"passed_time":0.1148630399,"remaining_time":0.07452089904},
{"learn":[15.73561079],"iteration":205,"passed_time":0.1153291314,"remaining_time":0.07390022011},
{"learn":[15.7352637],"iteration":206,"passed_time":0.1157983261,"remaining_time":0.07328299867},
{"learn":[15.72851918],"iteration":207,"passed_time":0.1163213443,"remaining_time":0.07270084022},
{"learn":[15.71849949],"iteration":208,"passed_time":0.1167714736,"remaining_time":0.07207425883},
{"learn":[15.70850606],"iteration":209,"passed_time":0.1171683716,"remaining_time":0.07141691223},
{"learn":[15.70817002],"iteration":210,"passed_time":0.1176811091,"remaining_time":0.07083175761},
{"learn":[15.69835457],"iteration":211,"passed_time":0.1181637458,"remaining_time":0.07022939609},
{"learn":[15.69726829],"iteration":212,"passed_time":0.1186312065,"remaining_time":0.06961925263},
{"learn":[15.69126651],"iteration":213,"passed_time":0.1193362742,"remaining_time":0.06914812152},
{"learn":[15.68168939],"iteration":214,"passed_time":0.1198699102,"remaining_time":0.06857673935},
{"learn":[15.6733662],"iteration":215,"passed_time":0.120501084,"remaining_time":0.06806079746},
{"learn":[15.67071771],"iteration":216,"passed_time":0.1210523676,"remaining_time":0.06749924648},
{"learn":[15.66140659],"iteration":217,"passed_time":0.1216088879,"remaining_time":0.06694067223},
{"learn":[15.65193439],"iteration":218,"passed_time":0.122079175,"remaining_time":0.06633525949},
{"learn":[15.64622809],"iteration":219,"passed_time":0.1225423094,"remaining_time":0.0657272387},
{"learn":[15.63703485],"iteration":220,"passed_time":0.1230348933,"remaining_time":0.06513611997},
{"learn":[15.62802347],"iteration":221,"passed_time":0.1235248814,"remaining_time":0.06454453263},
{"learn":[15.62005566],"iteration":222,"passed_time":0.1335875399,"remaining_time":0.06889043536},
{"learn":[15.6121973],"iteration":223,"passed_time":0.1342641922,"remaining_time":0.06833088354},
{"learn":[15.60601645],"iteration":224,"passed_time":0.1348075021,"remaining_time":0.06770332325},
{"learn":[15.59925629],"iteration":225,"passed_time":0.1355298494,"remaining_time":0.06716523512},
{"learn":[15.59346933],"iteration":226,"passed_time":0.1359992019,"remaining_time":0.06650181239},
{"learn":[15.58488569],"iteration":227,"passed_time":0.1364827602,"remaining_time":0.06584694569},
{"learn":[15.58314196],"iteration":228,"passed_time":0.1369301186,"remaining_time":0.06517634467},
{"learn":[15.57575299],"iteration":229,"passed_time":0.1374929014,"remaining_time":0.06456188412},
{"learn":[15.57541581],"iteration":230,"passed_time":0.1386322544,"remaining_time":0.06421494036},
{"learn":[15.56703691],"iteration":231,"passed_time":0.1391950557,"remaining_time":0.06359774098},
{"learn":[15.56662703],"iteration":232,"passed_time":0.1397435825,"remaining_time":0.06297457579},
{"learn":[15.5584365],"iteration":233,"passed_time":0.140202788,"remaining_time":0.0623123502},
{"learn":[15.54854734],"iteration":234,"passed_time":0.1408623408,"remaining_time":0.06173966427},
{"learn":[15.5412056],"iteration":235,"passed_time":0.1412916543,"remaining_time":0.06106673193},
{"learn":[15.53336515],"iteration":236,"passed_time":0.1419389496,"remaining_time":0.06048875066},
{"learn":[15.52537721],"iteration":237,"passed_time":0.142393201,"remaining_time":0.05982907606},
{"learn":[15.51823908],"iteration":238,"passed_time":0.1428996655,"remaining_time":0.05919274848},
{"learn":[15.5179174],"iteration":239,"passed_time":0.144174576,"remaining_time":0.05887128521},
{"learn":[15.51098691],"iteration":240,"passed_time":0.1447743085,"remaining_time":0.05827015735},
{"learn":[15.50402324],"iteration":241,"passed_time":0.1453726888,"remaining_time":0.05766850464},
{"learn":[15.50256475],"iteration":242,"passed_time":0.1474654427,"remaining_time":0.05765109899},
{"learn":[15.50085988],"iteration":243,"passed_time":0.1479324998,"remaining_time":0.05699038927},
{"learn":[15.49572926],"iteration":244,"passed_time":0.148708935,"remaining_time":0.05644869779},
{"learn":[15.48831934],"iteration":245,"passed_time":0.1492256609,"remaining_time":0.05580797076},
{"learn":[15.48072297],"iteration":246,"passed_time":0.1500255977,"remaining_time":0.05527258864},
{"learn":[15.47160981],"iteration":247,"passed_time":0.1506014568,"remaining_time":0.05465375447},
{"learn":[15.47015882],"iteration":248,"passed_time":0.1512127139,"remaining_time":0.0540479178},
{"learn":[15.46852768],"iteration":249,"passed_time":0.1520202665,"remaining_time":0.0535111338},
{"learn":[15.46621868],"iteration":250,"passed_time":0.1527536263,"remaining_time":0.05294647606},
{"learn":[15.45853562],"iteration":251,"passed_time":0.1532336716,"remaining_time":0.05229403078},
{"learn":[15.45154397],"iteration":252,"passed_time":0.1536975667,"remaining_time":0.05163752242},
{"learn":[15.44311811],"iteration":253,"passed_time":0.1543814174,"remaining_time":0.05105527191},
{"learn":[15.44216034],"iteration":254,"passed_time":0.1549693601,"remaining_time":0.0504410074},
{"learn":[15.43752228],"iteration":255,"passed_time":0.1554680317,"remaining_time":0.04979835391},
{"learn":[15.43082222],"iteration":256,"passed_time":0.1560453132,"remaining_time":0.04918159678},
{"learn":[15.42568857],"iteration":257,"passed_time":0.1577043528,"remaining_time":0.04890057451},
{"learn":[15.4191554],"iteration":258,"passed_time":0.1583111696,"remaining_time":0.04828796292},
{"learn":[15.41273524],"iteration":259,"passed_time":0.1588731128,"remaining_time":0.04766193383},
{"learn":[15.41129408],"iteration":260,"passed_time":0.1593544893,"remaining_time":0.04701262711},
{"learn":[15.40499359],"iteration":261,"passed_time":0.1598076623,"remaining_time":0.04635642112},
{"learn":[15.39732555],"iteration":262,"passed_time":0.1602444741,"remaining_time":0.04569709336},
{"learn":[15.39291295],"iteration":263,"passed_time":0.1606604345,"remaining_time":0.04503360663},
{"learn":[15.38600391],"iteration":264,"passed_time":0.1611066982,"remaining_time":0.04438033574},
{"learn":[15.38004674],"iteration":265,"passed_time":0.161531247,"remaining_time":0.04372274356},
{"learn":[15.37419043],"iteration":266,"passed_time":0.1620128431,"remaining_time":0.0430820669},
{"learn":[15.368433],"iteration":267,"passed_time":0.1625396329,"remaining_time":0.04245438173},
{"learn":[15.36106699],"iteration":268,"passed_time":0.1630558714,"remaining_time":0.04182474025},
{"learn":[15.36071338],"iteration":269,"passed_time":0.163543059,"remaining_time":0.04118862226},
{"learn":[15.35860281],"iteration":270,"passed_time":0.1640277483,"remaining_time":0.04055298573},
{"learn":[15.35209843],"iteration":271,"passed_time":0.1645400953,"remaining_time":0.03992517019},
{"learn":[15.34529265],"iteration":272,"passed_time":0.1649956502,"remaining_time":0.03928467862},
{"learn":[15.34176242],"iteration":273,"passed_time":0.1655187612,"remaining_time":0.03866131648},
{"learn":[15.33760183],"iteration":274,"passed_time":0.1660412641,"remaining_time":0.03803854414},
{"learn":[15.33298961],"iteration":275,"passed_time":0.1665412767,"remaining_time":0.03741144621},
{"learn":[15.32864949],"iteration":276,"passed_time":0.1672142251,"remaining_time":0.03682334921},
{"learn":[15.32263358],"iteration":277,"passed_time":0.1677263526,"remaining_time":0.03619993222},
{"learn":[15.31836356],"iteration":278,"passed_time":0.1683956087,"remaining_time":0.0356105409},
{"learn":[15.3131689],"iteration":279,"passed_time":0.169001635,"remaining_time":0.03500748153},
{"learn":[15.31161799],"iteration":280,"passed_time":0.1695278055,"remaining_time":0.03438820254},
{"learn":[15.30957949],"iteration":281,"passed_time":0.1702780352,"remaining_time":0.03381407792},
{"learn":[15.30346892],"iteration":282,"passed_time":0.1708695117,"remaining_time":0.03320785563},
{"learn":[15.30314843],"iteration":283,"passed_time":0.1713925222,"remaining_time":0.03258871901},
{"learn":[15.30113188],"iteration":284,"passed_time":0.1780185779,"remaining_time":0.03310520922},
{"learn":[15.29890173],"iteration":285,"passed_time":0.178789981,"remaining_time":0.03250726927},
{"learn":[15.29859108],"iteration":286,"passed_time":0.1804270184,"remaining_time":0.03206194403},
{"learn":[15.29826912],"iteration":287,"passed_time":0.1811791921,"remaining_time":0.03145472085},
{"learn":[15.29381744],"iteration":288,"passed_time":0.1816850876,"remaining_time":0.03080473804},
{"learn":[15.29254256],"iteration":289,"passed_time":0.1821317518,"remaining_time":0.03014594513},
{"learn":[15.28860512],"iteration":290,"passed_time":0.1826221679,"remaining_time":0.0294956766},
{"learn":[15.28828095],"iteration":291,"passed_time":0.183144687,"remaining_time":0.02885156028},
{"learn":[15.28203022],"iteration":292,"passed_time":0.1836329028,"remaining_time":0.02820300555},
{"learn":[15.28122099],"iteration":293,"passed_time":0.1841257321,"remaining_time":0.02755623202},
{"learn":[15.27635588],"iteration":294,"passed_time":0.1846508698,"remaining_time":0.02691521153},
{"learn":[15.27599698],"iteration":295,"passed_time":0.1851390442,"remaining_time":0.02626972925},
{"learn":[15.2738452],"iteration":296,"passed_time":0.1855594778,"remaining_time":0.02561595485},
{"learn":[15.26822662],"iteration":297,"passed_time":0.1860428849,"remaining_time":0.02497219932},
{"learn":[15.26318773],"iteration":298,"passed_time":0.1864846214,"remaining_time":0.02432408105},
{"learn":[15.2616887],"iteration":299,"passed_time":0.1868955164,"remaining_time":0.02367343208},
{"learn":[15.25956737],"iteration":300,"passed_time":0.1873429298,"remaining_time":0.02302886512},
{"learn":[15.2557434],"iteration":301,"passed_time":0.1878230384,"remaining_time":0.02238950127},
{"learn":[15.25381907],"iteration":302,"passed_time":0.1882997995,"remaining_time":0.02175080193},
{"learn":[15.24835557],"iteration":303,"passed_time":0.1887761153,"remaining_time":0.02111311816},
{"learn":[15.24688058],"iteration":304,"passed_time":0.1892346683,"remaining_time":0.02047457067},
{"learn":[15.24311461],"iteration":305,"passed_time":0.1898969962,"remaining_time":0.01985850941},
{"learn":[15.24104758],"iteration":306,"passed_time":0.19046803,"remaining_time":0.01923292811},
{"learn":[15.23706563],"iteration":307,"passed_time":0.1909166663,"remaining_time":0.01859577919},
{"learn":[15.23382403],"iteration":308,"passed_time":0.191387606,"remaining_time":0.01796194361},
{"learn":[15.23255267],"iteration":309,"passed_time":0.1918572766,"remaining_time":0.01732904434},
{"learn":[15.22686973],"iteration":310,"passed_time":0.1922995569,"remaining_time":0.01669481684},
{"learn":[15.22542037],"iteration":311,"passed_time":0.1927514906,"remaining_time":0.01606262422},
{"learn":[15.22174714],"iteration":312,"passed_time":0.1932521051,"remaining_time":0.01543547165},
{"learn":[15.21734627],"iteration":313,"passed_time":0.1939014329,"remaining_time":0.01482049168},
{"learn":[15.2122463],"iteration":314,"passed_time":0.1944562484,"remaining_time":0.01419839274},
{"learn":[15.21081125],"iteration":315,"passed_time":0.1950280954,"remaining_time":0.01357790538},
{"learn":[15.20545774],"iteration":316,"passed_time":0.1955921959,"remaining_time":0.01295721172},
{"learn":[15.2018643],"iteration":317,"passed_time":0.1961372549,"remaining_time":0.01233567641},
{"learn":[15.20077412],"iteration":318,"passed_time":0.196625386,"remaining_time":0.01171122989},
{"learn":[15.19721463],"iteration":319,"passed_time":0.1970567158,"remaining_time":0.01108444026},
{"learn":[15.19690628],"iteration":320,"passed_time":0.1975662197,"remaining_time":0.01046300852},
{"learn":[15.19354536],"iteration":321,"passed_time":0.1981136061,"remaining_time":0.009844154342},
{"learn":[15.19159628],"iteration":322,"passed_time":0.1986454864,"remaining_time":0.009225022589},
{"learn":[15.18965753],"iteration":323,"passed_time":0.1992748059,"remaining_time":0.008610639762},
{"learn":[15.18937071],"iteration":324,"passed_time":0.1998719489,"remaining_time":0.007994877954},
{"learn":[15.18527954],"iteration":325,"passed_time":0.2003677024,"remaining_time":0.007375498248},
{"learn":[15.18453838],"iteration":326,"passed_time":0.2008567563,"remaining_time":0.006756649293},
{"learn":[15.18368197],"iteration":327,"passed_time":0.2013675521,"remaining_time":0.006139254637},
{"learn":[15.1833341],"iteration":328,"passed_time":0.2018700715,"remaining_time":0.00552228159},
{"learn":[15.17952525],"iteration":329,"passed_time":0.2023603565,"remaining_time":0.004905705611},
{"learn":[15.17805618],"iteration":330,"passed_time":0.202876973,"remaining_time":0.00429044958},
{"learn":[15.17406433],"iteration":331,"passed_time":0.2033660272,"remaining_time":0.003675289648},
{"learn":[15.17030763],"iteration":332,"passed_time":0.2038237197,"remaining_time":0.003060416212},
{"learn":[15.16070908],"iteration":333,"passed_time":0.2044446259,"remaining_time":0.002448438634},
{"learn":[15.15883247],"iteration":334,"passed_time":0.2050359919,"remaining_time":0.001836143211},
{"learn":[15.15744176],"iteration":335,"passed_time":0.2055161639,"remaining_time":0.0012233105},
{"learn":[15.15557917],"iteration":336,"passed_time":0.2060791543,"remaining_time":0.0006115108435},
{"learn":[15.15382869],"iteration":337,"passed_time":0.2066165359,"remaining_time":0}
]}
</file>

<file path="catboost_info/learn_error.tsv">
iter	RMSE
0	22.62912629
1	22.55904783
2	22.45396966
3	22.34197654
4	22.26364277
5	22.18266737
6	22.10177672
7	22.00827781
8	21.8879153
9	21.77915344
10	21.68208858
11	21.58770379
12	21.49101501
13	21.40894799
14	21.31034525
15	21.24053315
16	21.1884252
17	21.11628445
18	21.05137132
19	20.98607817
20	20.92119893
21	20.8209076
22	20.77577424
23	20.71303699
24	20.65286172
25	20.5720313
26	20.486344
27	20.41327157
28	20.3399392
29	20.26644286
30	20.19166332
31	20.10730211
32	20.03692841
33	19.98503921
34	19.90645384
35	19.82446263
36	19.76739553
37	19.71030814
38	19.65883472
39	19.60894093
40	19.54461878
41	19.49431936
42	19.4565095
43	19.39079518
44	19.34211801
45	19.27800836
46	19.2367765
47	19.19050666
48	19.16504631
49	19.09858418
50	19.0383305
51	18.99658065
52	18.96472302
53	18.88910242
54	18.84491235
55	18.78782058
56	18.74950573
57	18.68726581
58	18.65924247
59	18.60662375
60	18.56240041
61	18.49841418
62	18.46776677
63	18.42032929
64	18.36556165
65	18.31134795
66	18.27055254
67	18.23604688
68	18.19564288
69	18.15833046
70	18.12974793
71	18.10009682
72	18.07737895
73	18.04871948
74	17.99982834
75	17.96840211
76	17.93087117
77	17.908707
78	17.87695402
79	17.85023579
80	17.82919942
81	17.79442245
82	17.75806215
83	17.71935051
84	17.69551252
85	17.67245834
86	17.65789702
87	17.62071453
88	17.57896867
89	17.54827239
90	17.51957115
91	17.48774608
92	17.46792008
93	17.45192224
94	17.43488891
95	17.40251379
96	17.38055767
97	17.34711493
98	17.32091432
99	17.29677259
100	17.27307874
101	17.25646811
102	17.23567678
103	17.22139429
104	17.19746097
105	17.16872891
106	17.13966866
107	17.11753449
108	17.09590237
109	17.07480181
110	17.05738127
111	17.03507019
112	17.01558996
113	16.98508564
114	16.97127125
115	16.94810725
116	16.92853312
117	16.90254726
118	16.88469378
119	16.87072203
120	16.84716501
121	16.82771963
122	16.8050763
123	16.78685079
124	16.77239707
125	16.74705365
126	16.73883188
127	16.72175591
128	16.69972093
129	16.67237764
130	16.65546848
131	16.64434503
132	16.62263409
133	16.60535286
134	16.59631093
135	16.57976196
136	16.56071482
137	16.54404295
138	16.53362896
139	16.51655897
140	16.50266489
141	16.47964536
142	16.46523158
143	16.45029137
144	16.42988106
145	16.41202622
146	16.39756015
147	16.38344291
148	16.36760885
149	16.35098488
150	16.34799984
151	16.33462709
152	16.32068485
153	16.30618458
154	16.29044882
155	16.28104842
156	16.26304502
157	16.24745918
158	16.2309831
159	16.22858712
160	16.21606988
161	16.20142297
162	16.18597306
163	16.17027527
164	16.15692885
165	16.13991977
166	16.12788629
167	16.11130744
168	16.09664531
169	16.08361703
170	16.07239464
171	16.05786586
172	16.04333996
173	16.0292017
174	16.01540527
175	16.00202064
176	15.98625344
177	15.97216232
178	15.96160283
179	15.94752053
180	15.94716544
181	15.94400209
182	15.94270422
183	15.93235761
184	15.91961253
185	15.90709724
186	15.89941905
187	15.88720731
188	15.87715071
189	15.86527816
190	15.85638056
191	15.84520276
192	15.83563554
193	15.82425455
194	15.81519642
195	15.80419142
196	15.79353906
197	15.78131232
198	15.77841406
199	15.77554588
200	15.76648752
201	15.75572559
202	15.75535958
203	15.74478907
204	15.74444293
205	15.73561079
206	15.7352637
207	15.72851918
208	15.71849949
209	15.70850606
210	15.70817002
211	15.69835457
212	15.69726829
213	15.69126651
214	15.68168939
215	15.6733662
216	15.67071771
217	15.66140659
218	15.65193439
219	15.64622809
220	15.63703485
221	15.62802347
222	15.62005566
223	15.6121973
224	15.60601645
225	15.59925629
226	15.59346933
227	15.58488569
228	15.58314196
229	15.57575299
230	15.57541581
231	15.56703691
232	15.56662703
233	15.5584365
234	15.54854734
235	15.5412056
236	15.53336515
237	15.52537721
238	15.51823908
239	15.5179174
240	15.51098691
241	15.50402324
242	15.50256475
243	15.50085988
244	15.49572926
245	15.48831934
246	15.48072297
247	15.47160981
248	15.47015882
249	15.46852768
250	15.46621868
251	15.45853562
252	15.45154397
253	15.44311811
254	15.44216034
255	15.43752228
256	15.43082222
257	15.42568857
258	15.4191554
259	15.41273524
260	15.41129408
261	15.40499359
262	15.39732555
263	15.39291295
264	15.38600391
265	15.38004674
266	15.37419043
267	15.368433
268	15.36106699
269	15.36071338
270	15.35860281
271	15.35209843
272	15.34529265
273	15.34176242
274	15.33760183
275	15.33298961
276	15.32864949
277	15.32263358
278	15.31836356
279	15.3131689
280	15.31161799
281	15.30957949
282	15.30346892
283	15.30314843
284	15.30113188
285	15.29890173
286	15.29859108
287	15.29826912
288	15.29381744
289	15.29254256
290	15.28860512
291	15.28828095
292	15.28203022
293	15.28122099
294	15.27635588
295	15.27599698
296	15.2738452
297	15.26822662
298	15.26318773
299	15.2616887
300	15.25956737
301	15.2557434
302	15.25381907
303	15.24835557
304	15.24688058
305	15.24311461
306	15.24104758
307	15.23706563
308	15.23382403
309	15.23255267
310	15.22686973
311	15.22542037
312	15.22174714
313	15.21734627
314	15.2122463
315	15.21081125
316	15.20545774
317	15.2018643
318	15.20077412
319	15.19721463
320	15.19690628
321	15.19354536
322	15.19159628
323	15.18965753
324	15.18937071
325	15.18527954
326	15.18453838
327	15.18368197
328	15.1833341
329	15.17952525
330	15.17805618
331	15.17406433
332	15.17030763
333	15.16070908
334	15.15883247
335	15.15744176
336	15.15557917
337	15.15382869
</file>

<file path="catboost_info/test_error.tsv">
iter	RMSE
0	24.97325187
1	24.31553624
2	23.77146897
3	23.2779618
4	22.73472951
5	22.24506633
6	21.81780246
7	21.36353132
8	20.95336663
9	20.65617255
10	20.29695762
11	20.0518295
12	19.76617563
13	19.5329565
14	19.2730599
15	19.14734089
16	18.94805374
17	18.71461401
18	18.59937216
19	18.35121254
20	18.08542362
21	17.96993205
22	17.83179983
23	17.73109078
24	17.61062296
25	17.47168209
26	17.23803424
27	17.0635614
28	16.87146165
29	16.85122515
30	16.75733739
31	16.61696489
32	16.55195885
33	16.4221066
34	16.38678574
35	16.36416354
36	16.26262553
37	16.25978103
38	16.20987503
39	16.10533122
40	16.02941966
41	15.95462384
42	15.90093868
43	15.82610209
44	15.81282117
45	15.80384161
46	15.73022655
47	15.7192581
48	15.67188292
49	15.59855473
50	15.59164642
51	15.54041757
52	15.4970452
53	15.47598982
54	15.44507351
55	15.43404264
56	15.41071774
57	15.40256238
58	15.36860136
59	15.35548265
60	15.27341602
61	15.25980229
62	15.22161108
63	15.23377005
64	15.21418565
65	15.20968828
66	15.1576913
67	15.14753424
68	15.08621542
69	15.04175651
70	15.02460658
71	15.02906852
72	15.03849461
73	15.0349015
74	15.02265994
75	15.01408698
76	14.98521813
77	15.01310161
78	15.00451967
79	14.9895131
80	15.03652215
81	15.0205681
82	14.97991059
83	14.98140968
84	15.0080292
85	14.99690461
86	14.97389321
87	14.97452306
88	14.97619232
89	14.99684783
90	14.98302452
91	14.97038131
92	14.91241705
93	14.89556566
94	14.88389895
95	14.87288461
96	14.89726914
97	14.88653216
98	14.86894885
99	14.85936989
100	14.84912152
101	14.80493053
102	14.7895744
103	14.78035929
104	14.7716599
105	14.76569241
106	14.75716362
107	14.76410341
108	14.75570419
109	14.74993443
110	14.72471755
111	14.71677698
112	14.69647445
113	14.68888779
114	14.68172779
115	14.67122828
116	14.6227691
117	14.61269461
118	14.60088434
119	14.594794
120	14.55987272
121	14.52710618
122	14.51346844
123	14.48265421
124	14.47773126
125	14.48888483
126	14.49598621
127	14.50479939
128	14.49086444
129	14.4714125
130	14.49675416
131	14.50032204
132	14.48770804
133	14.48409605
134	14.49077726
135	14.49924156
136	14.51024535
137	14.46946531
138	14.46433295
139	14.45415801
140	14.47658827
141	14.46442625
142	14.47908826
143	14.48711329
144	14.48052449
145	14.48519585
146	14.49879593
147	14.49275231
148	14.50231444
149	14.47749779
150	14.49417515
151	14.50579119
152	14.47472096
153	14.46391714
154	14.45678045
155	14.4414752
156	14.4171507
157	14.4053544
158	14.41270764
159	14.42029168
160	14.43195536
161	14.42798028
162	14.4183167
163	14.40756631
164	14.41582824
165	14.41754941
166	14.39035787
167	14.38068048
168	14.38849253
169	14.39644093
170	14.3936455
171	14.39103717
172	14.39866756
173	14.39897722
174	14.41531284
175	14.40847843
176	14.39878786
177	14.40486187
178	14.39767118
179	14.38350506
180	14.39071316
181	14.37933045
182	14.36202221
183	14.36278248
184	14.35936964
185	14.37395729
186	14.38034167
187	14.37377445
188	14.38218024
189	14.38700128
190	14.39172304
191	14.39066588
192	14.38724058
193	14.39364186
194	14.40321268
195	14.40126215
196	14.40740281
197	14.41590147
198	14.41197433
199	14.40420442
200	14.41364655
201	14.42075969
202	14.42969268
203	14.42958595
204	14.43329141
205	14.42660143
206	14.43029132
207	14.42763134
208	14.44087646
209	14.4462925
210	14.45155837
211	14.456682
212	14.46027799
213	14.45621015
214	14.46241121
215	14.47046578
216	14.46843565
217	14.47329272
218	14.49021497
219	14.48885211
220	14.50160408
221	14.49796165
222	14.49707619
223	14.5098219
224	14.50736057
225	14.51349183
226	14.50968887
227	14.51479045
228	14.51969138
229	14.51215244
230	14.50896371
231	14.52041472
232	14.51285299
233	14.51698549
234	14.5415415
</file>

<file path="catboost_info/time_left.tsv">
iter	Passed	Remaining
0	0	198
1	1	185
2	1	188
3	2	191
4	2	191
5	5	287
6	5	275
7	6	258
8	6	244
9	7	231
10	7	221
11	8	240
12	9	235
13	9	229
14	10	223
15	10	218
16	11	215
17	11	212
18	12	208
19	12	206
20	13	204
21	14	201
22	14	199
23	15	196
24	15	194
25	16	192
26	16	189
27	16	186
28	17	184
29	17	182
30	18	181
31	20	192
32	20	192
33	21	190
34	21	188
35	22	187
36	22	185
37	23	183
38	23	182
39	24	181
40	25	181
41	25	181
42	26	180
43	26	179
44	27	178
45	28	178
46	28	178
47	29	176
48	29	175
49	30	173
50	30	172
51	31	171
52	31	170
53	32	169
54	32	168
55	33	167
56	33	166
57	34	165
58	34	164
59	35	163
60	36	167
61	37	165
62	37	165
63	38	163
64	38	162
65	39	161
66	39	160
67	40	159
68	40	158
69	41	157
70	41	156
71	42	155
72	42	154
73	43	153
74	43	152
75	43	151
76	44	150
77	44	149
78	45	148
79	45	147
80	46	147
81	46	146
82	47	145
83	47	144
84	48	143
85	48	142
86	49	141
87	49	141
88	50	140
89	50	139
90	51	138
91	51	137
92	52	137
93	52	136
94	53	135
95	53	135
96	54	134
97	54	133
98	54	132
99	55	132
100	55	131
101	56	131
102	57	130
103	57	130
104	58	129
105	59	130
106	60	129
107	60	128
108	61	128
109	61	127
110	62	126
111	62	126
112	62	125
113	64	126
114	68	132
115	68	131
116	69	130
117	69	130
118	70	129
119	71	129
120	71	129
121	72	128
122	73	127
123	73	127
124	74	127
125	75	126
126	75	125
127	76	125
128	76	124
129	77	123
130	77	122
131	78	121
132	78	121
133	79	120
134	79	119
135	80	119
136	80	118
137	81	118
138	81	117
139	82	116
140	83	116
141	83	115
142	84	114
143	84	114
144	85	113
145	85	112
146	86	111
147	86	111
148	87	110
149	87	109
150	87	108
151	88	108
152	88	107
153	89	106
154	89	106
155	90	105
156	91	104
157	91	104
158	91	103
159	92	102
160	92	102
161	93	101
162	93	100
163	94	100
164	95	99
165	95	99
166	96	98
167	96	97
168	97	97
169	97	96
170	98	95
171	98	95
172	98	94
173	99	93
174	100	93
175	100	92
176	100	91
177	101	91
178	102	90
179	102	90
180	103	89
181	103	88
182	103	88
183	104	87
184	105	86
185	105	86
186	106	86
187	107	85
188	107	84
189	107	84
190	108	83
191	108	82
192	109	82
193	109	81
194	110	80
195	110	80
196	111	79
197	111	78
198	112	78
199	112	77
200	113	77
201	113	76
202	113	75
203	114	75
204	114	74
205	115	73
206	115	73
207	116	72
208	116	72
209	117	71
210	117	70
211	118	70
212	118	69
213	119	69
214	119	68
215	120	68
216	121	67
217	121	66
218	122	66
219	122	65
220	123	65
221	123	64
222	133	68
223	134	68
224	134	67
225	135	67
226	135	66
227	136	65
228	136	65
229	137	64
230	138	64
231	139	63
232	139	62
233	140	62
234	140	61
235	141	61
236	141	60
237	142	59
238	142	59
239	144	58
240	144	58
241	145	57
242	147	57
243	147	56
244	148	56
245	149	55
246	150	55
247	150	54
248	151	54
249	152	53
250	152	52
251	153	52
252	153	51
253	154	51
254	154	50
255	155	49
256	156	49
257	157	48
258	158	48
259	158	47
260	159	47
261	159	46
262	160	45
263	160	45
264	161	44
265	161	43
266	162	43
267	162	42
268	163	41
269	163	41
270	164	40
271	164	39
272	164	39
273	165	38
274	166	38
275	166	37
276	167	36
277	167	36
278	168	35
279	169	35
280	169	34
281	170	33
282	170	33
283	171	32
284	178	33
285	178	32
286	180	32
287	181	31
288	181	30
289	182	30
290	182	29
291	183	28
292	183	28
293	184	27
294	184	26
295	185	26
296	185	25
297	186	24
298	186	24
299	186	23
300	187	23
301	187	22
302	188	21
303	188	21
304	189	20
305	189	19
306	190	19
307	190	18
308	191	17
309	191	17
310	192	16
311	192	16
312	193	15
313	193	14
314	194	14
315	195	13
316	195	12
317	196	12
318	196	11
319	197	11
320	197	10
321	198	9
322	198	9
323	199	8
324	199	7
325	200	7
326	200	6
327	201	6
328	201	5
329	202	4
330	202	4
331	203	3
332	203	3
333	204	2
334	205	1
335	205	1
336	206	0
337	206	0
</file>

<file path="core.py">
from fastapi import FastAPI
from flask_bcrypt import Bcrypt

app = FastAPI(title="API do Projeto Daruma")

# Instancia o Bcrypt diretamente, sem associar a um app Flask.
bcrypt = Bcrypt()
</file>

<file path="crud.py">
# crud.py
from sqlalchemy.orm import Session
import models
import auth

def get_user_by_username(db: Session, username: str):
    return db.query(models.User).filter(models.User.username == username).first()

def create_user(db: Session, user_schema: models.User):
    hashed_password = auth.get_password_hash(user_schema.password)
    db_user = models.User(username=user_schema.username, password_hash=hashed_password)
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user
</file>

<file path="database.py">
# database.py
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
import os

SQLALCHEMY_DATABASE_URL = os.getenv('DATABASE_URL', 'postgresql://user:password@db:5432/daruma_db')

engine = create_engine(SQLALCHEMY_DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

# Dependency para obter a sess√£o do DB
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
</file>

<file path="Dockerfile">
FROM python:3.10-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copia todos os arquivos da aplica√ß√£o
COPY . .

EXPOSE 5000

# Comando para rodar a aplica√ß√£o com Uvicorn (servidor ASGI para FastAPI)
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "5000"]
</file>

<file path="export_artifacts_target1.py">
# export_artifacts_target1.py

import pandas as pd
import numpy as np
import os
import pickle
import joblib
import optuna
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import RobustScaler
from sklearn.feature_selection import VarianceThreshold
from sklearn.metrics import r2_score
from catboost import CatBoostRegressor

print("="*80)
print("INICIANDO EXPORTA√á√ÉO DE ARTEFATOS PARA O TARGET 1")
print("="*80)

# --- 1. CONFIGURA√á√ïES ---
ARTIFACTS_PATH = "ml_artifacts"
if not os.path.exists(ARTIFACTS_PATH):
    os.makedirs(ARTIFACTS_PATH)
TARGET = 'Target1'
RAW_DATA_FILE = 'JogadoresV1.xlsx'
RANDOM_STATE = 42

# --- 2. CARREGAMENTO E FEATURE ENGINEERING (L√≥gica do Notebook Fase 2) ---
print(f"\n[FASE 1] Carregando e processando dados de '{RAW_DATA_FILE}'...")
try:
    df = pd.read_excel(RAW_DATA_FILE)
except FileNotFoundError:
    print(f"‚ùå ERRO: Arquivo '{RAW_DATA_FILE}' n√£o encontrado.")
    exit()

df.dropna(subset=[TARGET], inplace=True)

# Limpeza e convers√£o de tipos
if 'F0103' in df.columns:
    df['F0103'] = pd.to_numeric(df['F0103'].astype(str).str.replace(',', '.'), errors='coerce')

p_cols = [c for c in df.columns if c.startswith('P') and any(char.isdigit() for char in c)]
t_cols = [c for c in df.columns if c.startswith('T') and any(char.isdigit() for char in c)]
f_cols = [c for c in df.columns if c.startswith('F') and len(c) > 1 and any(char.isdigit() for char in c)]

for col in p_cols + t_cols + f_cols:
    df[col] = pd.to_numeric(df[col], errors='coerce')
    df[col].replace(-1, np.nan, inplace=True)

# Imputa√ß√£o com mediana
for col in p_cols + t_cols + f_cols:
    if df[col].isnull().sum() > 0:
        df[col].fillna(df[col].median(), inplace=True)

# Feature Engineering
if 'QtdHorasDormi' in df.columns and 'Acordar' in df.columns:
    df['sono_total'] = df['QtdHorasDormi']
    df['sono_x_acordar'] = df['QtdHorasDormi'] * df['Acordar']

if p_cols:
    df['P_mean'] = df[p_cols].mean(axis=1)
    df['P_std'] = df[p_cols].std(axis=1)

if t_cols:
    df['T_mean'] = df[t_cols].mean(axis=1)

# Agrega√ß√µes conceituais de F
f_sono = [c for c in f_cols if c.startswith('F07')]
if f_sono:
    df['F_sono_mean'] = df[f_sono].mean(axis=1)

print("‚úÖ Dados processados e features criadas.")

# --- 3. SELE√á√ÉO DE FEATURES ---
print("\n[FASE 2] Selecionando as melhores features...")
numeric_features = df.select_dtypes(include=np.number).columns.tolist()
features_to_exclude = ['Target1', 'Target2', 'Target3']
feature_candidates = [f for f in numeric_features if f not in features_to_exclude]

X_temp = df[feature_candidates].fillna(0)
selector = VarianceThreshold(threshold=0.01)
selector.fit(X_temp)
feature_cols_var = X_temp.columns[selector.get_support()].tolist()

correlations = [(col, abs(df[col].corr(df[TARGET]))) for col in feature_cols_var]
correlations = [corr for corr in correlations if not np.isnan(corr[1])]
correlations.sort(key=lambda x: x[1], reverse=True)

TOP_K = 30
selected_features = [col for col, _ in correlations[:TOP_K]]

# Intera√ß√µes
top3_features = selected_features[:3]
for i, f1 in enumerate(top3_features):
    for f2 in top3_features[i+1:]:
        interaction_name = f'{f1}_X_{f2}'
        df[interaction_name] = df[f1] * df[f2]
        selected_features.append(interaction_name)

selected_features = list(dict.fromkeys(selected_features))
print(f"‚úÖ {len(selected_features)} features finais selecionadas para {TARGET}.")

# --- 4. PREPARA√á√ÉO FINAL E SALVAMENTO DE ARTEFATOS ---
X = df[selected_features]
y = df[TARGET]

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=RANDOM_STATE)

# Scaler
scaler = RobustScaler()
X_train_scaled = scaler.fit_transform(X_train)
joblib.dump(scaler, f'{ARTIFACTS_PATH}/scaler_{TARGET.lower()}.pkl')
print(f"üíæ Scaler para {TARGET} salvo em: {ARTIFACTS_PATH}/scaler_{TARGET.lower()}.pkl")

# Lista de Features
with open(f'{ARTIFACTS_PATH}/features_{TARGET.lower()}.pkl', 'wb') as f:
    pickle.dump(selected_features, f)
print(f"üíæ Lista de features para {TARGET} salva em: {ARTIFACTS_PATH}/features_{TARGET.lower()}.pkl")

# --- 5. OTIMIZA√á√ÉO E TREINAMENTO DO MODELO (L√≥gica do Notebook Fase 3) ---
print(f"\n[FASE 3] Otimizando e treinando o modelo para {TARGET}...")

def objective_t1(trial):
    params = {
        'iterations': 500,
        'learning_rate': trial.suggest_float('learning_rate', 0.01, 0.1, log=True),
        'depth': trial.suggest_int('depth', 3, 6),
        'l2_leaf_reg': trial.suggest_float('l2_leaf_reg', 10, 100, log=True),
        'verbose': False,
        'random_seed': RANDOM_STATE
    }
    model = CatBoostRegressor(**params)
    model.fit(X_train_scaled, y_train, eval_set=[(scaler.transform(X_test), y_test)], early_stopping_rounds=50, verbose=False)
    preds = model.predict(scaler.transform(X_test))
    return r2_score(y_test, preds)

study = optuna.create_study(direction='maximize')
study.optimize(objective_t1, n_trials=50) # 50 trials for a good balance
best_params = study.best_params
best_params['iterations'] = 500 # Re-set iterations
best_params['verbose'] = False
best_params['random_seed'] = RANDOM_STATE

final_model = CatBoostRegressor(**best_params)
final_model.fit(X_train_scaled, y_train)

print(f"‚úÖ Modelo {TARGET} treinado com R¬≤ de {study.best_value:.4f} na otimiza√ß√£o.")

# Salvamento do Modelo
joblib.dump(final_model, f'{ARTIFACTS_PATH}/modelo_{TARGET.lower()}.pkl')
print(f"üíæ Modelo para {TARGET} salvo em: {ARTIFACTS_PATH}/modelo_{TARGET.lower()}.pkl")
print("\n--- Conclu√≠do para Target 1 ---")
</file>

<file path="export_artifacts_target2.py">
# export_artifacts_target2.py

import pandas as pd
import numpy as np
import os
import pickle
import joblib
import optuna
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.preprocessing import RobustScaler, PolynomialFeatures
from sklearn.ensemble import RandomForestRegressor, StackingRegressor
from sklearn.linear_model import Ridge
from catboost import CatBoostRegressor
import lightgbm as lgb
import xgboost as xgb

print("="*80)
print("INICIANDO EXPORTA√á√ÉO DE ARTEFATOS PARA O TARGET 2")
print("="*80)

# --- 1. CONFIGURA√á√ïES ---
ARTIFACTS_PATH = "ml_artifacts"
if not os.path.exists(ARTIFACTS_PATH):
    os.makedirs(ARTIFACTS_PATH)
TARGET = 'Target2'
RAW_DATA_FILE = 'JogadoresV1.xlsx'
RANDOM_STATE = 42

# --- 2. CARREGAMENTO E FEATURE ENGINEERING ---
print(f"\n[FASE 1] Carregando e processando dados de '{RAW_DATA_FILE}'...")
try:
    df = pd.read_excel(RAW_DATA_FILE)
except FileNotFoundError:
    print(f"‚ùå ERRO: Arquivo '{RAW_DATA_FILE}' n√£o encontrado.")
    exit()

df.dropna(subset=[TARGET], inplace=True)

# Limpeza e FE simples
if 'F0103' in df.columns:
    df['F0103'] = pd.to_numeric(df['F0103'].astype(str).str.replace(',', '.'), errors='coerce')
if 'QtdHorasDormi' in df.columns and 'Acordar' in df.columns:
    df['sono_total'] = df['QtdHorasDormi']
    df['sono_x_acordar'] = df['QtdHorasDormi'] * df['Acordar']

p_cols = [c for c in df.columns if c.startswith('P') and any(char.isdigit() for char in c)]
t_cols = [c for c in df.columns if c.startswith('T') and any(char.isdigit() for char in c)]
f_cols = [c for c in df.columns if c.startswith('F') and len(c) > 1 and any(char.isdigit() for char in c)]

for col in p_cols + t_cols + f_cols:
    df[col] = pd.to_numeric(df[col], errors='coerce')

if p_cols:
    df['P_mean'] = df[p_cols].mean(axis=1)
if t_cols:
    df['T_mean'] = df[t_cols].mean(axis=1)
if f_cols:
    df['F_mean'] = df[f_cols].mean(axis=1)

# Imputa√ß√£o final antes de separar
numeric_cols = df.select_dtypes(include=np.number).columns
for col in numeric_cols:
    df[col].fillna(df[col].median(), inplace=True)

print("‚úÖ Dados processados e features base criadas.")

# --- 3. PREPARA√á√ÉO E SEPARA√á√ÉO DE DADOS ---
features_to_exclude = ['Target1', 'Target2', 'Target3', 'C√≥digo de Acesso', 'Data/Hora √öltimo']
initial_features = [col for col in df.columns if col not in features_to_exclude and pd.api.types.is_numeric_dtype(df[col])]

X = df[initial_features]
y = df[TARGET]

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=RANDOM_STATE)

# --- 4. FEATURE ENGINEERING AVAN√áADA E SELE√á√ÉO ---
print("\n[FASE 2] Criando features polinomiais e selecionando as melhores...")
# Features Polinomiais
rf_poly_selector = RandomForestRegressor(n_estimators=100, random_state=RANDOM_STATE, n_jobs=-1)
rf_poly_selector.fit(X_train, y_train)
importances = pd.Series(rf_poly_selector.feature_importances_, index=X_train.columns).sort_values(ascending=False)
top_features_for_poly = importances.head(15).index.tolist()

poly = PolynomialFeatures(degree=2, include_bias=False, interaction_only=True)
X_train_poly = poly.fit_transform(X_train[top_features_for_poly])
poly_names = [f"poly_{name}" for name in poly.get_feature_names_out(top_features_for_poly)]
X_train_poly_df = pd.DataFrame(X_train_poly, columns=poly_names, index=X_train.index)
X_train_expanded = X_train.join(X_train_poly_df)

# Sele√ß√£o H√≠brida
correlations = X_train_expanded.corrwith(y_train).abs().sort_values(ascending=False)
top_corr_features = correlations.head(60).index.tolist()
rf_final_selector = RandomForestRegressor(n_estimators=100, random_state=RANDOM_STATE, n_jobs=-1)
rf_final_selector.fit(X_train_expanded, y_train)
importances_final = pd.Series(rf_final_selector.feature_importances_, index=X_train_expanded.columns).sort_values(ascending=False)
top_rf_features = importances_final.head(60).index.tolist()

final_feature_list = list(set(top_corr_features + top_rf_features))
X_train_selected = X_train_expanded[final_feature_list]

print(f"‚úÖ {len(final_feature_list)} features finais selecionadas para {TARGET}.")

# --- 5. SALVAMENTO DE ARTEFATOS DE PR√â-PROCESSAMENTO ---
# Scaler
scaler = RobustScaler()
scaler.fit(X_train_selected)
joblib.dump(scaler, f'{ARTIFACTS_PATH}/scaler_{TARGET.lower()}.pkl')
print(f"üíæ Scaler para {TARGET} salvo.")

# Transformador Polinomial e sua lista de features
joblib.dump(poly, f'{ARTIFACTS_PATH}/poly_transformer_{TARGET.lower()}.pkl')
with open(f'{ARTIFACTS_PATH}/poly_features_list_{TARGET.lower()}.pkl', 'wb') as f:
    pickle.dump(top_features_for_poly, f)
print(f"üíæ Transformador polinomial e lista de features para {TARGET} salvos.")

# Lista final de Features
with open(f'{ARTIFACTS_PATH}/features_{TARGET.lower()}.pkl', 'wb') as f:
    pickle.dump(final_feature_list, f)
print(f"üíæ Lista final de features para {TARGET} salva.")


# --- 6. OTIMIZA√á√ÉO E TREINAMENTO DO MODELO STACKING ---
print(f"\n[FASE 3] Otimizando modelos base e treinando o Stacking para {TARGET}...")

def tune_model(model_name, X, y):
    def objective(trial):
        if model_name == 'catboost':
            params = {'iterations': trial.suggest_int('iterations', 100, 500), 'depth': trial.suggest_int('depth', 3, 7), 'learning_rate': trial.suggest_float('learning_rate', 0.01, 0.3, log=True), 'l2_leaf_reg': trial.suggest_float('l2_leaf_reg', 2, 20, log=True), 'verbose': 0}
            model = CatBoostRegressor(**params, random_state=RANDOM_STATE)
        # Adicione lgb e xgb se necess√°rio
        score = cross_val_score(model, X, y, cv=3, scoring='r2', n_jobs=-1).mean()
        return score
    
    study = optuna.create_study(direction='maximize')
    study.optimize(objective, n_trials=30)
    print(f"  - Melhor R¬≤ CV para {model_name}: {study.best_value:.4f}")
    return study.best_params

best_catboost_params = tune_model('catboost', scaler.transform(X_train_selected), y_train)

base_models = [
    ('catboost', CatBoostRegressor(**best_catboost_params, verbose=0, random_state=RANDOM_STATE)),
    ('random_forest', RandomForestRegressor(n_estimators=150, random_state=RANDOM_STATE))
]
meta_model = Ridge(random_state=RANDOM_STATE)
stacking_model = StackingRegressor(estimators=base_models, final_estimator=meta_model, cv=5, n_jobs=-1)

stacking_model.fit(scaler.transform(X_train_selected), y_train)
print(f"‚úÖ Modelo Stacking para {TARGET} treinado.")

# Salvamento do Modelo
joblib.dump(stacking_model, f'{ARTIFACTS_PATH}/modelo_{TARGET.lower()}.pkl')
print(f"üíæ Modelo para {TARGET} salvo em: {ARTIFACTS_PATH}/modelo_{TARGET.lower()}.pkl")
print("\n--- Conclu√≠do para Target 2 ---")
</file>

<file path="export_artifacts_target3.py">
# export_artifacts_target3.py

import pandas as pd
import numpy as np
import os
import pickle
import joblib
import optuna
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.preprocessing import RobustScaler, PolynomialFeatures
from sklearn.ensemble import RandomForestRegressor, StackingRegressor
from sklearn.linear_model import Ridge
from catboost import CatBoostRegressor
import lightgbm as lgb
import xgboost as xgb

print("="*80)
print("INICIANDO EXPORTA√á√ÉO DE ARTEFATOS PARA O TARGET 3")
print("="*80)

# --- 1. CONFIGURA√á√ïES ---
ARTIFACTS_PATH = "ml_artifacts"
if not os.path.exists(ARTIFACTS_PATH):
    os.makedirs(ARTIFACTS_PATH)
TARGET = 'Target3' # <- ALTERADO
RAW_DATA_FILE = 'JogadoresV1.xlsx'
RANDOM_STATE = 42

# --- 2. CARREGAMENTO E FEATURE ENGINEERING ---
print(f"\n[FASE 1] Carregando e processando dados de '{RAW_DATA_FILE}'...")
try:
    df = pd.read_excel(RAW_DATA_FILE)
except FileNotFoundError:
    print(f"‚ùå ERRO: Arquivo '{RAW_DATA_FILE}' n√£o encontrado.")
    exit()

df.dropna(subset=[TARGET], inplace=True)

# Limpeza e FE simples
if 'F0103' in df.columns:
    df['F0103'] = pd.to_numeric(df['F0103'].astype(str).str.replace(',', '.'), errors='coerce')
if 'QtdHorasDormi' in df.columns and 'Acordar' in df.columns:
    df['sono_total'] = df['QtdHorasDormi']
    df['sono_x_acordar'] = df['QtdHorasDormi'] * df['Acordar']

p_cols = [c for c in df.columns if c.startswith('P') and any(char.isdigit() for char in c)]
t_cols = [c for c in df.columns if c.startswith('T') and any(char.isdigit() for char in c)]
f_cols = [c for c in df.columns if c.startswith('F') and len(c) > 1 and any(char.isdigit() for char in c)]

for col in p_cols + t_cols + f_cols:
    df[col] = pd.to_numeric(df[col], errors='coerce')

if p_cols:
    df['P_mean'] = df[p_cols].mean(axis=1)
if t_cols:
    df['T_mean'] = df[t_cols].mean(axis=1)
if f_cols:
    df['F_mean'] = df[f_cols].mean(axis=1)

# Imputa√ß√£o final antes de separar
numeric_cols = df.select_dtypes(include=np.number).columns
for col in numeric_cols:
    df[col].fillna(df[col].median(), inplace=True)

print("‚úÖ Dados processados e features base criadas.")

# --- 3. PREPARA√á√ÉO E SEPARA√á√ÉO DE DADOS ---
features_to_exclude = ['Target1', 'Target2', 'Target3', 'C√≥digo de Acesso', 'Data/Hora √öltimo']
initial_features = [col for col in df.columns if col not in features_to_exclude and pd.api.types.is_numeric_dtype(df[col])]

X = df[initial_features]
y = df[TARGET]

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=RANDOM_STATE)

# --- 4. FEATURE ENGINEERING AVAN√áADA E SELE√á√ÉO ---
print("\n[FASE 2] Criando features polinomiais e selecionando as melhores...")
# Features Polinomiais
rf_poly_selector = RandomForestRegressor(n_estimators=100, random_state=RANDOM_STATE, n_jobs=-1)
rf_poly_selector.fit(X_train, y_train)
importances = pd.Series(rf_poly_selector.feature_importances_, index=X_train.columns).sort_values(ascending=False)
top_features_for_poly = importances.head(15).index.tolist()

poly = PolynomialFeatures(degree=2, include_bias=False, interaction_only=True)
X_train_poly = poly.fit_transform(X_train[top_features_for_poly])
poly_names = [f"poly_{name}" for name in poly.get_feature_names_out(top_features_for_poly)]
X_train_poly_df = pd.DataFrame(X_train_poly, columns=poly_names, index=X_train.index)
X_train_expanded = X_train.join(X_train_poly_df)

# Sele√ß√£o H√≠brida
correlations = X_train_expanded.corrwith(y_train).abs().sort_values(ascending=False)
top_corr_features = correlations.head(60).index.tolist()
rf_final_selector = RandomForestRegressor(n_estimators=100, random_state=RANDOM_STATE, n_jobs=-1)
rf_final_selector.fit(X_train_expanded, y_train)
importances_final = pd.Series(rf_final_selector.feature_importances_, index=X_train_expanded.columns).sort_values(ascending=False)
top_rf_features = importances_final.head(60).index.tolist()

final_feature_list = list(set(top_corr_features + top_rf_features))
X_train_selected = X_train_expanded[final_feature_list]

print(f"‚úÖ {len(final_feature_list)} features finais selecionadas para {TARGET}.")

# --- 5. SALVAMENTO DE ARTEFATOS DE PR√â-PROCESSAMENTO ---
# Scaler
scaler = RobustScaler()
scaler.fit(X_train_selected)
joblib.dump(scaler, f'{ARTIFACTS_PATH}/scaler_{TARGET.lower()}.pkl') # <- NOME ALTERADO
print(f"üíæ Scaler para {TARGET} salvo.")

# Transformador Polinomial e sua lista de features
joblib.dump(poly, f'{ARTIFACTS_PATH}/poly_transformer_{TARGET.lower()}.pkl') # <- NOME ALTERADO
with open(f'{ARTIFACTS_PATH}/poly_features_list_{TARGET.lower()}.pkl', 'wb') as f: # <- NOME ALTERADO
    pickle.dump(top_features_for_poly, f)
print(f"üíæ Transformador polinomial e lista de features para {TARGET} salvos.")

# Lista final de Features
with open(f'{ARTIFACTS_PATH}/features_{TARGET.lower()}.pkl', 'wb') as f: # <- NOME ALTERADO
    pickle.dump(final_feature_list, f)
print(f"üíæ Lista final de features para {TARGET} salva.")


# --- 6. OTIMIZA√á√ÉO E TREINAMENTO DO MODELO STACKING ---
print(f"\n[FASE 3] Otimizando modelos base e treinando o Stacking para {TARGET}...")

def tune_model(model_name, X, y):
    def objective(trial):
        if model_name == 'catboost':
            params = {'iterations': trial.suggest_int('iterations', 100, 500), 'depth': trial.suggest_int('depth', 3, 7), 'learning_rate': trial.suggest_float('learning_rate', 0.01, 0.3, log=True), 'l2_leaf_reg': trial.suggest_float('l2_leaf_reg', 2, 20, log=True), 'verbose': 0}
            model = CatBoostRegressor(**params, random_state=RANDOM_STATE)
        score = cross_val_score(model, X, y, cv=3, scoring='r2', n_jobs=-1).mean()
        return score
    
    study = optuna.create_study(direction='maximize')
    study.optimize(objective, n_trials=30)
    print(f"  - Melhor R¬≤ CV para {model_name}: {study.best_value:.4f}")
    return study.best_params

best_catboost_params = tune_model('catboost', scaler.transform(X_train_selected), y_train)

base_models = [
    ('catboost', CatBoostRegressor(**best_catboost_params, verbose=0, random_state=RANDOM_STATE)),
    ('random_forest', RandomForestRegressor(n_estimators=150, random_state=RANDOM_STATE))
]
meta_model = Ridge(random_state=RANDOM_STATE)
stacking_model = StackingRegressor(estimators=base_models, final_estimator=meta_model, cv=5, n_jobs=-1)

stacking_model.fit(scaler.transform(X_train_selected), y_train)
print(f"‚úÖ Modelo Stacking para {TARGET} treinado.")

# Salvamento do Modelo
joblib.dump(stacking_model, f'{ARTIFACTS_PATH}/modelo_{TARGET.lower()}.pkl') # <- NOME ALTERADO
print(f"üíæ Modelo para {TARGET} salvo em: {ARTIFACTS_PATH}/modelo_{TARGET.lower()}.pkl")
print("\n--- Conclu√≠do para Target 3 ---")
</file>

<file path="export_clustering_artifacts.py">
# =============================================================================
# EXPORT DE ARTEFATOS DE CLUSTERING
# =============================================================================
# Treina os modelos de clustering UMA VEZ e salva para uso na API

import pandas as pd
import numpy as np
import warnings
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans
from sklearn.decomposition import PCA
from sklearn.metrics import silhouette_score
import joblib
import pickle
import os

warnings.filterwarnings('ignore')

ARTIFACTS_PATH = 'ml_artifacts'
os.makedirs(ARTIFACTS_PATH, exist_ok=True)

print("=" * 100)
print("üß¨ TREINAMENTO DE CLUSTERING - AN√ÅLISE DE PERFIS".center(100))
print("=" * 100)

# =============================================================================
# CARREGAMENTO DOS DADOS
# =============================================================================

df_raw = pd.read_excel('JogadoresV3.xlsx')
df = df_raw.copy()

print(f"\n‚úÖ Dados carregados: {len(df)} linhas")

# Converter F0103
if 'F0103' in df.columns:
    df['F0103'] = pd.to_numeric(df['F0103'].astype(str).str.replace(',', '.'), errors='coerce')

# Identificar colunas
p_cols = [c for c in df.columns if c.startswith('P') and any(char.isdigit() for char in c)]
t_cols = [c for c in df.columns if c.startswith('T') and any(char.isdigit() for char in c)]
f_cols = [c for c in df.columns if c.startswith('F') and len(c) > 1 and any(char.isdigit() for char in c)]

print(f"\nüìä Colunas identificadas:")
print(f"  ‚Ä¢ Performance (P): {len(p_cols)}")
print(f"  ‚Ä¢ Tempo (T): {len(t_cols)}")
print(f"  ‚Ä¢ Formul√°rios (F): {len(f_cols)}")

# =============================================================================
# PR√â-PROCESSAMENTO
# =============================================================================

print("\nüîß Pr√©-processamento...")

# Tratar valores -1 e NaN
for col in p_cols + t_cols + f_cols:
    if col in df.columns:
        df[col] = pd.to_numeric(df[col], errors='coerce').replace(-1, np.nan)
        if df[col].isnull().sum() > 0:
            df[col].fillna(df[col].median(), inplace=True)

# Criar features para clustering
df['P_mean'] = df[p_cols].mean(axis=1)
df['P_std'] = df[p_cols].std(axis=1)
df['P_max'] = df[p_cols].max(axis=1)
df['T_mean'] = df[t_cols].mean(axis=1)
df['T_total'] = df[t_cols].sum(axis=1)

f_sono = [c for c in f_cols if c.startswith('F07')]
if f_sono:
    df['F_sono_mean'] = df[f_sono].mean(axis=1)

f_final = [c for c in f_cols if c.startswith('F11')]
if f_final:
    df['F_final_mean'] = df[f_final].mean(axis=1)

# Features selecionadas
cluster_features = ['P_mean', 'P_std', 'T_mean', 'F_sono_mean', 'F_final_mean']
cluster_features = [f for f in cluster_features if f in df.columns]

print(f"  ‚úÖ {len(cluster_features)} features criadas: {cluster_features}")

X_cluster = df[cluster_features].fillna(df[cluster_features].median())

# =============================================================================
# NORMALIZA√á√ÉO
# =============================================================================

print("\nüìè Normalizando dados...")

scaler = StandardScaler()
X_scaled = scaler.fit_transform(X_cluster)

print("  ‚úÖ Scaler treinado")

# =============================================================================
# CLUSTERING (K-MEANS)
# =============================================================================

print("\nüéØ Treinando K-Means (2 clusters)...")

kmeans = KMeans(n_clusters=2, random_state=42, n_init=20, max_iter=300)
clusters = kmeans.fit_predict(X_scaled)

silhouette = silhouette_score(X_scaled, clusters)

print(f"  ‚úÖ K-Means treinado")
print(f"  üìä Silhouette Score: {silhouette:.3f}")

# Nomear clusters baseado em performance m√©dia
cluster_0_p_mean = df[clusters == 0]['P_mean'].mean()
cluster_1_p_mean = df[clusters == 1]['P_mean'].mean()

if cluster_0_p_mean > cluster_1_p_mean:
    cluster_names = {0: "Alto Desempenho", 1: "Iniciante"}
else:
    cluster_names = {1: "Alto Desempenho", 0: "Iniciante"}

print(f"\nüìã Clusters identificados:")
for cluster_id in [0, 1]:
    mask = clusters == cluster_id
    count = np.sum(mask)
    percentage = count / len(clusters) * 100
    print(f"  ‚Ä¢ Cluster {cluster_id} ({cluster_names[cluster_id]}): {count} jogadores ({percentage:.1f}%)")

# =============================================================================
# PCA (VISUALIZA√á√ÉO)
# =============================================================================

print("\nüî¨ Treinando PCA (2 componentes)...")

pca = PCA(n_components=2)
X_pca = pca.fit_transform(X_scaled)

variance_explained = pca.explained_variance_ratio_

print(f"  ‚úÖ PCA treinado")
print(f"  üìä Vari√¢ncia explicada:")
print(f"     - PC1: {variance_explained[0]*100:.1f}%")
print(f"     - PC2: {variance_explained[1]*100:.1f}%")
print(f"     - Total: {sum(variance_explained)*100:.1f}%")

# =============================================================================
# SALVAR ARTEFATOS
# =============================================================================

print("\nüíæ Salvando artefatos...")

# 1. Modelo K-Means
joblib.dump(kmeans, f'{ARTIFACTS_PATH}/kmeans_model.pkl')
print(f"  ‚úÖ K-Means salvo: {ARTIFACTS_PATH}/kmeans_model.pkl")

# 2. Modelo PCA
joblib.dump(pca, f'{ARTIFACTS_PATH}/pca_model.pkl')
print(f"  ‚úÖ PCA salvo: {ARTIFACTS_PATH}/pca_model.pkl")

# 3. Scaler
joblib.dump(scaler, f'{ARTIFACTS_PATH}/scaler_cluster.pkl')
print(f"  ‚úÖ Scaler salvo: {ARTIFACTS_PATH}/scaler_cluster.pkl")

# 4. Lista de features
with open(f'{ARTIFACTS_PATH}/cluster_features.pkl', 'wb') as f:
    pickle.dump(cluster_features, f)
print(f"  ‚úÖ Features salvas: {ARTIFACTS_PATH}/cluster_features.pkl")

# 5. Nomes dos clusters
with open(f'{ARTIFACTS_PATH}/cluster_names.pkl', 'wb') as f:
    pickle.dump(cluster_names, f)
print(f"  ‚úÖ Nomes dos clusters salvos: {ARTIFACTS_PATH}/cluster_names.pkl")

print("\n" + "=" * 100)
print("‚úÖ CLUSTERING - ARTEFATOS SALVOS COM SUCESSO!".center(100))
print("=" * 100)

print(f"\nüì¶ Arquivos gerados em: {ARTIFACTS_PATH}/")
print(f"  ‚Ä¢ kmeans_model.pkl")
print(f"  ‚Ä¢ pca_model.pkl")
print(f"  ‚Ä¢ scaler_cluster.pkl")
print(f"  ‚Ä¢ cluster_features.pkl")
print(f"  ‚Ä¢ cluster_names.pkl")

print("\nüí° Pr√≥ximo passo: Adicionar o carregamento desses artefatos no main.py")
</file>

<file path="export_hibrido_target1.py">
# =============================================================================
# EXPORT H√çBRIDO - TARGET 1 (R1)
# =============================================================================
# Este script replica a SE√á√ÉO 2 do notebook h√≠brido definitivo
# Treina o modelo R1 e salva os artefatos necess√°rios para a API

import pandas as pd
import numpy as np
import warnings
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.preprocessing import RobustScaler
from sklearn.feature_selection import VarianceThreshold
from catboost import CatBoostRegressor
import optuna
import joblib
import pickle
import os

warnings.filterwarnings('ignore')
optuna.logging.set_verbosity(optuna.logging.WARNING)

# Configura√ß√£o de caminhos
ARTIFACTS_PATH = 'ml_artifacts'
os.makedirs(ARTIFACTS_PATH, exist_ok=True)

print("=" * 100)
print("üéØ TREINAMENTO TARGET 1 (R1) - MODELO H√çBRIDO".center(100))
print("=" * 100)

# =============================================================================
# CARREGAMENTO E PR√â-PROCESSAMENTO
# =============================================================================

df_raw = pd.read_excel('JogadoresV3.xlsx')
df = df_raw.copy()

print(f"\n‚úÖ Dados carregados: {len(df)} linhas")

# Converter F0103
if 'F0103' in df.columns:
    df['F0103'] = pd.to_numeric(df['F0103'].astype(str).str.replace(',', '.'), errors='coerce')

# Identificar colunas P, T, F
p_cols = [col for col in df.columns if col.startswith('P') and any(c.isdigit() for c in col)]
t_cols = [col for col in df.columns if col.startswith('T') and any(c.isdigit() for c in col)]
f_cols = [col for col in df.columns if col.startswith('F') and len(col) > 1 and any(c.isdigit() for c in col)]

# Tratar colunas duplicadas
print("\n[1/6] Tratando colunas duplicadas...")
cols = pd.Series(df.columns)
duplicated_cols = cols[cols.duplicated()].unique()

if len(duplicated_cols) > 0:
    for dup in duplicated_cols:
        indices = cols[cols == dup].index.tolist()
        for i, idx in enumerate(indices):
            cols.iloc[idx] = f'{dup}_{i}'
    df.columns = cols
    # Atualizar listas de colunas
    p_cols = [col for col in df.columns if col.startswith('P') and any(c.isdigit() for c in col)]
    t_cols = [col for col in df.columns if col.startswith('T') and any(c.isdigit() for c in col)]
    f_cols = [col for col in df.columns if col.startswith('F') and len(col) > 1 and any(c.isdigit() for c in col)]
    print(f"  ‚úÖ Colunas duplicadas renomeadas")
else:
    print("  ‚úÖ Sem duplicatas")

# Converter para num√©rico
for col in p_cols + t_cols + f_cols:
    if col in df.columns:
        df[col] = pd.to_numeric(df[col], errors='coerce')

# Remover outliers extremos
numeric_cols = [col for col in df.select_dtypes(include=[np.number]).columns if 'Target' not in col]
for col in numeric_cols:
    if col in df.columns:
        df.loc[df[col] < -100, col] = np.nan
        if df[col].max() > 10000:
            df.loc[df[col] > 10000, col] = np.nan

# =============================================================================
# FEATURE ENGINEERING
# =============================================================================

print("\n[2/6] Criando features comportamentais...")

# Taxa de pulos (-1)
p_minus_ones = sum((df[col] == -1).sum() for col in p_cols if col in df.columns)
t_minus_ones = sum((df[col] == -1).sum() for col in t_cols if col in df.columns)

df['taxa_pulos_P'] = p_minus_ones / len(p_cols) if len(p_cols) > 0 else 0
df['taxa_pulos_T'] = t_minus_ones / len(t_cols) if len(t_cols) > 0 else 0
df['taxa_pulos_geral'] = (p_minus_ones + t_minus_ones) / (len(p_cols) + len(t_cols))

# Substituir -1 por NaN e preencher com mediana
for col in p_cols + t_cols + f_cols:
    if col in df.columns:
        df[col] = df[col].replace(-1, np.nan)
        df[col] = df[col].replace(-1.0, np.nan)
        if df[col].isnull().sum() > 0:
            df[col].fillna(df[col].median(), inplace=True)

print("\n[3/6] Feature engineering avan√ßado...")

# Features de SONO
if 'QtdHorasDormi' in df.columns and 'Acordar' in df.columns:
    df['sono_total'] = df['QtdHorasDormi']
    df['sono_x_acordar'] = df['QtdHorasDormi'] * df['Acordar']
    df['sono_squared'] = df['QtdHorasDormi'] ** 2
    df['sono_irregular'] = np.abs(df['QtdHorasDormi'] - df['QtdHorasDormi'].median())
    print(f"  ‚úÖ Sono: 4 features")

# Features de PERFORMANCE
if len(p_cols) > 0:
    df['P_mean'] = df[p_cols].mean(axis=1)
    df['P_std'] = df[p_cols].std(axis=1)
    df['P_min'] = df[p_cols].min(axis=1)
    df['P_max'] = df[p_cols].max(axis=1)
    df['P_range'] = df['P_max'] - df['P_min']
    df['P_late'] = df[['P09', 'P12', 'P13', 'P15']].mean(axis=1) if all(c in df.columns for c in ['P09', 'P12', 'P13', 'P15']) else 0
    df['P_early'] = df[['P01', 'P02', 'P03', 'P04']].mean(axis=1) if all(c in df.columns for c in ['P01', 'P02', 'P03', 'P04']) else 0
    print(f"  ‚úÖ Performance: 7 features")

# Features de TEMPO
if len(t_cols) > 0:
    df['T_mean'] = df[t_cols].mean(axis=1)
    df['T_std'] = df[t_cols].std(axis=1)
    df['T_min'] = df[t_cols].min(axis=1)
    df['T_max'] = df[t_cols].max(axis=1)
    print(f"  ‚úÖ Tempo: 4 features")

# Features de FORMUL√ÅRIOS
f_perfil = [c for c in f_cols if c.startswith('F01') or c.startswith('F02')]
if len(f_perfil) > 0:
    df['F_perfil_mean'] = df[f_perfil].mean(axis=1)
    df['F_perfil_std'] = df[f_perfil].std(axis=1)

f_sono = [c for c in f_cols if c.startswith('F07')]
if len(f_sono) > 0:
    df['F_sono_mean'] = df[f_sono].mean(axis=1)
    df['F_sono_std'] = df[f_sono].std(axis=1)

f_final = [c for c in f_cols if c.startswith('F11')]
if len(f_final) > 0:
    df['F_final_mean'] = df[f_final].mean(axis=1)
    df['F_final_std'] = df[f_final].std(axis=1)

df['F_mean_geral'] = df[f_cols].mean(axis=1)

# =============================================================================
# SELE√á√ÉO DE FEATURES
# =============================================================================

print("\n[4/6] Selecionando TOP features...")

TARGET = 'Target1'
feature_cols = [col for col in df.columns if col not in [TARGET, 'C√≥digo de Acesso', 'Data/Hora √öltimo', 'Target2', 'Target3']
                and pd.api.types.is_numeric_dtype(df[col])]

X = df[feature_cols].fillna(0)
y = df[TARGET]

# Variance Threshold
selector = VarianceThreshold(threshold=0.01)
selector.fit(X)
feature_cols = X.columns[selector.get_support()].tolist()
X = df[feature_cols]

# Correla√ß√£o com target
correlations = []
for col in feature_cols:
    corr = abs(df[col].corr(df[TARGET]))
    if not np.isnan(corr):
        correlations.append((col, corr))

correlations.sort(key=lambda x: x[1], reverse=True)

# TOP 30 features
TOP_K = min(30, len(correlations))
selected_features_r1 = [col for col, _ in correlations[:TOP_K]]

print(f"  ‚úÖ {TOP_K} features selecionadas")

# Criar intera√ß√µes entre TOP 3
top3_features = [col for col, _ in correlations[:3]]
interaction_features = []

for i, f1 in enumerate(top3_features):
    for f2 in top3_features[i+1:]:
        interaction_name = f'{f1}_X_{f2}'
        df[interaction_name] = df[f1] * df[f2]
        interaction_features.append(interaction_name)

selected_features_r1.extend(interaction_features)
selected_features_r1 = list(dict.fromkeys(selected_features_r1))

print(f"  Total com intera√ß√µes: {len(selected_features_r1)}")

# =============================================================================
# PREPARA√á√ÉO DOS DADOS
# =============================================================================

print("\n[5/6] Preparando dados para treinamento...")

# Scaler
scaler_r1 = RobustScaler()
X_final = df[selected_features_r1].copy().fillna(0)
X_scaled = scaler_r1.fit_transform(X_final)

X_r1 = X_scaled
y_r1 = df[TARGET].values

# Remover NaNs
valid_idx = ~np.isnan(y_r1)
X_r1 = X_r1[valid_idx]
y_r1 = y_r1[valid_idx]

# Split
X_train_r1, X_test_r1, y_train_r1, y_test_r1 = train_test_split(X_r1, y_r1, test_size=0.25, random_state=42)

print(f"  Treino: {len(X_train_r1)} | Teste: {len(X_test_r1)}")

# =============================================================================
# OTIMIZA√á√ÉO E TREINAMENTO
# =============================================================================

print("\n[6/6] Otimizando hiperpar√¢metros (100 trials)...")

def objective_r1(trial):
    params = {
        'iterations': 500,
        'learning_rate': trial.suggest_float('learning_rate', 0.01, 0.1, log=True),
        'depth': trial.suggest_int('depth', 3, 6),
        'l2_leaf_reg': trial.suggest_float('l2_leaf_reg', 10, 100, log=True),
        'border_count': trial.suggest_int('border_count', 32, 128),
        'bagging_temperature': trial.suggest_float('bagging_temperature', 0.5, 1.0),
        'random_strength': trial.suggest_float('random_strength', 0.5, 2.0),
        'verbose': False,
        'random_seed': 42
    }
    model = CatBoostRegressor(**params)
    scores = cross_val_score(model, X_train_r1, y_train_r1, cv=5, scoring='r2')
    return scores.mean()

study_r1 = optuna.create_study(direction='maximize')
study_r1.optimize(objective_r1, n_trials=100, show_progress_bar=True)

best_params_r1 = study_r1.best_params
best_params_r1['iterations'] = 500
best_params_r1['verbose'] = False
best_params_r1['random_seed'] = 42

print(f"\n‚úÖ Melhor R¬≤ CV: {study_r1.best_value:.4f}")

# Treinar modelo final
print("\nüîß Treinando modelo final...")
model_r1 = CatBoostRegressor(**best_params_r1)
model_r1.fit(X_train_r1, y_train_r1, verbose=False)

# =============================================================================
# SALVAR ARTEFATOS
# =============================================================================

print("\nüíæ Salvando artefatos...")

# Salvar modelo
joblib.dump(model_r1, f'{ARTIFACTS_PATH}/modelo_target1.pkl')
print(f"  ‚úÖ Modelo salvo: {ARTIFACTS_PATH}/modelo_target1.pkl")

# Salvar scaler
joblib.dump(scaler_r1, f'{ARTIFACTS_PATH}/scaler_target1.pkl')
print(f"  ‚úÖ Scaler salvo: {ARTIFACTS_PATH}/scaler_target1.pkl")

# Salvar lista de features
with open(f'{ARTIFACTS_PATH}/features_target1.pkl', 'wb') as f:
    pickle.dump(selected_features_r1, f)
print(f"  ‚úÖ Features salvas: {ARTIFACTS_PATH}/features_target1.pkl")

print("\n" + "=" * 100)
print("‚úÖ TARGET 1 (R1) - TREINAMENTO COMPLETO!".center(100))
print("=" * 100)
print(f"\nüì¶ Artefatos salvos em: {ARTIFACTS_PATH}/")
print(f"  ‚Ä¢ modelo_target1.pkl")
print(f"  ‚Ä¢ scaler_target1.pkl")
print(f"  ‚Ä¢ features_target1.pkl")
</file>

<file path="export_hibrido_target2.py">
# =============================================================================
# EXPORT H√çBRIDO - TARGET 2 (R2)
# =============================================================================
# Este script replica a SE√á√ÉO 3 do notebook h√≠brido definitivo (CORRIGIDO!)
# Treina o ENSEMBLE de 3 modelos R2 e salva os artefatos necess√°rios para a API

import pandas as pd
import numpy as np
import warnings
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.preprocessing import QuantileTransformer
from sklearn.feature_selection import VarianceThreshold
from catboost import CatBoostRegressor
import optuna
import joblib
import pickle
import os

warnings.filterwarnings('ignore')
optuna.logging.set_verbosity(optuna.logging.WARNING)

# Configura√ß√£o de caminhos
ARTIFACTS_PATH = 'ml_artifacts'
os.makedirs(ARTIFACTS_PATH, exist_ok=True)

print("=" * 100)
print("üéØ TREINAMENTO TARGET 2 (R2) - ENSEMBLE H√çBRIDO CORRIGIDO".center(100))
print("=" * 100)

# =============================================================================
# CARREGAMENTO E PR√â-PROCESSAMENTO
# =============================================================================

df_raw = pd.read_excel('JogadoresV3.xlsx')
df = df_raw.copy()

TARGET = 'Target2'

print(f"\n‚úÖ Dados carregados: {len(df)} linhas")

# Converter F0103
if 'F0103' in df.columns:
    df['F0103'] = pd.to_numeric(df['F0103'].astype(str).str.replace(',', '.'), errors='coerce')

# Identificar colunas P, T, F
p_cols = [col for col in df.columns if col.startswith('P') and any(c.isdigit() for c in col)]
t_cols = [col for col in df.columns if col.startswith('T') and any(c.isdigit() for c in col)]
f_cols = [col for col in df.columns if col.startswith('F') and len(col) > 1 and any(c.isdigit() for c in col)]

print("\n[1/5] Tratando valores -1 e NaN...")

# Converter para num√©rico e tratar -1
for col in p_cols + t_cols + f_cols:
    if col in df.columns:
        df[col] = pd.to_numeric(df[col], errors='coerce')
        df[col] = df[col].replace(-1, np.nan)
        if df[col].isnull().sum() > 0:
            df[col].fillna(df[col].median(), inplace=True)

# =============================================================================
# FEATURE ENGINEERING MINIMALISTA
# =============================================================================

print("\n[2/5] Criando features minimalistas para R2...")

# Features de sono
if 'QtdHorasDormi' in df.columns and 'Acordar' in df.columns:
    df['sono_total'] = df['QtdHorasDormi']
    df['acordar'] = df['Acordar']

# Features de formul√°rio sono
f_sono = [c for c in f_cols if c.startswith('F07')]
if len(f_sono) > 0:
    df['F_sono_mean'] = df[f_sono].mean(axis=1)

# Features de formul√°rio final
f_final = [c for c in f_cols if c.startswith('F11')]
if len(f_final) > 0:
    df['F_final_mean'] = df[f_final].mean(axis=1)

# Features de performance
p_cols_exist = [c for c in p_cols if c in df.columns]
if len(p_cols_exist) > 0:
    df['P_mean'] = df[p_cols_exist].mean(axis=1)

# Preencher NaN remanescentes
numeric_cols = df.select_dtypes(include=np.number).columns
for col in numeric_cols:
    if df[col].isnull().sum() > 0:
        df[col].fillna(df[col].median(), inplace=True)

# =============================================================================
# SELE√á√ÉO DE FEATURES CONSERVADORA
# =============================================================================

print("\n[3/5] Sele√ß√£o conservadora (‚â§12 features)...")

feature_cols = [col for col in df.columns if col not in [TARGET, 'C√≥digo de Acesso', 'Data/Hora √öltimo', 'Target1', 'Target3']
                and pd.api.types.is_numeric_dtype(df[col])]

X_pre = df[feature_cols].fillna(0)
y = df[TARGET]

# Variance Threshold
selector = VarianceThreshold(threshold=0.01)
selector.fit(X_pre)
feature_cols_filtered = X_pre.columns[selector.get_support()].tolist()

# Correla√ß√£o com target
correlations = []
for col in feature_cols_filtered:
    corr = df[col].corr(df[TARGET])
    if not np.isnan(corr):
        correlations.append((col, abs(corr)))

correlations.sort(key=lambda x: x[1], reverse=True)

# TOP 12 features
MAX_FEATURES = 12
selected_features_r2 = [col for col, _ in correlations[:MAX_FEATURES]]

print(f"  ‚úÖ {len(selected_features_r2)} features selecionadas")

# Criar uma intera√ß√£o entre TOP 2
if len(selected_features_r2) >= 2:
    f1, f2 = selected_features_r2[0], selected_features_r2[1]
    df[f'{f1}_X_{f2}'] = df[f1] * df[f2]
    selected_features_r2.append(f'{f1}_X_{f2}')

# =============================================================================
# PREPARA√á√ÉO DOS DADOS
# =============================================================================

print("\n[4/5] Preparando dados...")

X_r2 = df[selected_features_r2].copy()
y_r2 = df[TARGET].values

# Remover NaNs
valid_idx = ~np.isnan(y_r2)
X_r2 = X_r2[valid_idx]
y_r2 = y_r2[valid_idx]

print(f"  Dados: {len(X_r2)} amostras √ó {len(selected_features_r2)} features")

# =============================================================================
# OTIMIZA√á√ÉO
# =============================================================================

print("\n[5/5] Otimiza√ß√£o brutal (150 trials)...")

def objective_r2(trial):
    params = {
        'iterations': trial.suggest_int('iterations', 300, 700),
        'learning_rate': trial.suggest_float('learning_rate', 0.001, 0.03, log=True),
        'depth': trial.suggest_int('depth', 2, 3),
        'l2_leaf_reg': trial.suggest_float('l2_leaf_reg', 50, 300, log=True),
        'border_count': trial.suggest_int('border_count', 16, 48),
        'bagging_temperature': trial.suggest_float('bagging_temperature', 0.0, 0.5),
        'random_strength': trial.suggest_float('random_strength', 2.0, 5.0),
        'min_data_in_leaf': trial.suggest_int('min_data_in_leaf', 5, 15),
        'verbose': False,
        'random_seed': 42
    }

    X_tr_opt, X_te_opt, y_tr_opt, y_te_opt = train_test_split(X_r2, y_r2, test_size=0.25, random_state=42)
    scaler_temp = QuantileTransformer(output_distribution='normal', random_state=42)
    X_tr_scaled = scaler_temp.fit_transform(X_tr_opt)

    model = CatBoostRegressor(**params)
    scores = cross_val_score(model, X_tr_scaled, y_tr_opt, cv=5, scoring='r2')
    return scores.mean()

study_r2 = optuna.create_study(direction='maximize')
study_r2.optimize(objective_r2, n_trials=150, show_progress_bar=True)

best_params_r2 = study_r2.best_params
best_params_r2['verbose'] = False
best_params_r2['random_seed'] = 42

print(f"\n‚úÖ Melhor R¬≤ CV: {study_r2.best_value:.4f}")

# =============================================================================
# TREINAMENTO DO ENSEMBLE (3 MODELOS) - VERS√ÉO CORRIGIDA
# =============================================================================

print("\nüöÄ Treinando ensemble (3 modelos)...")
print("  ‚úÖ Cada modelo treina com seed diferente (diversidade)")

# SPLIT BASE COMUM (para consist√™ncia do scaler)
X_train_base, X_test_base, y_train_base, y_test_base = train_test_split(
    X_r2, y_r2, test_size=0.25, random_state=42
)

# SCALER BASE COMUM
scaler_base = QuantileTransformer(output_distribution='normal', random_state=42)
X_train_base_scaled = scaler_base.fit_transform(X_train_base)
X_test_base_scaled = scaler_base.transform(X_test_base)

models_r2 = []

for i, seed in enumerate([42, 123, 456], 1):
    print(f"\n  Treinando Modelo {i} (seed={seed})...")
    
    # Cada modelo treina com seed diferente para diversidade
    X_tr_div, X_te_div, y_tr_div, y_te_div = train_test_split(X_r2, y_r2, test_size=0.25, random_state=seed)
    scaler_div = QuantileTransformer(output_distribution='normal', random_state=42)
    X_tr_div_scaled = scaler_div.fit_transform(X_tr_div)
    
    # Treinar modelo
    params_i = best_params_r2.copy()
    params_i['random_seed'] = seed
    model_i = CatBoostRegressor(**params_i)
    model_i.fit(X_tr_div_scaled, y_tr_div, verbose=False)
    
    models_r2.append(model_i)
    print(f"  ‚úÖ Modelo {i} treinado!")

# =============================================================================
# SALVAR ARTEFATOS
# =============================================================================

print("\nüíæ Salvando artefatos...")

# Salvar os 3 modelos do ensemble
for i, model in enumerate(models_r2):
    joblib.dump(model, f'{ARTIFACTS_PATH}/modelo_target2_ensemble_{i}.pkl')
    print(f"  ‚úÖ Modelo {i+1} salvo: {ARTIFACTS_PATH}/modelo_target2_ensemble_{i}.pkl")

# Salvar o scaler (QuantileTransformer)
joblib.dump(scaler_base, f'{ARTIFACTS_PATH}/scaler_target2.pkl')
print(f"  ‚úÖ Scaler salvo: {ARTIFACTS_PATH}/scaler_target2.pkl")

# Salvar a lista de features
with open(f'{ARTIFACTS_PATH}/features_target2.pkl', 'wb') as f:
    pickle.dump(selected_features_r2, f)
print(f"  ‚úÖ Features salvas: {ARTIFACTS_PATH}/features_target2.pkl")

print("\n" + "=" * 100)
print("‚úÖ TARGET 2 (R2) - ENSEMBLE COMPLETO!".center(100))
print("=" * 100)
print(f"\nüì¶ Artefatos salvos em: {ARTIFACTS_PATH}/")
print(f"  ‚Ä¢ modelo_target2_ensemble_0.pkl")
print(f"  ‚Ä¢ modelo_target2_ensemble_1.pkl")
print(f"  ‚Ä¢ modelo_target2_ensemble_2.pkl")
print(f"  ‚Ä¢ scaler_target2.pkl (QuantileTransformer)")
print(f"  ‚Ä¢ features_target2.pkl")
print(f"\nüí° NOTA: A API far√° a m√©dia das predi√ß√µes dos 3 modelos")
</file>

<file path="export_hibrido_target3.py">
# =============================================================================
# EXPORT H√çBRIDO - TARGET 3 (R3)
# =============================================================================
# Este script replica a SE√á√ÉO 4 do notebook h√≠brido definitivo (CORRIGIDO!)
# Treina o ENSEMBLE de 3 modelos R3 e salva os artefatos necess√°rios para a API

import pandas as pd
import numpy as np
import warnings
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.preprocessing import RobustScaler
from catboost import CatBoostRegressor
import optuna
import joblib
import pickle
import os

warnings.filterwarnings('ignore')
optuna.logging.set_verbosity(optuna.logging.WARNING)

# Configura√ß√£o de caminhos
ARTIFACTS_PATH = 'ml_artifacts'
os.makedirs(ARTIFACTS_PATH, exist_ok=True)

print("=" * 100)
print("üéØ TREINAMENTO TARGET 3 (R3) - ENSEMBLE H√çBRIDO CORRIGIDO".center(100))
print("=" * 100)

# =============================================================================
# CARREGAMENTO E PR√â-PROCESSAMENTO
# =============================================================================

df_raw = pd.read_excel('JogadoresV3.xlsx')
df = df_raw.copy()

TARGET = 'Target3'

print(f"\n‚úÖ Dados carregados: {len(df)} linhas")

# Converter F0103
if 'F0103' in df.columns:
    df['F0103'] = pd.to_numeric(df['F0103'].astype(str).str.replace(',', '.'), errors='coerce')

# Identificar colunas P, T, F
p_cols = [col for col in df.columns if col.startswith('P') and any(c.isdigit() for c in col)]
t_cols = [col for col in df.columns if col.startswith('T') and any(c.isdigit() for c in col)]
f_cols = [col for col in df.columns if col.startswith('F') and len(col) > 1 and any(c.isdigit() for c in col)]

print("\n[1/5] Tratando valores -1 e NaN...")

# Converter para num√©rico e tratar -1
for col in p_cols + t_cols + f_cols:
    if col in df.columns:
        df[col] = pd.to_numeric(df[col], errors='coerce')
        df[col] = df[col].replace(-1, np.nan)
        if df[col].isnull().sum() > 0:
            df[col].fillna(df[col].median(), inplace=True)

# =============================================================================
# FEATURE ENGINEERING
# =============================================================================

print("\n[2/5] Feature engineering para R3...")

# Features de Performance
df['P_mean'] = df[p_cols].mean(axis=1)
df['P_std'] = df[p_cols].std(axis=1)
df['P_late'] = df[['P09', 'P12', 'P13', 'P15']].mean(axis=1) if all(c in df.columns for c in ['P09', 'P12', 'P13', 'P15']) else 0
df['P_early'] = df[['P01', 'P02', 'P03', 'P04']].mean(axis=1) if all(c in df.columns for c in ['P01', 'P02', 'P03', 'P04']) else 0

# Features de Tempo
df['T_mean'] = df[t_cols].mean(axis=1)
df['T_std'] = df[t_cols].std(axis=1)

# Features de Sono
if 'QtdHorasSono' in df.columns:
    f_sono = [c for c in f_cols if '07' in c]
    df['F_sono_mean'] = df[f_sono].mean(axis=1)
    df['F_sono_std'] = df[f_sono].std(axis=1)
    df['F_sono_max'] = df[f_sono].max(axis=1)
    if 'Acordar' in df.columns:
        df['sono_x_acordar'] = df['QtdHorasSono'] * df['Acordar']
        df['acordar_squared'] = df['Acordar'] ** 2

# Features de Formul√°rio Final
f_final = [c for c in f_cols if '11' in c]
df['F_final_mean'] = df[f_final].mean(axis=1)

print("  ‚úÖ Features criadas!")

# =============================================================================
# SELE√á√ÉO DE FEATURES
# =============================================================================

print("\n[3/5] Sele√ß√£o TOP 15 features...")

# Pool de features com correla√ß√£o > 0.35
feature_pool = []
for col in df.columns:
    if col not in [TARGET, 'C√≥digo de Acesso', 'Target1', 'Target2'] and df[col].dtype in ['float64', 'int64']:
        corr = abs(df[col].corr(df[TARGET]))
        if not np.isnan(corr) and corr > 0.35:
            feature_pool.append((col, corr))

feature_pool.sort(key=lambda x: x[1], reverse=True)
selected_features_r3 = [f[0] for f in feature_pool[:15]]

print(f"  ‚úÖ {len(selected_features_r3)} features selecionadas")

# Criar intera√ß√£o
if 'F1103' in selected_features_r3 and 'P_mean' in selected_features_r3:
    df['F1103_X_P_mean'] = df['F1103'] * df['P_mean']
    selected_features_r3.append('F1103_X_P_mean')

# =============================================================================
# PREPARA√á√ÉO DOS DADOS
# =============================================================================

print("\n[4/5] Preparando dados...")

X_r3 = df[selected_features_r3].fillna(df[selected_features_r3].median())
y_r3 = df[TARGET].values

print(f"  Dados: {len(X_r3)} amostras √ó {len(selected_features_r3)} features")

# =============================================================================
# OTIMIZA√á√ÉO
# =============================================================================

print("\n[5/5] Otimiza√ß√£o (100 trials)...")

def objective_r3(trial):
    X_tr_opt, X_te_opt, y_tr_opt, y_te_opt = train_test_split(X_r3, y_r3, test_size=0.25, random_state=42)
    scaler_temp = RobustScaler()
    X_tr_scaled = scaler_temp.fit_transform(X_tr_opt)

    params = {
        'iterations': trial.suggest_int('iterations', 200, 800),
        'learning_rate': trial.suggest_float('learning_rate', 0.005, 0.05, log=True),
        'depth': 2,
        'l2_leaf_reg': trial.suggest_float('l2_leaf_reg', 120, 180),
        'border_count': trial.suggest_int('border_count', 16, 128),
        'bagging_temperature': trial.suggest_float('bagging_temperature', 0, 1),
        'random_strength': trial.suggest_float('random_strength', 0.5, 5),
        'min_data_in_leaf': trial.suggest_int('min_data_in_leaf', 8, 15),
        'random_seed': 42,
        'verbose': False
    }
    model = CatBoostRegressor(**params)
    scores = cross_val_score(model, X_tr_scaled, y_tr_opt, cv=3, scoring='r2')
    return scores.mean()

study_r3 = optuna.create_study(direction='maximize')
study_r3.optimize(objective_r3, n_trials=100, show_progress_bar=True)

best_params_r3 = study_r3.best_params
best_params_r3['depth'] = 2
best_params_r3['verbose'] = False
best_params_r3['random_seed'] = 42

print(f"\n‚úÖ Melhor R¬≤ CV: {study_r3.best_value:.4f}")

# =============================================================================
# TREINAMENTO DO ENSEMBLE (3 MODELOS) - VERS√ÉO CORRIGIDA
# =============================================================================

print("\nüöÄ Treinando ensemble (3 modelos)...")
print("  ‚úÖ Cada modelo treina com seed diferente (diversidade)")

# SPLIT BASE COMUM (para consist√™ncia do scaler)
X_train_base_r3, X_test_base_r3, y_train_base_r3, y_test_base_r3 = train_test_split(
    X_r3, y_r3, test_size=0.25, random_state=42
)

# SCALER BASE COMUM
scaler_base_r3 = RobustScaler()
X_train_base_r3_scaled = scaler_base_r3.fit_transform(X_train_base_r3)
X_test_base_r3_scaled = scaler_base_r3.transform(X_test_base_r3)

models_r3 = []

for i, seed in enumerate([42, 123, 456], 1):
    print(f"\n  Treinando Modelo {i} (seed={seed})...")
    
    # Cada modelo treina com seed diferente para diversidade
    X_tr_div, X_te_div, y_tr_div, y_te_div = train_test_split(X_r3, y_r3, test_size=0.25, random_state=seed)
    scaler_div = RobustScaler()
    X_tr_div_scaled = scaler_div.fit_transform(X_tr_div)
    
    # Treinar modelo
    params_i = best_params_r3.copy()
    params_i['random_seed'] = seed
    model_i = CatBoostRegressor(**params_i)
    model_i.fit(X_tr_div_scaled, y_tr_div, verbose=False)
    
    models_r3.append(model_i)
    print(f"  ‚úÖ Modelo {i} treinado!")

# =============================================================================
# SALVAR ARTEFATOS
# =============================================================================

print("\nüíæ Salvando artefatos...")

# Salvar os 3 modelos do ensemble
for i, model in enumerate(models_r3):
    joblib.dump(model, f'{ARTIFACTS_PATH}/modelo_target3_ensemble_{i}.pkl')
    print(f"  ‚úÖ Modelo {i+1} salvo: {ARTIFACTS_PATH}/modelo_target3_ensemble_{i}.pkl")

# Salvar o scaler (RobustScaler)
joblib.dump(scaler_base_r3, f'{ARTIFACTS_PATH}/scaler_target3.pkl')
print(f"  ‚úÖ Scaler salvo: {ARTIFACTS_PATH}/scaler_target3.pkl")

# Salvar a lista de features
with open(f'{ARTIFACTS_PATH}/features_target3.pkl', 'wb') as f:
    pickle.dump(selected_features_r3, f)
print(f"  ‚úÖ Features salvas: {ARTIFACTS_PATH}/features_target3.pkl")

print("\n" + "=" * 100)
print("‚úÖ TARGET 3 (R3) - ENSEMBLE COMPLETO!".center(100))
print("=" * 100)
print(f"\nüì¶ Artefatos salvos em: {ARTIFACTS_PATH}/")
print(f"  ‚Ä¢ modelo_target3_ensemble_0.pkl")
print(f"  ‚Ä¢ modelo_target3_ensemble_1.pkl")
print(f"  ‚Ä¢ modelo_target3_ensemble_2.pkl")
print(f"  ‚Ä¢ scaler_target3.pkl (RobustScaler)")
print(f"  ‚Ä¢ features_target3.pkl")
print(f"\nüí° NOTA: A API far√° a m√©dia das predi√ß√µes dos 3 modelos")
</file>

<file path="main.py">
# main.py (COM MODELO H√çBRIDO - VERS√ÉO FINAL)

import os
import pickle
import joblib
import pandas as pd
import numpy as np
import shap
from fastapi import FastAPI, Depends, HTTPException, UploadFile, File, status
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError
from sqlalchemy import func
import crud
import models
import schemas
import auth
import database
from sklearn.ensemble import StackingRegressor
from flask_bcrypt import Bcrypt
from core import app
from io import BytesIO
import warnings
from pandas.errors import SettingWithCopyWarning
warnings.simplefilter(action="ignore", category=FutureWarning)

# Cria tabelas no DB (se n√£o existirem) ao iniciar
try:
    models.Base.metadata.create_all(bind=database.engine)
except Exception as e:
    print(f"Aviso: N√£o foi poss√≠vel criar tabelas do DB na inicializa√ß√£o (pode ser normal se j√° existirem): {e}")

# --- Carregamento de Artefatos de ML (ATUALIZADO PARA MODELO H√çBRIDO) ---
ARTIFACTS_PATH = os.getenv('ARTIFACTS_PATH', 'ml_artifacts')
MODELS, SCALERS, FEATURES, EXPLAINERS = {}, {}, {}, {}

try:
    # Target 1 (modelo √∫nico - mant√©m compatibilidade)
    MODELS['target1'] = joblib.load(f"{ARTIFACTS_PATH}/modelo_target1.pkl")
    SCALERS['target1'] = joblib.load(f"{ARTIFACTS_PATH}/scaler_target1.pkl")
    with open(f"{ARTIFACTS_PATH}/features_target1.pkl", "rb") as f:
        FEATURES['target1'] = pickle.load(f)
    EXPLAINERS['target1'] = shap.TreeExplainer(MODELS['target1'])

    # Targets 2 e 3 (ensemble de 3 modelos cada - NOVA ESTRUTURA)
    for target in ['target2', 'target3']:
        MODELS[target] = []
        for i in range(3): # Carrega os 3 modelos do ensemble
            model = joblib.load(f"{ARTIFACTS_PATH}/modelo_{target}_ensemble_{i}.pkl")
            MODELS[target].append(model)
        
        SCALERS[target] = joblib.load(f"{ARTIFACTS_PATH}/scaler_{target}.pkl")
        with open(f"{ARTIFACTS_PATH}/features_{target}.pkl", "rb") as f:
            FEATURES[target] = pickle.load(f)
        
        # Cria um explainer para cada modelo do ensemble
        EXPLAINERS[target] = [shap.TreeExplainer(m) for m in MODELS[target]]

    print("‚úÖ Artefatos de ML e Explainers H√çBRIDOS carregados com sucesso.")
except Exception as e:
    print(f"‚ùå ERRO CR√çTICO ao carregar artefatos de ML: {e}")
    MODELS = None # Invalida para a verifica√ß√£o de sa√∫de da API

# --- Fun√ß√µes de Pr√©-processamento ATUALIZADAS (Modelo H√≠brido) ---

def preprocess_target1(df_input):
    """Pr√©-processamento espec√≠fico para Target 1 (modelo √∫nico)"""
    df = df_input.copy()
    
    # Convers√£o de F0103
    if 'F0103' in df.columns: 
        df['F0103'] = pd.to_numeric(df['F0103'].astype(str).str.replace(',', '.'), errors='coerce')
    
    # Identifica√ß√£o de colunas
    p_cols = [c for c in df.columns if c.startswith('P') and any(char.isdigit() for char in c)]
    t_cols = [c for c in df.columns if c.startswith('T') and any(char.isdigit() for char in c)]
    f_cols = [c for c in df.columns if c.startswith('F') and len(c) > 1 and any(char.isdigit() for char in c)]
    
    # Engenharia de features - taxas de pulos
    p_minus_ones = sum((df[col] == -1).sum() for col in p_cols if col in df.columns)
    t_minus_ones = sum((df[col] == -1).sum() for col in t_cols if col in df.columns)
    df['taxa_pulos_P'] = p_minus_ones / len(p_cols) if len(p_cols) > 0 else 0
    df['taxa_pulos_T'] = t_minus_ones / len(t_cols) if len(t_cols) > 0 else 0
    df['taxa_pulos_geral'] = (p_minus_ones + t_minus_ones) / (len(p_cols) + len(t_cols)) if (len(p_cols) + len(t_cols)) > 0 else 0

    # Processamento de colunas num√©ricas
    for col in p_cols + t_cols + f_cols:
        if col in df.columns:
            df[col] = pd.to_numeric(df[col], errors='coerce').replace(-1, np.nan)
            df[col].fillna(df[col].median(), inplace=True)
            
    # Features de sono
    if 'QtdHorasDormi' in df.columns and 'Acordar' in df.columns:
        df['sono_total'] = df['QtdHorasDormi']
        df['sono_x_acordar'] = df['QtdHorasDormi'] * df['Acordar']
        df['sono_squared'] = df['QtdHorasDormi'] ** 2
        df['sono_irregular'] = np.abs(df['QtdHorasDormi'] - df['QtdHorasDormi'].median())

    # Estat√≠sticas das colunas P
    if p_cols: 
        df['P_mean'] = df[p_cols].mean(axis=1)
        df['P_std'] = df[p_cols].std(axis=1)
        df['P_min'] = df[p_cols].min(axis=1)
        df['P_max'] = df[p_cols].max(axis=1)
        df['P_range'] = df['P_max'] - df['P_min']
        df['P_late'] = df[['P09', 'P12', 'P13', 'P15']].mean(axis=1) if all(c in df.columns for c in ['P09', 'P12', 'P13', 'P15']) else 0
        df['P_early'] = df[['P01', 'P02', 'P03', 'P04']].mean(axis=1) if all(c in df.columns for c in ['P01', 'P02', 'P03', 'P04']) else 0
    
    # Estat√≠sticas das colunas T
    if t_cols: 
        df['T_mean'] = df[t_cols].mean(axis=1)
        df['T_std'] = df[t_cols].std(axis=1)
        df['T_min'] = df[t_cols].min(axis=1)
        df['T_max'] = df[t_cols].max(axis=1)
        
    # Features espec√≠ficas das colunas F
    f_perfil = [c for c in f_cols if c.startswith('F01') or c.startswith('F02')]
    if f_perfil: 
        df['F_perfil_mean'] = df[f_perfil].mean(axis=1)
        df['F_perfil_std'] = df[f_perfil].std(axis=1)

    f_sono = [c for c in f_cols if c.startswith('F07')]
    if f_sono: 
        df['F_sono_mean'] = df[f_sono].mean(axis=1)
        df['F_sono_std'] = df[f_sono].std(axis=1)
    
    f_final = [c for c in f_cols if c.startswith('F11')]
    if f_final: 
        df['F_final_mean'] = df[f_final].mean(axis=1)
        df['F_final_std'] = df[f_final].std(axis=1)

    df['F_mean_geral'] = df[f_cols].mean(axis=1)

    # Intera√ß√µes entre as top 3 features
    top3 = [f for f in FEATURES['target1'] if '_X_' not in f][:3]
    for i, f1 in enumerate(top3):
        for f2 in top3[i+1:]:
            df[f'{f1}_X_{f2}'] = df.get(f1, 0) * df.get(f2, 0)
    
    # Garante todas as features esperadas pelo modelo
    df_final = df.reindex(columns=FEATURES['target1'], fill_value=0)
    return SCALERS['target1'].transform(df_final)

def preprocess_target2(df_input):
    """Pr√©-processamento espec√≠fico para Target 2 (ensemble)"""
    df = df_input.copy()
    
    if 'F0103' in df.columns: 
        df['F0103'] = pd.to_numeric(df['F0103'].astype(str).str.replace(',', '.'), errors='coerce')
    
    # Identifica√ß√£o de colunas
    p_cols = [c for c in df.columns if c.startswith('P') and any(char.isdigit() for char in c)]
    t_cols = [c for c in df.columns if c.startswith('T') and any(char.isdigit() for char in c)]
    f_cols = [c for c in df.columns if c.startswith('F') and len(c) > 1 and any(char.isdigit() for char in c)]

    # Processamento de colunas num√©ricas
    for col in p_cols + t_cols + f_cols:
        if col in df.columns:
            df[col] = pd.to_numeric(df[col], errors='coerce').replace(-1, np.nan)
            df[col].fillna(df[col].median(), inplace=True)
            
    # Features b√°sicas de sono
    if 'QtdHorasDormi' in df.columns and 'Acordar' in df.columns:
        df['sono_total'] = df['QtdHorasDormi']
        df['acordar'] = df['Acordar']

    # M√©dias espec√≠ficas
    f_sono = [c for c in f_cols if c.startswith('F07')]
    if f_sono: 
        df['F_sono_mean'] = df[f_sono].mean(axis=1)

    f_final = [c for c in f_cols if c.startswith('F11')]
    if f_final: 
        df['F_final_mean'] = df[f_final].mean(axis=1)

    if p_cols: 
        df['P_mean'] = df[p_cols].mean(axis=1)
    
    # Intera√ß√£o entre as duas principais features
    base_features = [f for f in FEATURES['target2'] if '_X_' not in f]
    if len(base_features) >= 2:
        f1, f2 = base_features[0], base_features[1]
        interaction_name = f'{f1}_X_{f2}'
        if interaction_name in FEATURES['target2']:
            df[interaction_name] = df[f1] * df[f2]

    # Garante todas as features esperadas pelo modelo
    df_final = df.reindex(columns=FEATURES['target2'], fill_value=0)
    return SCALERS['target2'].transform(df_final)

def preprocess_target3(df_input):
    """Pr√©-processamento espec√≠fico para Target 3 (ensemble)"""
    df = df_input.copy()

    if 'F0103' in df.columns: 
        df['F0103'] = pd.to_numeric(df['F0103'].astype(str).str.replace(',', '.'), errors='coerce')

    # Identifica√ß√£o de colunas
    p_cols = [c for c in df.columns if c.startswith('P') and any(char.isdigit() for char in c)]
    t_cols = [c for c in df.columns if c.startswith('T') and any(char.isdigit() for char in c)]
    f_cols = [c for c in df.columns if c.startswith('F') and len(c) > 1 and any(char.isdigit() for char in c)]

    # Processamento de colunas num√©ricas
    for col in p_cols + t_cols + f_cols:
        if col in df.columns:
            df[col] = pd.to_numeric(df[col], errors='coerce').replace(-1, np.nan)
            df[col].fillna(df[col].median(), inplace=True)
    
    # Estat√≠sticas avan√ßadas das colunas P
    if p_cols:
        df['P_mean'] = df[p_cols].mean(axis=1)
        df['P_std'] = df[p_cols].std(axis=1)
        df['P_late'] = df[['P09', 'P12', 'P13', 'P15']].mean(axis=1) if all(c in df.columns for c in ['P09', 'P12', 'P13', 'P15']) else 0
        df['P_early'] = df[['P01', 'P02', 'P03', 'P04']].mean(axis=1) if all(c in df.columns for c in ['P01', 'P02', 'P03', 'P04']) else 0

    # Estat√≠sticas das colunas T
    if t_cols:
        df['T_mean'] = df[t_cols].mean(axis=1)
        df['T_std'] = df[t_cols].std(axis=1)

    # Features de sono avan√ßadas
    if 'QtdHorasSono' in df.columns:
        f_sono = [c for c in f_cols if '07' in c]
        if f_sono:
            df['F_sono_mean'] = df[f_sono].mean(axis=1)
            df['F_sono_std'] = df[f_sono].std(axis=1)
            df['F_sono_max'] = df[f_sono].max(axis=1)
        if 'Acordar' in df.columns:
            df['sono_x_acordar'] = df['QtdHorasSono'] * df['Acordar']
            df['acordar_squared'] = df['Acordar'] ** 2
    
    # Features finais
    f_final = [c for c in f_cols if '11' in c]
    if f_final: 
        df['F_final_mean'] = df[f_final].mean(axis=1)

    # Intera√ß√£o espec√≠fica para Target 3
    if 'F1103' in df.columns and 'P_mean' in df.columns and 'F1103_X_P_mean' in FEATURES['target3']:
        df['F1103_X_P_mean'] = df['F1103'] * df['P_mean']
    
    # Garante todas as features esperadas pelo modelo
    df_final = df.reindex(columns=FEATURES['target3'], fill_value=0)
    return SCALERS['target3'].transform(df_final)

# --- Rotas da API (ATUALIZADAS) ---
@app.get("/health", status_code=status.HTTP_200_OK)
def health_check():
    """Endpoint de health check para o Docker Compose."""
    if MODELS is None:
        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail="Modelos de ML n√£o carregados.")
    return {"status": "ok"}

@app.post("/register", status_code=status.HTTP_201_CREATED)
def register(user: schemas.UserCreate, db: Session = Depends(database.get_db)):
    db_user = crud.get_user_by_username(db, username=user.username)
    if db_user:
        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail="Usu√°rio j√° existe")
    try:
        crud.create_user(db=db, user_schema=user)
        return {"msg": "Usu√°rio registrado com sucesso"}
    except IntegrityError: # Captura erro de corrida (race condition)
        db.rollback()
        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail="Usu√°rio j√° existe")

@app.post("/login", response_model=schemas.Token)
def login(form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(database.get_db)):
    user = crud.get_user_by_username(db, username=form_data.username)
    if not user or not auth.verify_password(form_data.password, user.password_hash):
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Credenciais inv√°lidas")
    access_token = auth.create_access_token(data={"sub": str(user.id)})
    return {"access_token": access_token, "token_type": "bearer"}

@app.post("/predict")
async def predict(file: UploadFile = File(...), user_id: str = Depends(auth.get_current_user_id), db: Session = Depends(database.get_db)):
    if MODELS is None:
        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail="Modelos de ML n√£o est√£o dispon√≠veis.")
    
    try:
        contents = await file.read()
        buffer = BytesIO(contents)
        df_new = pd.read_excel(buffer)
        if 'C√≥digo de Acesso' not in df_new.columns:
            print("Coluna 'C√≥digo de Acesso' n√£o encontrada no arquivo.")
            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Coluna 'C√≥digo de Acesso' n√£o encontrada no arquivo.")
    except Exception as e:
        print(f"Erro ao ler o arquivo Excel: {e}")
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=f"Erro ao ler o arquivo Excel: {e}")

    df_results = df_new.copy()
    shap_data = {}

    try:
        # Previs√£o T1 (modelo √∫nico)
        X_scaled_t1 = preprocess_target1(df_new)
        df_results['Previs√£o T1'] = MODELS['target1'].predict(X_scaled_t1).round(2)
        
        # Previs√£o T2 (ensemble - m√©dia dos 3 modelos)
        X_scaled_t2 = preprocess_target2(df_new)
        preds_t2 = [model.predict(X_scaled_t2) for model in MODELS['target2']]
        df_results['Previs√£o T2'] = np.mean(preds_t2, axis=0).round(2)
        
        # Previs√£o T3 (ensemble - m√©dia dos 3 modelos)
        X_scaled_t3 = preprocess_target3(df_new)
        preds_t3 = [model.predict(X_scaled_t3) for model in MODELS['target3']]
        df_results['Previs√£o T3'] = np.mean(preds_t3, axis=0).round(2)

        # C√°lculo SHAP - ATUALIZADO PARA ENSEMBLE
        # T1 (modelo √∫nico)
        shap_values_t1 = EXPLAINERS['target1'].shap_values(X_scaled_t1)
        
        # T2 (m√©dia dos SHAP values dos 3 modelos do ensemble)
        shap_values_list_t2 = [explainer.shap_values(X_scaled_t2) for explainer in EXPLAINERS['target2']]
        shap_values_t2 = np.mean(shap_values_list_t2, axis=0)

        # T3 (m√©dia dos SHAP values dos 3 modelos do ensemble)
        shap_values_list_t3 = [explainer.shap_values(X_scaled_t3) for explainer in EXPLAINERS['target3']]
        shap_values_t3 = np.mean(shap_values_list_t3, axis=0)

        # Estrutura dos dados SHAP para resposta
        for i, j_id in enumerate(df_results['C√≥digo de Acesso']):
            shap_data[str(j_id)] = {
                'T1': {
                    'shap_values': shap_values_t1[i].tolist(), 
                    'feature_names': FEATURES['target1']
                },
                'T2': {
                    'shap_values': shap_values_t2[i].tolist(), 
                    'feature_names': FEATURES['target2']
                },
                'T3': {
                    'shap_values': shap_values_t3[i].tolist(), 
                    'feature_names': FEATURES['target3']
                }
            }
            
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"Erro durante o pipeline de previs√£o: {e}")

    # Salvar no DB
    try:
        for _, row in df_results.iterrows():
            db.add(models.Prediction(
                user_id=int(user_id), 
                jogador_id=str(row['C√≥digo de Acesso']), 
                pred_t1=row['Previs√£o T1'], 
                pred_t2=row['Previs√£o T2'], 
                pred_t3=row['Previs√£o T3']
            ))
        db.commit()
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"Erro ao salvar previs√£o no banco de dados: {e}")

    return {
        "predictions": df_results[['C√≥digo de Acesso', 'Previs√£o T1', 'Previs√£o T2', 'Previs√£o T3']].to_dict('records'),
        "shap_data": shap_data
    }

@app.get("/history")
def get_history(user_id: str = Depends(auth.get_current_user_id), db: Session = Depends(database.get_db)):
    query = db.query(
        models.Prediction.upload_timestamp, 
        func.count(models.Prediction.id).label('num_jogadores')
    ).filter(models.Prediction.user_id == int(user_id)).group_by(models.Prediction.upload_timestamp).order_by(models.Prediction.upload_timestamp.desc()).all()
    return [{"timestamp": r.upload_timestamp.strftime("%Y-%m-%d %H:%M:%S"), "num_jogadores": r.num_jogadores} for r in query]

@app.get("/feature_importance")
def get_feature_importance(user_id: str = Depends(auth.get_current_user_id)):
    if MODELS is None:
        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail="Modelos de ML n√£o carregados.")
    
    importances_data = {}
    try:
        # Target 1 (modelo √∫nico)
        if hasattr(MODELS['target1'], 'feature_importances_'):
            df_imp_t1 = pd.DataFrame({
                'feature': FEATURES['target1'], 
                'importance': MODELS['target1'].feature_importances_
            }).sort_values(by='importance', ascending=False).head(20)
            importances_data['Target1'] = df_imp_t1.to_dict('records')
        else:
            importances_data['Target1'] = []

        # Targets 2 e 3 (m√©dia das import√¢ncias dos ensembles)
        for target_key, target_name in [('target2', 'Target2'), ('target3', 'Target3')]:
            all_importances = []
            for model in MODELS[target_key]:
                if hasattr(model, 'feature_importances_'):
                    all_importances.append(model.feature_importances_)
            
            if all_importances:
                avg_importance = np.mean(all_importances, axis=0)
                df_imp = pd.DataFrame({
                    'feature': FEATURES[target_key],
                    'importance': avg_importance
                }).sort_values(by='importance', ascending=False).head(20)
                importances_data[target_name] = df_imp.to_dict('records')
            else:
                importances_data[target_name] = []
                
        return importances_data
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"Erro ao calcular feature importance: {e}")
</file>

<file path="models.py">
# models.py
from sqlalchemy import Column, Integer, String, Float, DateTime, ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from database import Base

class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, unique=True, index=True, nullable=False)
    password_hash = Column(String, nullable=False)
    predictions = relationship('Prediction', backref='user', lazy=True)

class Prediction(Base):
    __tablename__ = 'predictions'
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey('users.id'), nullable=False)
    upload_timestamp = Column(DateTime, nullable=False, default=func.now())
    jogador_id = Column(String, nullable=False)
    pred_t1 = Column(Float, nullable=False)
    pred_t2 = Column(Float, nullable=False)
    pred_t3 = Column(Float, nullable=False)
</file>

<file path="README.md">
# Backend API (FastAPI)

Esta API serve como o c√©rebro do projeto, lidando com autentica√ß√£o, processamento de dados e previs√µes de Machine Learning.

## Principais Funcionalidades

-   **Autentica√ß√£o JWT:** Sistema de registro (`/register`) e login (`/login`) que gera tokens JWT para proteger os endpoints.
-   **Endpoint de Previs√£o (`/predict`):** Recebe um arquivo `.xlsx` com novos dados de jogadores, aplica o mesmo pipeline de pr√©-processamento dos modelos treinados e retorna as previs√µes para os 3 targets.
-   **An√°lise SHAP:** Junto com as previs√µes, a API calcula os valores SHAP para cada jogador, permitindo entender a contribui√ß√£o de cada feature para o resultado.
-   **Hist√≥rico de Previs√µes (`/history`):** Salva cada lote de previs√µes no banco de dados, associado ao usu√°rio que fez o upload.
-   **An√°lise do Modelo (`/feature_importance`):** Exp√µe a import√¢ncia geral das features para cada modelo.

## Principais Endpoints

-   `POST /register`: Cria um novo usu√°rio.
-   `POST /login`: Autentica um usu√°rio e retorna um token de acesso.
-   `POST /predict`: (Protegido) Recebe um arquivo Excel e retorna as previs√µes e dados SHAP.
-   `GET /history`: (Protegido) Retorna o hist√≥rico de uploads do usu√°rio logado.
-   `GET /feature_importance`: (Protegido) Retorna a import√¢ncia das features para cada modelo.
-   `GET /health`: Verifica a sa√∫de da aplica√ß√£o, incluindo o carregamento dos modelos de ML.
</file>

<file path="requirements.txt">
fastapi
uvicorn[standard]
python-multipart
sqlalchemy
psycopg2-binary
python-jose[cryptography]
pandas
scikit-learn==1.7.2 # Fixando a vers√£o para consist√™ncia
joblib
openpyxl
catboost
shap
Flask-Bcrypt 
optuna
lightgbm
xgboost
reportlab
</file>

<file path="schemas.py">
# schemas.py
from pydantic import BaseModel

class UserCreate(BaseModel):
    username: str
    password: str

class Token(BaseModel):
    access_token: str
    token_type: str
</file>

</files>
</file>

<file path="dashboard/backend/schemas.py">
# schemas.py
from pydantic import BaseModel

class UserCreate(BaseModel):
    username: str
    password: str

class Token(BaseModel):
    access_token: str
    token_type: str
</file>

<file path="dashboard/frontend/README.md">
# Frontend Dashboard (Plotly Dash)

Este √© um dashboard interativo constru√≠do com Plotly Dash para fornecer uma interface amig√°vel para o sistema de previs√£o.

## Funcionalidades

O dashboard √© dividido em abas:

1.  **Nova Previs√£o:**
    -   Permite o upload de um arquivo `.xlsx` com novos dados de jogadores.
    -   Exibe os resultados em uma tabela interativa (orden√°vel, filtr√°vel) e em gr√°ficos de barras comparativos.
    -   Disponibiliza um bot√£o para download dos resultados.
    -   Apresenta uma se√ß√£o de an√°lise SHAP, onde √© poss√≠vel selecionar um jogador e visualizar gr√°ficos que explicam sua previs√£o.

2.  **An√°lise do Modelo:**
    -   Exibe gr√°ficos de barras horizontais mostrando as 20 features mais importantes para cada um dos 3 modelos de target.

3.  **Hist√≥rico:**
    -   Mostra uma tabela com o hist√≥rico de uploads de arquivos realizados pelo usu√°rio, incluindo data e quantidade de jogadores previstos em cada lote.
</file>

<file path="dashboard/README.md">
# Projeto Daruma: Previs√£o de Targets de Jogadores

Este projeto √© a solu√ß√£o para o Desafio Final de Ciclo, que consiste em construir um sistema de Machine Learning completo para prever 3 targets num√©ricos com base nos dados de jogadores.

A solu√ß√£o inclui um pipeline de treinamento de modelos, uma API backend para servir as previs√µes e um dashboard interativo para visualiza√ß√£o e an√°lise dos resultados.

## Arquitetura

O projeto √© conteinerizado com Docker e orquestrado com Docker Compose, seguindo a arquitetura abaixo:

```
Frontend (Plotly Dash) <--> Backend (FastAPI) <--> Database (PostgreSQL)
```

-   **Frontend:** Um dashboard interativo onde o usu√°rio pode fazer upload de novos dados, visualizar previs√µes, an√°lises de import√¢ncia de features e explica√ß√µes de predi√ß√£o individuais com SHAP.
-   **Backend:** Uma API RESTful constru√≠da com FastAPI que lida com autentica√ß√£o de usu√°rios, recebe os dados, executa o pipeline de pr√©-processamento e predi√ß√£o usando modelos pr√©-treinados, e salva os resultados.
-   **Database:** Um banco de dados PostgreSQL para armazenar informa√ß√µes de usu√°rios e hist√≥rico de previs√µes.
-   **ML Training:** Scripts Python para treinar os modelos de Machine Learning, realizar a otimiza√ß√£o de hiperpar√¢metros e exportar os artefatos (modelos, scalers, listas de features) necess√°rios para a API.

## Estrutura do Projeto

```
.
‚îú‚îÄ‚îÄ backend/            # C√≥digo da API FastAPI
‚îÇ   ‚îú‚îÄ‚îÄ ml_artifacts/   # Artefatos de ML (modelos, scalers, etc.)
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ frontend/           # C√≥digo do Dashboard em Dash
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ .env                # Arquivo de configura√ß√£o de ambiente (N√ÉO COMMITAR)
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ docker-compose.yml
‚îî‚îÄ‚îÄ README.md
```

## Como Executar

**Pr√©-requisitos:**
*   Docker
*   Docker Compose

**Passo 1: Preparar os Modelos de ML**

# Pipeline de Treinamento de Modelos

Esta parte cont√©m os scripts respons√°veis pelo treinamento, otimiza√ß√£o e exporta√ß√£o dos modelos de Machine Learning. Pois, os modelos precisam ser treinados antes de iniciar a aplica√ß√£o.

# Navegue at√© a pasta backend
cd backend

# Instale as depend√™ncias
pip install -r requirements.txt

# Certifique-se que o excel para treinamento 'JogadoresV1.xlsx' esteja na mesma pasta e Execute os scripts de treinamento para gerar os artefatos
python export_artifacts_target1.py
python export_artifacts_target2.py
python export_artifacts_target3.py

## Funcionamento
Cada script `export_artifacts_target<N>.py` √© um pipeline completo para um dos tr√™s targets. O processo geral inclui:

1.  **Carregamento e Limpeza:** Os dados do arquivo `JogadoresV1.xlsx` s√£o carregados. Valores ausentes s√£o tratados (imputa√ß√£o por mediana) e tipos de dados s√£o corrigidos.
2.  **Engenharia de Features:** Novas features s√£o criadas a partir das existentes (m√©dias, intera√ß√µes, features polinomiais) para aumentar o poder preditivo do modelo.
3.  **Sele√ß√£o de Features:** T√©cnicas como `VarianceThreshold`, correla√ß√£o com o target e import√¢ncia de features de um `RandomForest` s√£o usadas para selecionar as vari√°veis mais relevantes.
4.  **Otimiza√ß√£o de Hiperpar√¢metros:** A biblioteca `Optuna` √© utilizada para encontrar os melhores hiperpar√¢metros para os modelos (ex: `CatBoost`), maximizando a m√©trica `R2 Score` em valida√ß√£o cruzada.
5.  **Treinamento Final:** O modelo √© treinado com os melhores par√¢metros em todo o conjunto de dados de treino.
6.  **Exporta√ß√£o de Artefatos:** O modelo treinado, o `scaler` (para normaliza√ß√£o) e a lista de features utilizadas s√£o salvos como arquivos `.pkl` na pasta `backend/ml_artifacts`.

# Volte para a raiz do projeto
cd ..
```
Isso criar√° a pasta `backend/ml_artifacts` com todos os arquivos `.pkl` necess√°rios.

**Passo 2: Configurar o Ambiente**

Crie uma c√≥pia do arquivo `.env.example` (que voc√™ deve criar) e renomeie para `.env`. Preencha com suas configura√ß√µes, principalmente uma `JWT_SECRET_KEY` segura.

**Passo 3: Iniciar a Aplica√ß√£o**

Com o Docker em execu√ß√£o, rode o seguinte comando na raiz do projeto:

```bash
docker-compose up --build
```

A aplica√ß√£o estar√° dispon√≠vel nos seguintes endere√ßos:
-   **Dashboard:** `http://localhost:8050`
-   **API (documenta√ß√£o):** `http://localhost:5000/docs`
</file>

<file path="notebooks/PROJETOFINAL.ipynb">
{
  "nbformat": 4,
  "nbformat_minor": 0,
  "metadata": {
    "colab": {
      "provenance": []
    },
    "kernelspec": {
      "name": "python3",
      "display_name": "Python 3"
    },
    "language_info": {
      "name": "python"
    }
  },
  "cells": [
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "tuhH-znyFcGf",
        "outputId": "c0c316ca-190e-4ac9-c8fb-99b0987ab8ae"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "\u001b[?25l   \u001b[90m‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\u001b[0m \u001b[32m0.0/175.3 kB\u001b[0m \u001b[31m?\u001b[0m eta \u001b[36m-:--:--\u001b[0m\r\u001b[2K   \u001b[91m‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\u001b[0m\u001b[91m‚ï∏\u001b[0m \u001b[32m174.1/175.3 kB\u001b[0m \u001b[31m6.9 MB/s\u001b[0m eta \u001b[36m0:00:01\u001b[0m\r\u001b[2K   \u001b[90m‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\u001b[0m \u001b[32m175.3/175.3 kB\u001b[0m \u001b[31m3.9 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n",
            "\u001b[?25h‚úÖ Bibliotecas instaladas!\n",
            "================================================================================\n",
            "     FASE 2 OTIMIZADA: LIMPEZA E PREPARA√á√ÉO (VERS√ÉO MELHORADA)\n",
            "================================================================================\n",
            "üìã Categ√≥ricas: 21 | Targets: 3\n",
            "\n",
            "================================================================================\n",
            "ETAPA 0: CARREGANDO DADOS\n",
            "================================================================================\n",
            "‚úÖ Carregado: 183 linhas, 114 colunas\n",
            "\n",
            "================================================================================\n",
            "ETAPA 1: REMO√á√ÉO DE NEGATIVOS ‚Üí NaN\n",
            "================================================================================\n",
            "‚úÖ 108 negativos convertidos ‚Üí NaN\n",
            "\n",
            "================================================================================\n",
            "ETAPA 2: AN√ÅLISE DE MISSING\n",
            "================================================================================\n",
            "üóëÔ∏è  Removendo 7 colunas (>70% missing)\n",
            "‚úÖ Shape: (183, 107)\n",
            "\n",
            "================================================================================\n",
            "ETAPA 3: REMO√á√ÉO DE JOGADORES SEM TARGETS\n",
            "================================================================================\n",
            "‚úÖ Jogadores mantidos: 173 (removidos: 10)\n",
            "\n",
            "================================================================================\n",
            "ETAPA 4: IMPUTA√á√ÉO\n",
            "================================================================================\n",
            "‚úÖ 90 num√©ricas imputadas (mediana)\n",
            "‚úÖ 17 categ√≥ricas imputadas (moda)\n",
            "\n",
            "================================================================================\n",
            "ETAPA 5: TRATAMENTO DE OUTLIERS\n",
            "================================================================================\n",
            "‚úÖ 727 outliers tratados (substitu√≠dos por mediana)\n",
            "\n",
            "================================================================================\n",
            "ETAPA 6: ONE-HOT ENCODING\n",
            "================================================================================\n",
            "‚úÖ One-Hot conclu√≠do: 107 ‚Üí 355 colunas\n",
            "\n",
            "================================================================================\n",
            "ETAPA 7: FEATURE ENGINEERING\n",
            "================================================================================\n",
            "‚úÖ F11_mean criada (8 colunas)\n",
            "‚úÖ F07_mean criada (9 colunas)\n",
            "\n",
            "================================================================================\n",
            "üîß CORRE√á√ÉO 1: CONVERS√ÉO BOOL ‚Üí INT\n",
            "================================================================================\n",
            "üìã Convertendo 265 colunas booleanas...\n",
            "‚úÖ VERDADEIRO/FALSO ‚Üí 1/0\n",
            "   Exemplo: ['Cor0202_000000', 'Cor0202_3E3200', 'Cor0202_552D2D']\n",
            "\n",
            "================================================================================\n",
            "ETAPA 8: FEATURE SELECTION\n",
            "================================================================================\n",
            "üìä Features dispon√≠veis: 347\n",
            "‚úÖ Features mantidas: 54 (threshold=0.2)\n",
            "‚úÖ Features removidas: 293\n",
            "\n",
            "üèÜ TOP 10 FEATURES:\n",
            "    1. F07_mean                       | Corr: 0.6025\n",
            "    2. F1105                          | Corr: 0.5670\n",
            "    3. F1107                          | Corr: 0.5448\n",
            "    4. F1101                          | Corr: 0.5363\n",
            "    5. F0708                          | Corr: 0.5349\n",
            "    6. F0711                          | Corr: 0.5341\n",
            "    7. Acordar                        | Corr: 0.5263\n",
            "    8. F1109                          | Corr: 0.5226\n",
            "    9. F0710                          | Corr: 0.5146\n",
            "   10. F0707                          | Corr: 0.5088\n",
            "\n",
            "================================================================================\n",
            "ETAPA 9: CRIA√á√ÉO DOS DATAFRAMES FINAIS\n",
            "================================================================================\n",
            "‚úÖ DataFrame N√ÉO-NORMALIZADO: (173, 57)\n",
            "üî¢ Num√©ricas a normalizar: 25\n",
            "üìù Categ√≥ricas (preservadas): 29\n",
            "‚úÖ Normaliza√ß√£o conclu√≠da!\n",
            "‚úÖ DataFrame NORMALIZADO: (173, 57)\n",
            "\n",
            "================================================================================\n",
            "ETAPA 10: EXPORTA√á√ÉO\n",
            "================================================================================\n",
            "‚úÖ Arquivo 'Dados_Otimizados_V4.xlsx' criado!\n",
            "\n",
            "================================================================================\n",
            "üéâ FASE 2 OTIMIZADA CONCLU√çDA!\n",
            "================================================================================\n",
            "\n",
            "üìä RESUMO:\n",
            "   Jogadores: 173\n",
            "   Features: 54\n",
            "   Targets: 3\n",
            "\n",
            "üîß MELHORIAS APLICADAS:\n",
            "   ‚úÖ BOOL convertidas para INT (0/1)\n",
            "   ‚úÖ Clusteriza√ß√£o REMOVIDA (n√£o agregava valor)\n",
            "   ‚úÖ Pipeline otimizado\n",
            "\n",
            "üìÅ ARQUIVO GERADO: Dados_Otimizados_V4.xlsx\n",
            "   Aba 1: Dados_Para_Analise\n",
            "   Aba 2: Dados_Para_Modelo ‚≠ê (usar este!)\n",
            "   Aba 3: Resumo_Estatistico\n",
            "   Aba 4: Correlacoes\n",
            "\n",
            "üöÄ PR√ìXIMO PASSO: FASE 3 OTIMIZADA\n",
            "   Use: Dados_Para_Modelo\n"
          ]
        }
      ],
      "source": [
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "# FASE 2 OTIMIZADA: PIPELINE COM MELHORIAS APLICADAS\n",
        "# üîß CORRE√á√ïES IMPLEMENTADAS:\n",
        "#    ‚úÖ Convers√£o BOOL ‚Üí INT (problema cr√≠tico resolvido!)\n",
        "#    ‚úÖ Remo√ß√£o de features de cluster (n√£o agregavam valor)\n",
        "#    ‚úÖ C√≥digo otimizado e mais r√°pido\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "# C√âLULA 1: INSTALA√á√ÉO\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "!pip install xlsxwriter openpyxl scikit-learn -q\n",
        "print(\"‚úÖ Bibliotecas instaladas!\")\n",
        "\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "# C√âLULA 2: IMPORTS\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "import pandas as pd\n",
        "import numpy as np\n",
        "from sklearn.impute import SimpleImputer\n",
        "from sklearn.preprocessing import StandardScaler\n",
        "from datetime import datetime\n",
        "import warnings\n",
        "warnings.filterwarnings('ignore')\n",
        "\n",
        "print(\"=\" * 80)\n",
        "print(\"     FASE 2 OTIMIZADA: LIMPEZA E PREPARA√á√ÉO (VERS√ÉO MELHORADA)\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "# C√âLULA 3: DEFINI√á√ïES\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "COLUNAS_CATEGORICAS = [\n",
        "    'Cor0202', 'Cor0204', 'Cor0206', 'Cor0208', 'Cor0209Outro',\n",
        "    'P01', 'P02', 'P03', 'P04', 'P05', 'P07', 'P08', 'P09', 'P10',\n",
        "    'P12', 'P13', 'P15', 'P12_1', 'P02_1', 'P03_1', 'P09_1'\n",
        "]\n",
        "\n",
        "COLUNAS_TARGETS = ['Target1', 'Target2', 'Target3']\n",
        "\n",
        "COLUNAS_IGNORAR = [\n",
        "    'C√≥digo de Acesso', 'Data/Hora √öltimo',\n",
        "    'L0210 (n√£o likert)',\n",
        "    'F0299 - Explica√ß√£o Tempo', 'T0499 - Explica√ß√£o Tempo',\n",
        "    'PTempoTotalExpl', 'T1199Expl', 'T1205Expl', 'T1210Expl',\n",
        "    'TempoTotalExpl'\n",
        "]\n",
        "\n",
        "print(f\"üìã Categ√≥ricas: {len(COLUNAS_CATEGORICAS)} | Targets: {len(COLUNAS_TARGETS)}\")\n",
        "\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "# C√âLULA 4: CARREGAR DADOS\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 0: CARREGANDO DADOS\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "df = pd.read_excel('JogadoresV1.xlsx')\n",
        "print(f\"‚úÖ Carregado: {df.shape[0]} linhas, {df.shape[1]} colunas\")\n",
        "\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "# C√âLULA 5: TRATAMENTO F0103 (v√≠rgula ‚Üí ponto)\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "if 'F0103' in df.columns and df['F0103'].dtype == 'object':\n",
        "    print(\"\\nüîß Convertendo F0103 (v√≠rgula ‚Üí ponto)\")\n",
        "    df['F0103'] = df['F0103'].str.replace(',', '.').astype(float)\n",
        "    print(\"   ‚úÖ Convertido!\")\n",
        "\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "# C√âLULA 6: REMO√á√ÉO DE NEGATIVOS (TODOS!)\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 1: REMO√á√ÉO DE NEGATIVOS ‚Üí NaN\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "colunas_numericas = df.select_dtypes(include=[np.number]).columns.tolist()\n",
        "colunas_numericas = [col for col in colunas_numericas if col not in COLUNAS_TARGETS]\n",
        "\n",
        "contador = 0\n",
        "for col in colunas_numericas:\n",
        "    negativos = (df[col] < 0).sum()\n",
        "    if negativos > 0:\n",
        "        df.loc[df[col] < 0, col] = np.nan\n",
        "        contador += negativos\n",
        "\n",
        "print(f\"‚úÖ {contador} negativos convertidos ‚Üí NaN\")\n",
        "\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "# C√âLULA 7: REMO√á√ÉO DE COLUNAS COM MUITO MISSING\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 2: AN√ÅLISE DE MISSING\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "missing_info = pd.DataFrame({\n",
        "    'Coluna': df.columns,\n",
        "    'Missing': df.isna().sum(),\n",
        "    'Percentual': (df.isna().sum() / len(df) * 100).round(2)\n",
        "})\n",
        "missing_info = missing_info[missing_info['Missing'] > 0].sort_values('Percentual', ascending=False)\n",
        "\n",
        "threshold = 70\n",
        "colunas_remover = missing_info[missing_info['Percentual'] > threshold]['Coluna'].tolist()\n",
        "\n",
        "if colunas_remover:\n",
        "    print(f\"üóëÔ∏è  Removendo {len(colunas_remover)} colunas (>{threshold}% missing)\")\n",
        "    df = df.drop(columns=colunas_remover)\n",
        "\n",
        "print(f\"‚úÖ Shape: {df.shape}\")\n",
        "\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "# C√âLULA 8: REMO√á√ÉO DE JOGADORES SEM TARGETS\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 3: REMO√á√ÉO DE JOGADORES SEM TARGETS\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "antes = len(df)\n",
        "df = df.dropna(subset=COLUNAS_TARGETS, how='all')\n",
        "depois = len(df)\n",
        "\n",
        "print(f\"‚úÖ Jogadores mantidos: {depois} (removidos: {antes-depois})\")\n",
        "\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "# C√âLULA 9: IMPUTA√á√ÉO DE VALORES FALTANTES\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 4: IMPUTA√á√ÉO\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "# Num√©ricas: MEDIANA\n",
        "colunas_num_imputar = [\n",
        "    col for col in df.select_dtypes(include=[np.number]).columns\n",
        "    if col not in COLUNAS_TARGETS and col not in COLUNAS_IGNORAR\n",
        "]\n",
        "\n",
        "if colunas_num_imputar:\n",
        "    imputer_num = SimpleImputer(strategy='median')\n",
        "    df[colunas_num_imputar] = imputer_num.fit_transform(df[colunas_num_imputar])\n",
        "    print(f\"‚úÖ {len(colunas_num_imputar)} num√©ricas imputadas (mediana)\")\n",
        "\n",
        "# Categ√≥ricas: MODA\n",
        "colunas_cat_imputar = [col for col in COLUNAS_CATEGORICAS if col in df.columns]\n",
        "\n",
        "if colunas_cat_imputar:\n",
        "    imputer_cat = SimpleImputer(strategy='most_frequent')\n",
        "    df[colunas_cat_imputar] = imputer_cat.fit_transform(df[colunas_cat_imputar])\n",
        "    print(f\"‚úÖ {len(colunas_cat_imputar)} categ√≥ricas imputadas (moda)\")\n",
        "\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "# C√âLULA 10: TRATAMENTO DE OUTLIERS (IQR + MEDIANA)\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 5: TRATAMENTO DE OUTLIERS\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "colunas_outliers = [\n",
        "    col for col in colunas_num_imputar\n",
        "    if col not in ['QtdHorasSono', 'QtdHorasDormi', 'Acordar']\n",
        "]\n",
        "\n",
        "outliers_tratados = 0\n",
        "for col in colunas_outliers:\n",
        "    Q1 = df[col].quantile(0.25)\n",
        "    Q3 = df[col].quantile(0.75)\n",
        "    IQR = Q3 - Q1\n",
        "\n",
        "    limite_inf = Q1 - 1.5 * IQR\n",
        "    limite_sup = Q3 + 1.5 * IQR\n",
        "\n",
        "    outliers_mask = (df[col] < limite_inf) | (df[col] > limite_sup)\n",
        "    n_outliers = outliers_mask.sum()\n",
        "\n",
        "    if n_outliers > 0:\n",
        "        mediana = df[col].median()\n",
        "        df.loc[outliers_mask, col] = mediana\n",
        "        outliers_tratados += n_outliers\n",
        "\n",
        "print(f\"‚úÖ {outliers_tratados} outliers tratados (substitu√≠dos por mediana)\")\n",
        "\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "# C√âLULA 11: ONE-HOT ENCODING\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 6: ONE-HOT ENCODING\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "colunas_cat_presentes = [col for col in COLUNAS_CATEGORICAS if col in df.columns]\n",
        "\n",
        "if colunas_cat_presentes:\n",
        "    colunas_antes = df.shape[1]\n",
        "    df = pd.get_dummies(df, columns=colunas_cat_presentes, prefix=colunas_cat_presentes, drop_first=False)\n",
        "    colunas_depois = df.shape[1]\n",
        "\n",
        "    print(f\"‚úÖ One-Hot conclu√≠do: {colunas_antes} ‚Üí {colunas_depois} colunas\")\n",
        "\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "# C√âLULA 12: FEATURE ENGINEERING (Agrega√ß√µes)\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 7: FEATURE ENGINEERING\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "# Agrega√ß√£o F11*\n",
        "f11_cols = [c for c in df.columns if c.startswith('F11') and pd.api.types.is_numeric_dtype(df[c])]\n",
        "if len(f11_cols) > 2:\n",
        "    df['F11_mean'] = df[f11_cols].mean(axis=1)\n",
        "    print(f\"‚úÖ F11_mean criada ({len(f11_cols)} colunas)\")\n",
        "\n",
        "# Agrega√ß√£o F07*\n",
        "f07_cols = [c for c in df.columns if c.startswith('F07') and pd.api.types.is_numeric_dtype(df[c])]\n",
        "if len(f07_cols) > 2:\n",
        "    df['F07_mean'] = df[f07_cols].mean(axis=1)\n",
        "    print(f\"‚úÖ F07_mean criada ({len(f07_cols)} colunas)\")\n",
        "\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "# C√âLULA 13: üîß CORRE√á√ÉO 1 - CONVERTER BOOL ‚Üí INT\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"üîß CORRE√á√ÉO 1: CONVERS√ÉO BOOL ‚Üí INT\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "bool_cols = df.select_dtypes(include=['bool']).columns.tolist()\n",
        "\n",
        "if bool_cols:\n",
        "    print(f\"üìã Convertendo {len(bool_cols)} colunas booleanas...\")\n",
        "    df[bool_cols] = df[bool_cols].astype(int)\n",
        "    print(f\"‚úÖ VERDADEIRO/FALSO ‚Üí 1/0\")\n",
        "    print(f\"   Exemplo: {bool_cols[:3]}\")\n",
        "else:\n",
        "    print(\"‚ÑπÔ∏è  Nenhuma coluna booleana encontrada\")\n",
        "\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "# C√âLULA 14: FEATURE SELECTION POR CORRELA√á√ÉO\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 8: FEATURE SELECTION\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "features_numericas_finais = [\n",
        "    col for col in df.columns\n",
        "    if col not in COLUNAS_TARGETS\n",
        "    and col not in COLUNAS_IGNORAR\n",
        "    and pd.api.types.is_numeric_dtype(df[col])\n",
        "]\n",
        "\n",
        "print(f\"üìä Features dispon√≠veis: {len(features_numericas_finais)}\")\n",
        "\n",
        "corr_t1 = df[features_numericas_finais].corrwith(df['Target1']).abs()\n",
        "corr_t2 = df[features_numericas_finais].corrwith(df['Target2']).abs()\n",
        "corr_t3 = df[features_numericas_finais].corrwith(df['Target3']).abs()\n",
        "\n",
        "corr_mean = (corr_t1 + corr_t2 + corr_t3) / 3\n",
        "\n",
        "threshold = 0.20\n",
        "features_selecionadas = corr_mean[corr_mean > threshold].index.tolist()\n",
        "\n",
        "print(f\"‚úÖ Features mantidas: {len(features_selecionadas)} (threshold={threshold})\")\n",
        "print(f\"‚úÖ Features removidas: {len(features_numericas_finais) - len(features_selecionadas)}\")\n",
        "\n",
        "# Top 10\n",
        "print(f\"\\nüèÜ TOP 10 FEATURES:\")\n",
        "top10 = corr_mean.sort_values(ascending=False).head(10)\n",
        "for idx, (feat, corr) in enumerate(top10.items(), 1):\n",
        "    print(f\"   {idx:2d}. {feat:30s} | Corr: {corr:.4f}\")\n",
        "\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "# C√âLULA 15: CRIAR DATAFRAMES FINAIS\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 9: CRIA√á√ÉO DOS DATAFRAMES FINAIS\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "df_final_nao_normalizado = df[features_selecionadas + COLUNAS_TARGETS].copy()\n",
        "print(f\"‚úÖ DataFrame N√ÉO-NORMALIZADO: {df_final_nao_normalizado.shape}\")\n",
        "\n",
        "df_final_normalizado = df_final_nao_normalizado.copy()\n",
        "\n",
        "# Identificar categ√≥ricas (One-Hot) para N√ÉO normalizar\n",
        "features_cat_onehot = [\n",
        "    col for col in features_selecionadas\n",
        "    if any(cat in col for cat in COLUNAS_CATEGORICAS)\n",
        "]\n",
        "\n",
        "features_numericas_normalizar = [\n",
        "    col for col in features_selecionadas\n",
        "    if col not in features_cat_onehot\n",
        "]\n",
        "\n",
        "print(f\"üî¢ Num√©ricas a normalizar: {len(features_numericas_normalizar)}\")\n",
        "print(f\"üìù Categ√≥ricas (preservadas): {len(features_cat_onehot)}\")\n",
        "\n",
        "if features_numericas_normalizar:\n",
        "    scaler = StandardScaler()\n",
        "    df_final_normalizado[features_numericas_normalizar] = scaler.fit_transform(\n",
        "        df_final_normalizado[features_numericas_normalizar]\n",
        "    )\n",
        "    print(f\"‚úÖ Normaliza√ß√£o conclu√≠da!\")\n",
        "\n",
        "print(f\"‚úÖ DataFrame NORMALIZADO: {df_final_normalizado.shape}\")\n",
        "\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "# C√âLULA 16: EXPORTAR PARA EXCEL\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 10: EXPORTA√á√ÉO\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "output_file = 'Dados_Otimizados_V4.xlsx'\n",
        "\n",
        "writer = pd.ExcelWriter(output_file, engine='xlsxwriter')\n",
        "workbook = writer.book\n",
        "\n",
        "header_format = workbook.add_format({\n",
        "    'bold': True, 'text_wrap': True, 'valign': 'vcenter',\n",
        "    'align': 'center', 'fg_color': '#1F4E78',\n",
        "    'font_color': 'white', 'border': 1\n",
        "})\n",
        "\n",
        "title_format = workbook.add_format({\n",
        "    'bold': True, 'font_size': 16,\n",
        "    'fg_color': '#4472C4', 'font_color': 'white',\n",
        "    'align': 'center', 'valign': 'vcenter', 'border': 2\n",
        "})\n",
        "\n",
        "# Aba 1: Dados n√£o-normalizados\n",
        "df_final_nao_normalizado.to_excel(writer, sheet_name='Dados_Para_Analise', index=False, startrow=2)\n",
        "worksheet1 = writer.sheets['Dados_Para_Analise']\n",
        "worksheet1.merge_range('A1:Z1', 'üìã DADOS LIMPOS - Vers√£o Otimizada', title_format)\n",
        "worksheet1.freeze_panes(3, 0)\n",
        "\n",
        "# Aba 2: Dados normalizados\n",
        "df_final_normalizado.to_excel(writer, sheet_name='Dados_Para_Modelo', index=False, startrow=2)\n",
        "worksheet2 = writer.sheets['Dados_Para_Modelo']\n",
        "worksheet2.merge_range('A1:Z1', 'üìä DADOS NORMALIZADOS - Para ML', title_format)\n",
        "worksheet2.freeze_panes(3, 0)\n",
        "\n",
        "# Aba 3: Resumo estat√≠stico\n",
        "summary = df_final_nao_normalizado[COLUNAS_TARGETS].describe().T\n",
        "summary.to_excel(writer, sheet_name='Resumo_Estatistico', startrow=2)\n",
        "worksheet3 = writer.sheets['Resumo_Estatistico']\n",
        "worksheet3.merge_range('A1:I1', 'üìä RESUMO ESTAT√çSTICO', title_format)\n",
        "\n",
        "# Aba 4: Correla√ß√µes\n",
        "correlations_df = pd.DataFrame({\n",
        "    'Feature': corr_mean.index,\n",
        "    'Corr_Target1': corr_t1.values,\n",
        "    'Corr_Target2': corr_t2.values,\n",
        "    'Corr_Target3': corr_t3.values,\n",
        "    'Corr_Media': corr_mean.values,\n",
        "    'Mantida': ['‚úÖ' if f in features_selecionadas else '‚ùå' for f in corr_mean.index]\n",
        "}).sort_values('Corr_Media', ascending=False)\n",
        "\n",
        "correlations_df.to_excel(writer, sheet_name='Correlacoes', index=False, startrow=2)\n",
        "worksheet4 = writer.sheets['Correlacoes']\n",
        "worksheet4.merge_range('A1:F1', 'üîç AN√ÅLISE DE CORRELA√á√ïES', title_format)\n",
        "\n",
        "writer.close()\n",
        "\n",
        "print(f\"‚úÖ Arquivo '{output_file}' criado!\")\n",
        "\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "# C√âLULA 17: RELAT√ìRIO FINAL\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"üéâ FASE 2 OTIMIZADA CONCLU√çDA!\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "print(f\"\\nüìä RESUMO:\")\n",
        "print(f\"   Jogadores: {len(df_final_nao_normalizado)}\")\n",
        "print(f\"   Features: {len(features_selecionadas)}\")\n",
        "print(f\"   Targets: {len(COLUNAS_TARGETS)}\")\n",
        "\n",
        "print(f\"\\nüîß MELHORIAS APLICADAS:\")\n",
        "print(f\"   ‚úÖ BOOL convertidas para INT (0/1)\")\n",
        "print(f\"   ‚úÖ Clusteriza√ß√£o REMOVIDA (n√£o agregava valor)\")\n",
        "print(f\"   ‚úÖ Pipeline otimizado\")\n",
        "\n",
        "print(f\"\\nüìÅ ARQUIVO GERADO: {output_file}\")\n",
        "print(f\"   Aba 1: Dados_Para_Analise\")\n",
        "print(f\"   Aba 2: Dados_Para_Modelo ‚≠ê (usar este!)\")\n",
        "print(f\"   Aba 3: Resumo_Estatistico\")\n",
        "print(f\"   Aba 4: Correlacoes\")\n",
        "\n",
        "print(f\"\\nüöÄ PR√ìXIMO PASSO: FASE 3 OTIMIZADA\")\n",
        "print(f\"   Use: Dados_Para_Modelo\")"
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "# FASE 3 COMPLETA: MODELAGEM AVAN√áADA + VISUALIZA√á√ïES DETALHADAS\n",
        "# üîß COMBINA O MELHOR DAS DUAS VERS√ïES:\n",
        "#    ‚úÖ 8 Algoritmos testados (incluindo LightGBM e CatBoost)\n",
        "#    ‚úÖ Gr√°fico de Dispers√£o (Previsto vs. Real) para os melhores modelos\n",
        "#    ‚úÖ Gr√°fico de Feature Importance para os melhores modelos\n",
        "#    ‚úÖ Salva os modelos e gera um relat√≥rio final completo\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "# C√âLULA 1: INSTALA√á√ÉO DE BIBLIOTECAS\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "!pip install xgboost lightgbm catboost scikit-learn pandas matplotlib seaborn plotly -q\n",
        "print(\"‚úÖ Bibliotecas instaladas com sucesso!\")\n",
        "\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "# C√âLULA 2: IMPORTA√á√ÉO DE BIBLIOTECAS\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "import pandas as pd\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "import seaborn as sns\n",
        "import warnings\n",
        "from sklearn.model_selection import train_test_split, cross_val_score\n",
        "from sklearn.linear_model import LinearRegression, Ridge\n",
        "from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor\n",
        "from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score\n",
        "import xgboost as xgb\n",
        "import lightgbm as lgb\n",
        "from catboost import CatBoostRegressor\n",
        "import pickle\n",
        "\n",
        "warnings.filterwarnings('ignore')\n",
        "sns.set_style('whitegrid')\n",
        "\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"     FASE 3 COMPLETA: MODELAGEM AVAN√áADA + VISUALIZA√á√ïES\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "# C√âLULA 3: CARREGAMENTO DOS DADOS\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 1: CARREGANDO DADOS LIMPOS\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "# MUDE O NOME DO ARQUIVO AQUI SE NECESS√ÅRIO:\n",
        "df = pd.read_excel('Dados_para_modelo.xlsx')\n",
        "\n",
        "print(f\"‚úÖ Dados carregados com sucesso. Shape: {df.shape}\")\n",
        "print(f\"   Total de Jogadores: {len(df)}\")\n",
        "print(f\"   Total de Colunas: {len(df.columns)}\")\n",
        "\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "# C√âLULA 4: SEPARA√á√ÉO DE FEATURES (X) E TARGETS (y)\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 2: SEPARA√á√ÉO DE FEATURES E TARGETS\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "targets = ['Target1', 'Target2', 'Target3']\n",
        "X = df.drop(columns=targets)\n",
        "y1 = df['Target1']\n",
        "y2 = df['Target2']\n",
        "y3 = df['Target3']\n",
        "\n",
        "print(f\"‚úÖ Features (X) separadas. Total de features: {X.shape[1]}\")\n",
        "print(f\"‚úÖ Targets (y1, y2, y3) separados.\")\n",
        "\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "# C√âLULA 5: DIVIS√ÉO EM DADOS DE TREINO E TESTE (80/20)\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 3: DIVIS√ÉO TREINO/TESTE\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "X_train, X_test, y1_train, y1_test = train_test_split(X, y1, test_size=0.2, random_state=42)\n",
        "_, _, y2_train, y2_test = train_test_split(X, y2, test_size=0.2, random_state=42)\n",
        "_, _, y3_train, y3_test = train_test_split(X, y3, test_size=0.2, random_state=42)\n",
        "\n",
        "print(f\"‚úÖ Dados divididos em 80% treino e 20% teste.\")\n",
        "print(f\"   Tamanho do treino: {len(X_train)} jogadores\")\n",
        "print(f\"   Tamanho do teste:  {len(X_test)} jogadores\")\n",
        "\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "# C√âLULA 6: DEFINI√á√ÉO DOS MODELOS A SEREM TESTADOS\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 4: DEFINI√á√ÉO DOS MODELOS\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "modelos = {\n",
        "    'Linear Regression': LinearRegression(),\n",
        "    'Ridge': Ridge(alpha=1.0),\n",
        "    'Random Forest': RandomForestRegressor(n_estimators=100, max_depth=10, random_state=42, n_jobs=-1),\n",
        "    'Gradient Boosting': GradientBoostingRegressor(n_estimators=100, max_depth=5, random_state=42),\n",
        "    'XGBoost': xgb.XGBRegressor(n_estimators=100, max_depth=6, learning_rate=0.1, random_state=42, n_jobs=-1),\n",
        "    'LightGBM': lgb.LGBMRegressor(n_estimators=100, max_depth=6, learning_rate=0.1, random_state=42, n_jobs=-1, verbose=-1),\n",
        "    'CatBoost': CatBoostRegressor(iterations=100, depth=6, learning_rate=0.1, random_state=42, verbose=False)\n",
        "}\n",
        "print(f\"‚úÖ {len(modelos)} modelos definidos para teste.\")\n",
        "\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "# C√âLULA 7: FUN√á√ÉO DE TREINAMENTO E AVALIA√á√ÉO\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "def treinar_avaliar_modelo(modelo, X_train, X_test, y_train, y_test):\n",
        "    \"\"\"Fun√ß√£o para treinar, prever e avaliar um modelo, retornando as m√©tricas e o modelo treinado.\"\"\"\n",
        "    modelo.fit(X_train, y_train)\n",
        "    y_pred = modelo.predict(X_test)\n",
        "    r2 = r2_score(y_test, y_pred)\n",
        "    rmse = np.sqrt(mean_squared_error(y_test, y_pred))\n",
        "    mae = mean_absolute_error(y_test, y_pred)\n",
        "    return {'modelo': modelo, 'y_pred': y_pred, 'r2': r2, 'rmse': rmse, 'mae': mae}\n",
        "\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "# C√âLULA 8: TREINAMENTO E AVALIA√á√ÉO DE TODOS OS MODELOS\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 5: TREINAMENTO E AVALIA√á√ÉO DOS MODELOS\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "# --- Target 1 ---\n",
        "resultados_t1 = {}\n",
        "for nome, modelo in modelos.items():\n",
        "    resultados_t1[nome] = treinar_avaliar_modelo(type(modelo)(**modelo.get_params()), X_train, X_test, y1_train, y1_test)\n",
        "melhor_t1 = max(resultados_t1.items(), key=lambda x: x[1]['r2'])\n",
        "print(f\"üéØ Target 1 | Melhor Modelo: {melhor_t1[0]:<20} | R¬≤ = {melhor_t1[1]['r2']:.4f}\")\n",
        "\n",
        "# --- Target 2 ---\n",
        "resultados_t2 = {}\n",
        "for nome, modelo in modelos.items():\n",
        "    resultados_t2[nome] = treinar_avaliar_modelo(type(modelo)(**modelo.get_params()), X_train, X_test, y2_train, y2_test)\n",
        "melhor_t2 = max(resultados_t2.items(), key=lambda x: x[1]['r2'])\n",
        "print(f\"üéØ Target 2 | Melhor Modelo: {melhor_t2[0]:<20} | R¬≤ = {melhor_t2[1]['r2']:.4f}\")\n",
        "\n",
        "# --- Target 3 ---\n",
        "resultados_t3 = {}\n",
        "for nome, modelo in modelos.items():\n",
        "    resultados_t3[nome] = treinar_avaliar_modelo(type(modelo)(**modelo.get_params()), X_train, X_test, y3_train, y3_test)\n",
        "melhor_t3 = max(resultados_t3.items(), key=lambda x: x[1]['r2'])\n",
        "print(f\"üéØ Target 3 | Melhor Modelo: {melhor_t3[0]:<20} | R¬≤ = {melhor_t3[1]['r2']:.4f}\")\n",
        "\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "# C√âLULA 9: VISUALIZA√á√ÉO 1 - PREVISTO vs. REAL (Gr√°fico de Dispers√£o)\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 6: VISUALIZA√á√ÉO - PREVISTO vs. REAL\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "fig, axes = plt.subplots(1, 3, figsize=(18, 5))\n",
        "fig.suptitle('An√°lise de Previs√£o vs. Valor Real para os Melhores Modelos', fontsize=16, fontweight='bold')\n",
        "\n",
        "# Gr√°fico para Target 1\n",
        "y1_pred = melhor_t1[1]['y_pred']\n",
        "axes[0].scatter(y1_test, y1_pred, alpha=0.7, color='blue', edgecolors='k')\n",
        "axes[0].plot([y1_test.min(), y1_test.max()], [y1_test.min(), y1_test.max()], 'r--', lw=2, label='Linha Perfeita')\n",
        "axes[0].set_xlabel('Valores Reais', fontsize=12)\n",
        "axes[0].set_ylabel('Valores Previstos', fontsize=12)\n",
        "axes[0].set_title(f'Target 1 - {melhor_t1[0]}\\nR¬≤={melhor_t1[1][\"r2\"]:.3f}', fontsize=14)\n",
        "axes[0].legend()\n",
        "axes[0].grid(True)\n",
        "\n",
        "# Gr√°fico para Target 2\n",
        "y2_pred = melhor_t2[1]['y_pred']\n",
        "axes[1].scatter(y2_test, y2_pred, alpha=0.7, color='green', edgecolors='k')\n",
        "axes[1].plot([y2_test.min(), y2_test.max()], [y2_test.min(), y2_test.max()], 'r--', lw=2, label='Linha Perfeita')\n",
        "axes[1].set_xlabel('Valores Reais', fontsize=12)\n",
        "axes[1].set_ylabel('Valores Previstos', fontsize=12)\n",
        "axes[1].set_title(f'Target 2 - {melhor_t2[0]}\\nR¬≤={melhor_t2[1][\"r2\"]:.3f}', fontsize=14)\n",
        "axes[1].legend()\n",
        "axes[1].grid(True)\n",
        "\n",
        "# Gr√°fico para Target 3\n",
        "y3_pred = melhor_t3[1]['y_pred']\n",
        "axes[2].scatter(y3_test, y3_pred, alpha=0.7, color='purple', edgecolors='k')\n",
        "axes[2].plot([y3_test.min(), y3_test.max()], [y3_test.min(), y3_test.max()], 'r--', lw=2, label='Linha Perfeita')\n",
        "axes[2].set_xlabel('Valores Reais', fontsize=12)\n",
        "axes[2].set_ylabel('Valores Previstos', fontsize=12)\n",
        "axes[2].set_title(f'Target 3 - {melhor_t3[0]}\\nR¬≤={melhor_t3[1][\"r2\"]:.3f}', fontsize=14)\n",
        "axes[2].legend()\n",
        "axes[2].grid(True)\n",
        "\n",
        "plt.tight_layout(rect=[0, 0, 1, 0.96])\n",
        "plt.savefig('grafico_dispersao_previsto_vs_real.png', dpi=300, bbox_inches='tight')\n",
        "print(\"‚úÖ Gr√°fico de Dispers√£o (Previsto vs. Real) salvo como 'grafico_dispersao_previsto_vs_real.png'\")\n",
        "\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "# C√âLULA 10: VISUALIZA√á√ÉO 2 - IMPORT√ÇNCIA DAS FEATURES\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 7: VISUALIZA√á√ÉO - IMPORT√ÇNCIA DAS FEATURES\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "def plotar_importancia(melhor_modelo_info, target_name, feature_names, ax):\n",
        "    \"\"\"Fun√ß√£o auxiliar para plotar a import√¢ncia das features em um eixo do matplotlib.\"\"\"\n",
        "    nome_modelo = melhor_modelo_info[0]\n",
        "    modelo = melhor_modelo_info[1]['modelo']\n",
        "\n",
        "    if hasattr(modelo, 'feature_importances_'):\n",
        "        importances = modelo.feature_importances_\n",
        "    else: # CatBoost\n",
        "        importances = modelo.get_feature_importance()\n",
        "\n",
        "    df_importances = pd.DataFrame({'feature': feature_names, 'importance': importances}).sort_values('importance', ascending=True).tail(15)\n",
        "\n",
        "    ax.barh(df_importances['feature'], df_importances['importance'], color='darkcyan')\n",
        "    ax.set_title(f'Top 15 Features - {target_name}\\n(Modelo: {nome_modelo})', fontsize=14)\n",
        "    ax.set_xlabel('Import√¢ncia')\n",
        "\n",
        "fig, axes = plt.subplots(1, 3, figsize=(20, 8))\n",
        "fig.suptitle('An√°lise de Import√¢ncia das Features para os Melhores Modelos', fontsize=16, fontweight='bold')\n",
        "\n",
        "plotar_importancia(melhor_t1, 'Target 1', X.columns, axes[0])\n",
        "plotar_importancia(melhor_t2, 'Target 2', X.columns, axes[1])\n",
        "plotar_importancia(melhor_t3, 'Target 3', X.columns, axes[2])\n",
        "\n",
        "plt.tight_layout(rect=[0, 0, 1, 0.95])\n",
        "plt.savefig('grafico_feature_importance.png', dpi=300, bbox_inches='tight')\n",
        "print(\"‚úÖ Gr√°fico de Import√¢ncia das Features salvo como 'grafico_feature_importance.png'\")\n",
        "\n",
        "\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "# C√âLULA 11: SALVANDO OS MELHORES MODELOS\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 8: SALVANDO OS MELHORES MODELOS\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "with open('modelo_target1_final.pkl', 'wb') as f: pickle.dump(melhor_t1[1]['modelo'], f)\n",
        "print(f\"‚úÖ Modelo para Target 1 ({melhor_t1[0]}) salvo como 'modelo_target1_final.pkl'\")\n",
        "\n",
        "with open('modelo_target2_final.pkl', 'wb') as f: pickle.dump(melhor_t2[1]['modelo'], f)\n",
        "print(f\"‚úÖ Modelo para Target 2 ({melhor_t2[0]}) salvo como 'modelo_target2_final.pkl'\")\n",
        "\n",
        "with open('modelo_target3_final.pkl', 'wb') as f: pickle.dump(melhor_t3[1]['modelo'], f)\n",
        "print(f\"‚úÖ Modelo para Target 3 ({melhor_t3[0]}) salvo como 'modelo_target3_final.pkl'\")\n",
        "\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "# C√âLULA 12: RELAT√ìRIO FINAL\n",
        "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"üéâ FASE 3 COMPLETA - RELAT√ìRIO FINAL üéâ\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "print(\"\\nüìä RESUMO DOS MELHORES MODELOS:\\n\")\n",
        "\n",
        "print(f\"  TARGET 1\")\n",
        "print(f\"  - Melhor Modelo: {melhor_t1[0]}\")\n",
        "print(f\"  - R¬≤ (R-quadrado): {melhor_t1[1]['r2']:.4f}  (Explica ~{melhor_t1[1]['r2']:.1%} da vari√¢ncia)\")\n",
        "print(f\"  - RMSE (Erro M√©dio): {melhor_t1[1]['rmse']:.2f} pontos\")\n",
        "print(f\"  - MAE (Erro Absoluto M√©dio): {melhor_t1[1]['mae']:.2f} pontos\\n\")\n",
        "\n",
        "print(f\"  TARGET 2\")\n",
        "print(f\"  - Melhor Modelo: {melhor_t2[0]}\")\n",
        "print(f\"  - R¬≤ (R-quadrado): {melhor_t2[1]['r2']:.4f}  (Explica ~{melhor_t2[1]['r2']:.1%} da vari√¢ncia)\")\n",
        "print(f\"  - RMSE (Erro M√©dio): {melhor_t2[1]['rmse']:.2f} pontos\")\n",
        "print(f\"  - MAE (Erro Absoluto M√©dio): {melhor_t2[1]['mae']:.2f} pontos\\n\")\n",
        "\n",
        "print(f\"  TARGET 3\")\n",
        "print(f\"  - Melhor Modelo: {melhor_t3[0]}\")\n",
        "print(f\"  - R¬≤ (R-quadrado): {melhor_t3[1]['r2']:.4f}  (Explica ~{melhor_t3[1]['r2']:.1%} da vari√¢ncia)\")\n",
        "print(f\"  - RMSE (Erro M√©dio): {melhor_t3[1]['rmse']:.2f} pontos\")\n",
        "print(f\"  - MAE (Erro Absoluto M√©dio): {melhor_t3[1]['mae']:.2f} pontos\\n\")\n",
        "\n",
        "print(\"üìÅ ARQUIVOS GERADOS:\")\n",
        "print(\"  ‚úÖ modelo_target1_final.pkl\")\n",
        "print(\"  ‚úÖ modelo_target2_final.pkl\")\n",
        "print(\"  ‚úÖ modelo_target3_final.pkl\")\n",
        "print(\"  ‚úÖ grafico_dispersao_previsto_vs_real.png\")\n",
        "print(\"  ‚úÖ grafico_feature_importance.png\")\n",
        "\n",
        "print(\"\\nüöÄ PR√ìXIMOS PASSOS:\")\n",
        "print(\"  1. Usar os arquivos '.pkl' salvos para carregar os modelos no seu backend (Node.js/FastAPI).\")\n",
        "print(\"  2. Criar as rotas da API que recebem novos dados de jogadores e usam os modelos para prever os targets.\")\n",
        "print(\"  3. Desenvolver o dashboard interativo que consome essa API e exibe os resultados e insights.\")\n",
        "print(\"  4. Preparar a apresenta√ß√£o de slides contando a hist√≥ria do projeto, dos dados aos resultados.\")\n",
        "\n",
        "print(\"\\n‚ú® Excelente trabalho! A etapa de modelagem e an√°lise est√° conclu√≠da. ‚ú®\")"
      ],
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 1000
        },
        "id": "qrrGV7ZrGYVu",
        "outputId": "f887f2ae-d192-4602-9d5d-bd8c4dd445b9"
      },
      "execution_count": null,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "‚úÖ Bibliotecas instaladas com sucesso!\n",
            "\n",
            "================================================================================\n",
            "     FASE 3 COMPLETA: MODELAGEM AVAN√áADA + VISUALIZA√á√ïES\n",
            "================================================================================\n",
            "\n",
            "================================================================================\n",
            "ETAPA 1: CARREGANDO DADOS LIMPOS\n",
            "================================================================================\n",
            "‚úÖ Dados carregados com sucesso. Shape: (173, 57)\n",
            "   Total de Jogadores: 173\n",
            "   Total de Colunas: 57\n",
            "\n",
            "================================================================================\n",
            "ETAPA 2: SEPARA√á√ÉO DE FEATURES E TARGETS\n",
            "================================================================================\n",
            "‚úÖ Features (X) separadas. Total de features: 54\n",
            "‚úÖ Targets (y1, y2, y3) separados.\n",
            "\n",
            "================================================================================\n",
            "ETAPA 3: DIVIS√ÉO TREINO/TESTE\n",
            "================================================================================\n",
            "‚úÖ Dados divididos em 80% treino e 20% teste.\n",
            "   Tamanho do treino: 138 jogadores\n",
            "   Tamanho do teste:  35 jogadores\n",
            "\n",
            "================================================================================\n",
            "ETAPA 4: DEFINI√á√ÉO DOS MODELOS\n",
            "================================================================================\n",
            "‚úÖ 7 modelos definidos para teste.\n",
            "\n",
            "================================================================================\n",
            "ETAPA 5: TREINAMENTO E AVALIA√á√ÉO DOS MODELOS\n",
            "================================================================================\n",
            "üéØ Target 1 | Melhor Modelo: CatBoost             | R¬≤ = 0.5766\n",
            "üéØ Target 2 | Melhor Modelo: Random Forest        | R¬≤ = 0.4057\n",
            "üéØ Target 3 | Melhor Modelo: Random Forest        | R¬≤ = 0.4198\n",
            "\n",
            "================================================================================\n",
            "ETAPA 6: VISUALIZA√á√ÉO - PREVISTO vs. REAL\n",
            "================================================================================\n",
            "‚úÖ Gr√°fico de Dispers√£o (Previsto vs. Real) salvo como 'grafico_dispersao_previsto_vs_real.png'\n",
            "\n",
            "================================================================================\n",
            "ETAPA 7: VISUALIZA√á√ÉO - IMPORT√ÇNCIA DAS FEATURES\n",
            "================================================================================\n",
            "‚úÖ Gr√°fico de Import√¢ncia das Features salvo como 'grafico_feature_importance.png'\n",
            "\n",
            "================================================================================\n",
            "ETAPA 8: SALVANDO OS MELHORES MODELOS\n",
            "================================================================================\n",
            "‚úÖ Modelo para Target 1 (CatBoost) salvo como 'modelo_target1_final.pkl'\n",
            "‚úÖ Modelo para Target 2 (Random Forest) salvo como 'modelo_target2_final.pkl'\n",
            "‚úÖ Modelo para Target 3 (Random Forest) salvo como 'modelo_target3_final.pkl'\n",
            "\n",
            "================================================================================\n",
            "üéâ FASE 3 COMPLETA - RELAT√ìRIO FINAL üéâ\n",
            "================================================================================\n",
            "\n",
            "üìä RESUMO DOS MELHORES MODELOS:\n",
            "\n",
            "  TARGET 1\n",
            "  - Melhor Modelo: CatBoost\n",
            "  - R¬≤ (R-quadrado): 0.5766  (Explica ~57.7% da vari√¢ncia)\n",
            "  - RMSE (Erro M√©dio): 16.25 pontos\n",
            "  - MAE (Erro Absoluto M√©dio): 13.75 pontos\n",
            "\n",
            "  TARGET 2\n",
            "  - Melhor Modelo: Random Forest\n",
            "  - R¬≤ (R-quadrado): 0.4057  (Explica ~40.6% da vari√¢ncia)\n",
            "  - RMSE (Erro M√©dio): 22.05 pontos\n",
            "  - MAE (Erro Absoluto M√©dio): 18.98 pontos\n",
            "\n",
            "  TARGET 3\n",
            "  - Melhor Modelo: Random Forest\n",
            "  - R¬≤ (R-quadrado): 0.4198  (Explica ~42.0% da vari√¢ncia)\n",
            "  - RMSE (Erro M√©dio): 16.37 pontos\n",
            "  - MAE (Erro Absoluto M√©dio): 14.50 pontos\n",
            "\n",
            "üìÅ ARQUIVOS GERADOS:\n",
            "  ‚úÖ modelo_target1_final.pkl\n",
            "  ‚úÖ modelo_target2_final.pkl\n",
            "  ‚úÖ modelo_target3_final.pkl\n",
            "  ‚úÖ grafico_dispersao_previsto_vs_real.png\n",
            "  ‚úÖ grafico_feature_importance.png\n",
            "\n",
            "üöÄ PR√ìXIMOS PASSOS:\n",
            "  1. Usar os arquivos '.pkl' salvos para carregar os modelos no seu backend (Node.js/FastAPI).\n",
            "  2. Criar as rotas da API que recebem novos dados de jogadores e usam os modelos para prever os targets.\n",
            "  3. Desenvolver o dashboard interativo que consome essa API e exibe os resultados e insights.\n",
            "  4. Preparar a apresenta√ß√£o de slides contando a hist√≥ria do projeto, dos dados aos resultados.\n",
            "\n",
            "‚ú® Excelente trabalho! A etapa de modelagem e an√°lise est√° conclu√≠da. ‚ú®\n"
          ]
        },
        {
          "output_type": "display_data",
          "data": {
            "text/plain": [
              "<Figure size 1800x500 with 3 Axes>"
            ],
            "image/png": "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lnZIy6xYvHgxbt++DV9fX7x79w7h4eGIi4uDkZERbGxs4OLigv79+0uGUHR2dsbu3buxcuVK3L59G3FxcShXrhw6dOiAkSNHYvbs2V88pqOjI44cOYJ9+/bh7NmzePLkCSIjI6Gvrw9ra2u4uLigT58+qFKlSrbOCZDPz2dqaip5AaBJkyYZ9pIpXrw4li1bBh8fHzx48AAfP35EeHg4EhISYGxsjAoVKqBx48bo37+/ZAiz3NalSxcsWbJEMmQhALi5uWW4fk6vw9cMHz4crVu3hre3N27evImgoCDEx8ejRIkS4u/Id999l6Nkc27Q0dGBu7u7JDHt7e2NoUOHiterffv2qFevHvbs2YMrV67g2bNniIqKgo6ODiwsLFCxYkXUrVsXrq6ukpdEXF1dsWXLFqxduxa+vr5ISUlBhQoV0L17dwwcOBCDBw/Ot/OcNGkSnJ2dsW3bNjx69AgA4ODggMGDB6Ndu3aSdfPr/pPXx2natCmOHz+Ov/76CxcvXsTz588RHR0NQ0ND2NraolGjRujbt6/S33Xbtm2hra2Ne/fu4cmTJwgLC8Pnz5/FYT4dHBzQvn17dO7cOU/mnMyqgnyPy4/fayD7bWBra4uFCxfCx8cHDx8+REhICMLDw5GcnAwTExNUrFgRLVu2RJ8+fVCiRImcNkeuyMlvq5ubG8qXLw8vLy/cu3cPiYmJsLOzg5ubG/r37//F2AGQvzh0/Phx/P333zh//jyePHmCiIgIaGlpoVSpUrCzs0Pt2rXRunVr1KxZM1/Oy93dHU5OTrh37x5evnyJ8PBw8TtWunRpODs74/vvv4eLi0uW6kNERESFi5aQX2OsEBEREREREeWy1q1bS3paZzT0KxERERERUVGg/lf1iIiIiIiIiIiIiIiIiChHmPQjIiIiIiIiIiIiIiIi0nBM+hERERERERERERERERFpOM7pR0RERERERERERERERKTh2NOPiIiIiIiIiIiIiIiISMMx6UdERERERERERERERESk4Zj0IyIiIiIiIiIiIiIiItJwTPoRERERERERERERERERaTgm/YiIiIiIiIiIiIiIiIg0HJN+RERERERERERERERERBqOST8iIiIiIiIiIiIiIiIiDcekHxEREREREREREREREZGGY9KPiIiIiIiIiIiIiIiISMMx6UdERERERERERERERESk4Zj0IyIiIiIiIiIiIiIiItJwTPoRERERERERERERERERaTgm/YiIiIiIiIiIiIiIiIg0HJN+RERERERERERERERERBqOST8iIiIiIiIiIiIiIiIiDcekHxEREREREREREREREZGGY9KPiIiIiIiIiIiIiIiISMMx6UdERERERERERERERESk4Zj0IyIiIiIiIiIiIiIiItJwTPoRERERERERERERERERaTgm/YiIiIiIiIiIiIiIiIg0HJN+RERERERERERERERERBqOST8iIiIiIiIiIiIiIiIiDcekHxEREREREREREREREZGGY9KPiIiIiIiIiIiIiIiISMMx6UdERERERERERERERESk4Zj0IyIiIiIiIiIiIiIiItJwTPoRERERERERERERERERaTgm/YiIiIiIiIiIiIiIiIg0HJN+RERERERERERERERERBqOST8iIiIiIiIiIiIiIiIiDcekHxEREREREREREREREZGGY9KPiIiIiIiIiIiIiIiISMMx6UdERERERERERERERESk4Zj0IyIiIiIiIiIiIiIiItJwTPoRERERERERERERERERaTgm/YiIiIiIiIiIiIiIiIg0HJN+RERERERERERERERERBqOST8iIiIiIiIq0G7cuAEHBwesWrVK3VUhIiIi0miMq4gKN111V4CIpBwcHLK0/uPHj/OoJrlr1apV8PT0xLZt29CgQQOVtwsNDcW+ffvg5+eHhw8fIigoCED+n3dSUhIOHTqEEydO4NGjR/j8+TMMDAxgZ2eHpk2bomfPnrC2ts7Wvt+8eYM2bdrAzc0NCxcuVFq+f/9+TJs2TVKmpaUFY2NjyGQy9OjRAz169MjWsfODg4MDXFxcsH37dnVXhYiI1IgxjtTt27dx+vRp3Lx5E0FBQYiJiYG1tTXatGmDESNGwMTEJA9rnVrvtAwNDVG+fHm0adMGw4YNg7GxcZ7WobAaMGAAbt68menyadOmYfDgwflXoRzK7neciIjyDuMqKV9fX+zatQt+fn74+PEjYmNjUaZMGTg6OmLo0KGoUaNGHtaacVVeYlxFlHVM+hEVMB4eHkplW7duRWRkZIbLCrunT59i2bJl0NLSgq2tLYoVK4bY2Nh8rUNQUBBGjRqFgIAAWFhYoHHjxihbtixiYmLw6NEjbNiwAZs2bcLRo0dha2ubZ/Vo1KgR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1aEAAAAXQl5VdeRVAADgfMirqo68CnAdFP0AVEpCQoI6deqk/Pz8X3zOM888o8jISOXk5NRiZLVv3LhxCgsLK/8TGRmpW2+9VXPmzFFhYaHV4QEAABdHXlWBvAoAAFwK8qoK5FUAJMnT6gAAuIe+fftq8+bN+uijj3T33Xefc7ygoED//Oc/1bNnTwUGBtZ+gLXM29tb06ZNkyTl5+fr448/1vz58/X9999r9uzZNfa6d911l+644w55e3vX2GsAAICaRV7ljLwKAABcLPIqZ+RVAJjpB6BSevXqpUaNGmndunXnPf7xxx/r9OnT6tu3by1HVuH06dO19lqenp666667dNddd+mBBx7Q0qVLFRMTow0bNujEiRM19roeHh7y8fGRzWarsdcAAAA1i7zKGXkVAAC4WORVzsirAFD0A1ApDRo00C233KIvvvhCWVlZ5xxfv369GjVqpF69eunkyZN66aWX1KdPH8XGxiouLk6PPvqo9uzZU6nX2rJli+6//37FxMTommuu0YgRI7R//36n57z++usKCwvTvn379Mwzz6hz5866//77y49/8MEH6t+/v6Kjo9WlSxeNGjVK//3vf53OcfDgQT3xxBPq0aOHoqKidN1112nUqFE6depUlfvHZrMpLi5OhmHohx9+cDr26aeflr+f2NhYDR8+XHv37nV6zp49ezRu3DjdeOONioqKUo8ePfTcc8+ds/TE+dZIT0tL09ChQ9W1a1dFR0erV69eeu6556r8HgAAQO0gr7ow8ioAAFBZ5FUXRl4F1D8s7wmg0vr06aP3339fH374oQYPHlzefvLkSf373//WHXfcoQYNGmjv3r366KOPdNttt6l169Y6ceKE/vKXv2jw4MHasGGDWrRo8YuvkZKSomHDhql169ZKTEzUmTNntGLFCg0aNEjvvfeeWrdu7fT8p556Sm3bttWoUaNkGIYkacGCBZozZ4569+6te+65R9nZ2VqxYoUeeOABrV27Vo0bN1ZRUZGGDh2qoqIiDR48WEFBQTp69Kg++eQT5eXlyd/fv8r98+OPP0qSGjduXN62du1ajRs3Tj179lRSUpIKCgq0atUq3X///Xr//ffL309KSop++OEH9e/fX82aNdPevXu1evVq7du3T6tXr/7FkVJZWVkaOnSoAgMDNXz4cDVu3FiHDx/Wpk2bqhw/AACoPeRV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\n"
          },
          "metadata": {}
        },
        {
          "output_type": "display_data",
          "data": {
            "text/plain": [
              "<Figure size 2000x800 with 3 Axes>"
            ],
            "image/png": "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tmzKmTOnihcvrrJly+rdd9+Vh4dHkuqVWBEREdqwYYPWrVunY8eO6c6dO3JwcFCBAgVUq1Ytde7cWS+//LLFfkm5PnGveYzBgwebfa/GvBee9X0rmX8e8ufPry1bthivre3/3nvvadKkSdq5c6du3bqlpk2basyYMcY2N27c0MKFC7Vjxw5duHBBDx48kIuLi0qWLKnGjRvrvffek6Ojo0Udkvu6WvueGDp0qH777Tf9+eefunbtmrJnz65atWqpV69eFp+DO3fuaP78+Tpx4oTOnTunkJAQhYaGyt7eXjly5FCJEiXk4+OjJk2aKFMm89nlEtNuz3OehErK96yU8p81V1dXPXnyRI8fP9aePXt06tQpeXp6SooeFefy5cuSpDx58uj69evPPN7jx4+1YsUKbd68WSdOnFBoaKgyZ86swoULy9vbW+3bt1eOHDmSVNbYQkJC9Ntvv+mvv/7S9evX5erqqjp16qhfv37KkyeP1X3Onj2rBQsWaO/evQoKCtKTJ0+ULVs2FS9eXG+99ZZatmxp8Tt5+fJlvfXWW8brqlWr6rffftPUqVO1ceNGXblyRR4eHmaf2aS2wdWrVzV79mwjfnr48KFeeuklubm5qXDhwipbtqzefvttlSpVKsntFnMd7927p5UrV6p9+/aSpODgYK1bt87YLnfu3Lpx40a8x4qKitLmzZu1Zs0aHT16VLdv35adnZ1y5cqlChUqqEWLFnr99det7hsREaG5c+dq2bJlunDhgrJmzaoqVaqoZ8+eCa7LiRMntGDBAu3fv19Xr15VWFiYcubMqQoVKqh169aqWbNmgo+VXPVat26d1qxZo+PHj+v27dsymUxyc3NT7ty5VbJkSZUpU0atWrWSvb19ksoGAAAAcyTGAQAAkllMj/AYWbNmVefOnbVlyxYdPnxYUnQSLfaN5PgMHDhQK1euNFsWGBiogQMHKiQkRB988IHZut9//12nT5+2OE5ISIgOHTqkQ4cOaf78+Zo5c6ZKliyZ+ApaERYWpg4dOigwMNBseXh4uB4+fKgrV67owIED2r9/v0VifN68eRo9erTFfOzBwcHaunWrtm7dqjp16mj8+PFydnZOcJnu37+vzp07KyAgwOyYq1at0ubNm9WkSZN494+IiNCwYcOszgEck7hdtWqV/ve//6lv374JLldSjB49Wps3bzZeP3r0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NHr0aH344Yfq3r27GjRooPz588vf31979+412i6p269atUqLFi1SlSpVjKd3z5w5o+3bt8vNzc2sbatXr65NmzapT58+ql27tjJnzqwSJUrI29vb2Gbnzp2SlOD3KAAAGRlxYOrFgfH56KOPtGjRIs2cOVMdO3ZU9uzZ1aFDB+3YsUPt2rVTo0aN5OTkpL179+r69euqWrWq1R5RiVG4cGH17NlTEyZMMOptb2+vP//8U15eXlZ7dH311Vdq166dhg0bJl9fX7366qs6ffq0tmzZopw5c+qrr756rjKlpKRc5/jUqVNHPXv21K+//qr69eurdu3aypcvn0JCQnTx4kUdOHBA/fr1U7FixfT48WO1bdtWRYoUUZkyZZQ3b149fPhQW7du1c2bN9W1a1fjodGiRYsqd+7cWrdunZycnJQnTx7Z2dmpY8eOxjCkDx480OHDh/X6668ra9asKdJeAAAkN+JO4k7iTuJOIClIjANIdu+//74mT56s1atXJygwTaxGjRrJw8NDU6ZM0V9//aVHjx4pf/786tmzpz766COzHsFS9BNz2bJl06+//qoVK1YoW7Zs8vb21oABA6w+Tefk5KTff/9dS5cu1cqVK/Xnn38qLCxMuXLlUrFixdSmTZsEDfXSpUsXFSpUSDNnztTq1asVHh6uIkWKaNCgQerYseNT53lJjCxZsuinn35Sy5YttWzZMvn7++uff/6RJOXNm1c+Pj5q1aqVMde3vb29pkyZoh9//FH//POPjh49qsKFC+v//u//VKdOHauJ8Z49e+ru3bvy9fXVgQMHFBkZqV69elkkxidOnGi8dnJy0ssvv6y2bduqe/fuRk/1GJUrV9aiRYs0adIk7dy5U/fv31fu3LnVqVMn/e9//7OYYyYx2zdp0kRPnjyRv7+/jhw5orCwMKMs3bp1MytLq1atFBQUpPXr12vatGnGE7+xE+Nr1qxRyZIljTYEAABPRxwYLTXiwPjkypVLbdu21fTp0zVjxgz17dtXb775psaPH68pU6Zo9erVypIli6pXr65JkyZp0qRJyXLeXr16KU+ePJo5c6YWLlwod3d3+fj4qG/fvipfvrzF9kWLFtWyZcs0ceJE/fPPP9q2bZty5Mih5s2bq1evXhZzKKY3yX2d+/btqypVqmj27NnavXu37t27Jzc3NxUoUEC9evXSO++8I0lydnbW559/rj179mj//v26deuWXF1d9corr+jTTz9V48aNjWPa29tr4sSJ+vHHH7V27Vo9ePBAUnSvuZgblH/++aceP36s1q1bJ1PLAACQ8og7oxF3EncSdwKJY2eKO6kCACSDAQMGaNu2bdqyZYsx3w7wotm1a5e6dOmi7777Tu+9915aFwcAgBcCcSDwYmnXrp1u3bql9evXG3NDAgDwIiDuBF4sxJ1ID5hjHECK6Nevnx4/fqy5c+emdVGAJJs4caJKliyppk2bpnVRAAB4YRAHAi+O3bt368CBA/r888+5OQkAeOEQdwIvDuJOpBcMpQ4gReTPn19jxozRrVu30rooQJKEhISoRo0aevPNN5UpE8+RAQCQUMSBwIvj3r17GjhwoN5+++20LgoAAIlG3Am8OIg7kV4wlDoAAAAAAAAAAAAAwKbRBQ4AAAAAAAAAAAAAYNNIjAMAAAAAAAAAAAAAbBpzjKczUVFRioiIUKZMmWRnZ5fWxQEAADbEZDIpKipKDg4OypSJ5yMzOuJOAACQUog7ERexJwAASCmJiT1JjKczEREROnr0aFoXAwAA2LCyZcvKyckprYuBNEbcCQAAUhpxJ2IQewIAgJSWkNiTxHg6E/MkQ6lSpfjDwUZERkbq6NGjKlu2rOzt7dO6OEgGXFPbwzW1PVxT62LahV47kDJu3JkRvx8yYp2ljFlv6pwx6ixlzHpnxDpLL269iTsRV0aNPWN7UT/PySmjt0FGr79EG0i0gUQbSLSBlLxtkJjYk8R4OhMzlJC9vX2G/TDYKq6p7eGa2h6uqe3hmlrH0IWQiDszYr0zYp2ljFlv6pxxZMR6Z8Q6Sy9uvYk7ESOjx56x0Qa0QUavv0QbSLSBRBtItIGUvG2QkNiTxzYBAAAAAAAAAAAAADaNxDgAAAAAAAAAAAAAwKaRGAcAAAAAAAAAAAAA2DQS4wAAAAAAAAAAAAAAm0ZiHAAAAAAAAAAAAABg00iMAwAAAAAAAAAAAABsGolxAAAAAAAAAAAAAIBNIzEOAAAAAAAAAAAAALBpJMYBAAAAAAAAAAAAADaNxDgAAAAAAAAAAAAAwKaRGAcAAAAAAAAAAAAA2DQS4wAAAAAAAAAAAAAAm0ZiHAAAAAAAAAAAAABg00iMAwAAAAAAAAAAAABsGolxAAAAAAAAAAAAAIBNIzEOAAAAAAAAAAAAALBpJMYBAAAAAAAAAAAAADaNxDgAAAAAAAAAAAAAwKaRGAcAAAAAAAAAAAAA2DQS4wAAAAAAAAAAAAAAm0ZiHAAAAAAAAAAAAABg00iMAwAAAAAAAAAAAABsGolxAAAAAAAAAAAAAIBNIzEOpAJnZ+e0LgKSGdfU9nBNbQ/XFMDTZMTvh4xYZylj1ps6ZxwZsd4Zsc5Sxq03YIv4PNMGGb3+Em0g0QYSbSDRBmnFzmQymdK6EPhPZGSkDh06pAoVKsje3j6tiwMAAFJJZFSU7DOl7DOLxBmIjfcDAAAZV0rHnsQZiIv3BAAAGdPT4s7kjA0ScyyH5zoTUsyHmzbpcHBwWhcDAACkgpLu7prXuHFaFwMZFHEnAAAZC7En0hKxJwAAGUd6jDtJjKdTJ2/flv+NG2ldDAAAANg44k4AAACkFmJPAACQlphjHAAAAAAAAAAAAABg00iMAwAAAAAAAAAAAABsGolxAAAAAAAAAAAAAIBNIzEOAAAAAAAAAAAAALBpJMYBAAAAAAAAAAAAADaNxDgAAAAAAAAAAAAAwKaRGAcAAAAAAAAAAAAA2DQS4wAAAAAAAAAAAAAAm0ZiPAG8vb01c+bMtC4GAAAAAAAAAAAAACAJ0n1i3N/fXyVLllT37t3TuigAAACABg0aJC8vL4t/Fy9e1L59+9SjRw/VqlVLXl5e2rx5s8X+f/75p7p27apq1arJy8tLx48ft9jmyZMnGjFihKpVq6aKFSuqd+/eCg4ONtYvX77cahm8vLx069atFK0/AAAAUkd6iDslWS3DunXrUqzeAAAAKSXdJ8aXLl2qDh06aN++fbp+/XqKnScyMlJRUVEv3LEBAACQ+mrXrq0dO3aY/StQoIAePnwoLy8vffnll0/d9+HDh6pUqZI+//zzp27z7bffytfXV+PGjdOcOXN048YN9erVy1jv4+Njcf5atWqpatWqcnd3T9a6AgAAIO2kddwZY/To0WZlqFevXrLUDwAAIDU5pHUB4vPgwQOtX79ey5YtU3BwsFasWKEePXoY67ds2aJJkybp1KlTypo1qypXrqxJkyZJkkJDQ/XNN9/I19dXYWFhqlKlir744gsVKVJEUnQvm2+//Vbfffedxo4dqwsXLujPP/+Us7Ozhg4dql27dilXrlzq16+fRblmzJih5cuX699//5Wrq6vefPNNDRgwQC+99FK8xy5QoECKtxkAAHhxRUZGvtDHz0icnJzk4eFhsbxu3bqqW7duvPu+9957kqTLly9bXX/v3j0tW7ZMP/74o2rUqCEp+oalj4+PDh06pAoVKihLlizKkiWLsc/t27fl5+enUaNGJbFGAAAgo0nJ2JC4M/mkddwZI3v27FbLAQAA8CzWYsOYZckRNybmGOk6Mb5hwwYVLVpURYsWVdOmTfXtt9/q448/lp2dnbZu3apevXqpR48e+v777xUeHq5t27YZ+w4aNEgXL17U5MmT5eLioh9++EHdu3fXunXr5OjoKEl6/Pixfv/9d40aNUpubm5yd3dXnz59dOPGDc2ePVsODg4aNWqUxXCUdnZ2Gjp0qAoUKKB///1XI0aM0A8//KCvvvrK2MbasQEAAOJz8uRJPXr0KK2LgTQWEBCg8PBwvf7668ayYsWKKV++fBY3KGOsXLlSWbJkUcOGDVOxpAAA4EVG7InExJ0jRozQ0KFDVbBgQbVp00YtWrSQnZ1dGpQaAAC8aOKLO48ePZqqZUnXifGlS5eqadOmkqKHDbp375727t2ratWq6bfffpOPj4/69OljbF+iRAlJ0oULF7RlyxYtWLBAlSpVkiT9+OOPeuONN7R582Y1atRIkhQeHq6vvvrK2O/8+fPavn27lixZonLlykmSvvnmG/n4+JiV64MPPjD+X6BAAfXr109ffvmlWWI87rEBAACexcvLK0WPHxkZmerBpq3aunWrKlasaLyuXbu2xo8fnyzHDg4OlqOjo7Jnz2623N3dXTdv3rS6z9KlS9WkSROzXuQAAADxScnYk7gz+aSHuLNPnz6qXr26nJ2dtWPHDo0YMUIPHz5Up06dkqUcAADAtlmLO2PixbJly8re3v65jp+Y2DPdJsbPnTuno0ePGkOjOzg4yMfHR0uXLlW1atV0/Phxvf/++1b3PXv2rBwcHFS+fHljWY4cOfTKK6/o7NmzxjJHR0ezixGzX5kyZYxlxYoVswgOd+3apSlTpujcuXO6f/++IiMj9eTJEz169EjOzs5Wjw0AAPAszxsEIvVUq1bN7KHImBgwLfj7++vs2bP6/vvv06wMAADgxUPs+WJID3HnJ598Yvy/VKlSevTokf744w8S4wAAIEHiizvt7e1TNS5Nt4nxpUuXKiIiQrVr1zaWmUwmOTk5afjw4cnSGyZLliyJHvLn8uXL+vjjj9W2bVv1799frq6uOnDggIYOHarw8HAjOE3KsQEAAPBicHZ2VuHChVPk2Lly5VJ4eLju3r1r9oDmrVu3rM7ruGTJEpUsWdLs4U4AAADYhvQUd8YoX768fv31V4WFhcnJySlFygYAAJASMqV1AayJiIjQqlWrNGjQIK1cudL4t2rVKuXOnVtr166Vp6endu/ebXX/YsWKKSIiQocPHzaW3blzR+fPn9err7761PMWLVpUERERCggIMJadO3dOd+/eNV4HBgbKZDJp0KBBqlChgl555RXduHEjGWoNAAAASGXKlJGjo6NZrHvu3DlduXLFYn7xBw8eaMOGDWrZsmUqlxIAAAAvusTEnbEdP35crq6uJMUBAMALJ132GN+6datCQ0PVsmVLZcuWzWxd/fr1tXTpUv3f//2fPvjgAxUqVEiNGzdWRESEtm3bpu7du6tIkSJ66623NGzYMI0YMUIuLi768ccflSdPHr311ltPPW/RokVVu3ZtY75we3t7ffvtt2a90wsXLqzw8HDNmTNH3t7eOnDggBYuXJhibQEAAIAXx4MHD3Tp0iXj9eXLl40bh/ny5ZMkhYSE6OrVq8bDlefPn5cU3WPHw8ND2bJlU4sWLTRmzBi5urrKxcVFo0aNUsWKFS1uUK5fv16RkZFq2rRp6lQQAAAA6UJqxZ1btmzRrVu3VL58eWXOnFk7d+7UlClT1LVr19StMAAAQDJIl4nxpUuX6vXXX7dIiktSgwYNNG3aNLm6uuqXX37Rr7/+qqlTp8rFxUVVqlQxths9erS++eYb9ejRQ+Hh4apcubKmTp0qR0fHeM89evRoffHFF+rQoYNy5cqlvn37avz48cb6EiVKaPDgwfr999/1008/qXLlyvr00081cODA5GsAAAAAvJACAgLM5locPXq0JKlZs2YaM2aMpOibi4MHDza26d+/vySpV69e6t27tyRpyJAhypQpk/r06aOwsDDVqlVLX375pcX5li1bprffftts6EsAAADYvtSKOx0cHDRv3jx9++23kqRChQpp0KBBatWqVcpWEAAAIAXYmUwmU1oXAv+JjIzUoUOH1Pv4ce2+di2tiwMAAFJBxdy5dTDWTa2UEhNnVKhQQfb29il+PqRvxJ0AAGRMqRF7EnciLmJPAAAynvjizuSMFxNzrHQ5xzgAAAAAAAAAAAAAAMmFxDgAAAAAAAAAAAAAwKaRGAcAAAAAAAAAAAAA2DQS4wAAAAAAAAAAAAAAm0ZiHAAAAAAAAAAAAABg00iMAwAAAAAAAAAAAABsmkNaFwDWeeXMqcdRUWldDAAAkApKurundRGQgRF3AgCQsRB7Ii0RewIAkHGkx7iTxHg6Na1BA9nb26d1MQAAQCqJjIqSfSYG80HqI+4EACDjIfZEWiH2BAAgY0lvcWf6KQnMREZGpnURkEwiIyN17NgxrqkN4ZraHq6p7XkRr2l6ChCRsbxIn5Pk8CJ+PzyvjFhnKWPWmzpnHBmx3hmxzlLK1ZvYE2klo32GY8uo32OxZfQ2yOj1l2gDiTaQaAMpY7VBeos701dpABv16NGjtC4CkhnX1PZwTW0P1xTA02TE74eMWGcpY9abOmccGbHeGbHOUsatN2CL+DzTBhm9/hJtINEGEm0g0QZphcQ4AAAAAAAAAAAAAMCmkRgHAAAAAAAAAAAAANg0EuMAAAAAAAAAAAAAAJtGYhxIBc7OzmldBCQzrikAAC+ujPg7nhHrLGXcegMAgPSJ2IQ2yOj1l2gDiTaQaAOkHYe0LgCss7e3T+siIJnY29urVKlSaV0MJCOuafoWGRUl+0w89wUACZXR4s6M+DueEessWdabGAEAgLSX0WLP2DJqTBZbRm+DjF5/iTaQaAMp9dqAvwFhDYnxdOrDTZt0ODg4rYsBAC+Uku7umte4cVoXAwBeKMSdyAiIEQAASB+IPQEAqYG/AfE0JMbTqZO3b8v/xo20LgYAAABsHHEnAAAAUguxJwAASEuMIQAAAAAAAAAAAAAAsGkkxgEAAAAAAAAAAAAANo3EOAAAAAAAAAAAAADAppEYBwAAAAAAAAAAAADYNBLjAAAAAAAAAAAAAACbRmIcAAAAAAAAAAAAAGDTSIwDAAAAAAAAAAAAAGwaiXEAAAAAAAAAAAAAgE0jMQ4AAAAAAAAAAAAAsGk2kRgfNGiQvLy8LP5dvHhRkjRv3jx5e3urbNmyev/993XkyBFj38uXL1vd18vLSxs2bDC2GzVqlJo3b64yZcro3XfftSjDkydPNGjQIL3zzjsqVaqUevbsmfIVBwAAyOBSIw4EAAAA0kJ8se6+ffvUo0cP1apVS15eXtq8ebPF/n/++ae6du2qatWqycvLS8ePH7fY5smTJxoxYoSqVaumihUrqnfv3goODjbW37lzR926dVOtWrVUpkwZ1a1bVyNHjtT9+/dTtO4AAAApwSGtC5BcateurdGjR5sty5kzp9avX6/Ro0drxIgRKl++vGbNmqVu3bpp48aNcnd3V968ebVjxw6z/RYtWqQ//vhDderUMVveokULHT58WCdPnrQ4f2RkpDJnzqyOHTtq06ZNyV9BAAAAWJUacSAAAACQFp4W6164cEFeXl5q0aKFevXqZXXfhw8fqlKlSmrUqJG++OILq9t8++232rZtm8aNG6ds2bLp66+/Vq9evbRw4UJJUqZMmfTWW2+pX79+ypkzpy5duqQRI0YoNDRUY8eOTd7KAgAApDCbSYw7OTnJw8PDYvmMGTPUqlUrtWjRQpI0YsQIbd26VcuWLVP37t1lb29vsd/mzZvVqFEjvfTSS8aymODx9u3bVhPjWbNm1YgRIyRJBw8e1N27d5OtbgCAxImMjEzS9ondD+kX19Q6W22PlI4Dn8bPz0+dOnXStGnTNHbsWJ07d04VKlTQzz//rICAAI0ZM0bXr1/Xm2++qVGjRsnZ2VmSFBUVpd9//12LFi1ScHCwihQpop49e6phw4aSoq/TsGHDtGfPHgUHBytv3rxq166dOnfubJx70KBBunv3rl577TXNmDFD4eHh8vHx0ZAhQ+To6JjktgRsna1+D8bIiL9/GbHOUsasd0ass/Ti1vtFK2969rRYt27duqpbt268+7733nuSokdKsubevXtatmyZfvzxR9WoUUNSdKLcx8dHhw4dUoUKFeTq6qp27doZ++TPn1/t2rXTH3/8kcQaAQCQetJrTPKixnjJKTnbIDHHsJnEuDVhYWEKDAzUxx9/bCzLlCmTXn/9dfn7+1vdJyAgQMePH9fw4cNTq5gAgGR28uRJPXr0KNH7HT16NAVKg7TENc24UjMOnDhxooYNGyZnZ2f169dP/fr1k5OTk8aOHauHDx/qk08+0Zw5c9S9e3dJ0pQpU7R69WqNGDFCRYoU0b59+zRgwADlzJlTVatWVVRUlF5++WX98ssvcnNzk7+/v4YPHy4PDw/5+PgY5/Xz85OHh4dmzZqlS5cuqX///ipZsqRatWqVhBYDMoakxggvmoz4+5cR6yxlzHpnxDpLGbfeSFkBAQEKDw/X66+/biwrVqyY8uXLZyTG47p+/br++usvValSJRVLCgBA0qT3vwGJ8VK/DWwmMb5161ZVrFjReF27dm0NHTpUkZGRcnd3N9vW3d1d586ds3qcpUuXqlixYqpUqVKKlhcAkHK8vLwStX1kZKSOHj2qsmXLyt7ePoVKhdTENbUupl1sTVrHgf369dNrr70mSWrZsqXGjh2rzZs3q2DBgpKkBg0ayM/PT927d1dYWJimTJmiGTNmGGUuWLCgDhw4oEWLFqlq1apydHRUnz59jOMXLFhQhw4d0saNG80S466urho+fLjs7e1VrFgx1a1bV7t37yYxDsQjsTHCiyYj/v5lxDpLGbPeGbHO0otbb1uNO9OCtVh3/PjxyXLs4OBgOTo6Knv27GbL3d3ddfPmTbNln376qf7++289fvxYb775pr755ptkKQMAACkpvf4N+KLGeMkpOdsgMbGnzSTGq1Wrpq+++sp47ezsLJPJlKhjPH78WGvXrlXPnj2TuXQAgNSU1B9Se3v7DBuI2CquacaQ1nFg7D+y3N3d5ezsbCTFJSlXrlxGcH7x4kU9evRIXbt2NTtGeHi4SpYsabyeN2+eli1bpitXrujJkycKDw9XiRIlzPZ59dVXzd7fHh4eOnXqVKLLD2QkGeU3ISP+/mXEOksZs94Zsc5Sxq03rMe6aWHw4MH65JNPdOHCBf30008aPXq0WbkAAEiP0nv8RIyX+m1gM4lxZ2dnFS5c2GxZWFiY7O3tdevWLbPlt27dUq5cuSyOsXHjRj1+/NiYfwcAAADpX1rHgQ4O/4XUdnZ2Zq9jlkVFRUmSHj58KCl6OPU8efKYbefk5CRJWrdunb777jsNHDhQFStW1EsvvaQ//vhDhw8ffup5Y86T2AcCAAAAkL5Zi3WTS65cuRQeHq67d++a9Rq/deuWxbzmHh4e8vDwULFixeTq6qr27durZ8+eyp07d4qUDQAAICVkSusCpCQnJyeVLl1au3fvNpZFRUVp9+7dZkMQxVi2bJm8vb2VM2fO1CwmAAAAkll6jQOLFSsmJycnXblyRYULFzb7lzdvXknSwYMHVbFiRbVv316lSpVS4cKFdenSpRQtFwAAADKeMmXKyNHR0SxmPnfunK5cuWJ1fvEYMQ9jhoWFpXQRAQAAkpXN9Bh/mi5dumjgwIEqU6aMypUrp1mzZunRo0dq3ry52XYXL17Uvn37NHXqVKvHuXjxoh4+fKibN2/q8ePHOn78uKT/bm5K0pkzZxQeHq6QkBA9ePDA2Cb2sJgAAABIHckVByYnFxcXde3aVaNHj5bJZNJrr72me/fu6eDBg3JxcVGzZs1UuHBhrVy5Uv/8848KFCigVatW6ejRoypQoECKlw8AAAAvhgcPHpg9PHn58mUdP35crq6uypcvnyQpJCREV69e1Y0bNyRJ58+flxTdU9zDw0PZsmVTixYtNGbMGLm6usrFxUWjRo1SxYoVjcT4tm3bFBwcrLJlyypr1qw6c+aMvv/+e1WqVIn4FAAAvHBsPjHu4+Oj27dva/z48bp586ZKliypadOmWQyhuWzZMr388suqVauW1eN88cUX2rt3r/E6ZpjNv//+2wgCu3fvrqCgIIttTp48mYw1AgAAQEIkVxyY3Pr166ecOXNqypQpunz5srJly6ZSpUqpR48ekqQ2bdro+PHj6t+/v+zs7NS4cWO1a9dO27dvT5XyAQAAIP0LCAhQp06djNejR4+WJDVr1kxjxoyRJG3ZskWDBw82tunfv78kqVevXurdu7ckaciQIcqUKZP69OmjsLAw1apVS19++aWxT+bMmbVkyRKNHj1aYWFhyps3r95++2117949xesIAACQ3OxMTESYrkRGRurQoUPqffy4dl+7ltbFAYAXSsXcuXUw1o2BhIr57q1QoYLs7e1ToGRIbVxT62gXxEbciYwkqTHCiyYjfs9nxDpLGbPeGbHO0otb7xe13Eg5xJ4AgNSU3v8GJFZK3jZIzLFseo5xAAAAAAAAAAAAAABsfih1AAAAICmGDx+uNWvWWF33zjvvaOTIkalcIgAAAAAAAABJRWIcAAAAsKJv377q1q2b1XUuLi6pXBoAAAAAAAAAz4PEOAAAAGCFu7u73N3d07oYAAAAAAAAAJIBc4wDAAAAAAAAAAAAAGwaiXEAAAAAAAAAAAAAgE1jKPV0yitnTj2OikrrYgDAC6UkQx4DQKIRdyIjIEYAACB9IPYEAKQG/gbE05AYT6emNWgge3v7tC4GALxwIqOiZJ+JAVEAIKGIO5FRECMAAJD2iD0BAKmFvwFhDe+IdCoyMjKti4BkEhkZqWPHjnFNbQjXNH0j2AGAxMlov2cZ8Xc8I9ZZsqw3MQIAAGkvo8UjsWXUmCy2jN4GGb3+Em0g0QZS6rUBfwPCGt4VQCp49OhRWhcByYxrCgDAiysj/o5nxDpLGbfeAAAgfSI2oQ0yev0l2kCiDSTaAGmHxDgAAAAAAAAAAAAAwKaRGAcAAAAAAAAAAAAA2DQS4wAAAAAAAAAAAAAAm0ZiHAAAAAAAAAAAAABg00iMA6nA2dk5rYuAZMY1BQDgxZURf8czYp0BAADSG2Iy2iCj11+iDSTaAEhLDmldAFhnb2+f1kVAMrG3t1epUqXSuhhIRlzTlBUZFSX7TDy3BQCpJaPFnRnxd9xW6kyMAADAiy+jxZ6x2UpM9jwyehtk9PpLtIGUsdqAv+GQHpEYT6c+3LRJh4OD07oYAJCqSrq7a17jxmldDADIUIg78SIgRgAAwDYQewJAxsDfcEivSIynUydv35b/jRtpXQwAAADYOOJOAAAApBZiTwAAkJYYwwAAAAAAAAAAAAAAYNNIjAMAAAAAAAAAAAAAbBqJcQAAAAAAAAAAAACATSMxDgAAAAAAAAAAAACwaSTGAQAAAAAAAAAAAAA2jcQ4AAAAAAAAAAAAAMCmkRgHAAAAAAAAAAAAANg0EuMAAAAAAAAAAAAAAJvmkNANvby84l3fq1cv9e7d+7kLlBJGjRqlgwcP6tSpUypWrJhWrVpltv7Jkyf68ssvFRgYqLNnz+qNN97Qr7/+arbNjRs39N133ykgIEAXL15Ux44dNXToULNtFi9erJUrV+r06dOSpNKlS+vTTz9VuXLlUraCAAAANobYk9gTAAAgvRk0aJBWrFhhsfzPP/9U4cKFNW/ePP3xxx+6efOmSpQooWHDhhmx2eXLl/XWW29ZPe64cePUqFGjFC07AAAAEpEY37Fjh/H/9evXa/z48dq4caOxLGvWrMlbsmTWokULHT58WCdPnrRYFxkZqcyZM6tjx47atGmT1f3DwsKUI0cO/e9//9PMmTOtbuPn56fGjRurUqVKcnJy0rRp09S1a1etW7dOefLkSc7qAAAA2DRiT2JPAACA9Kh27doaPXq02bKcOXNq/fr1Gj16tEaMGKHy5ctr1qxZ6tatmzZu3Ch3d3flzZvXLMaVpEWLFumPP/5QnTp1UrMKAAAAGVaCE+MeHh7G/7NlyyY7OzuzZUuWLNH06dN1+fJl5c+fXx07dlT79u0l/fdE5M8//6y5c+cqICBAxYsX148//qh79+7pq6++0vnz5/Xaa6/p+++/V86cOSVFP4V59+5dlSpVSnPnzlVYWJiaNGmiL774Qk5OTpKibxp+//33Wrdune7fv68yZcpo8ODBZj1lvvjiC0nS7du3rd6czJo1q0aMGCFJOnjwoO7evWuxTYECBYzjLFu2zGobjR071uz1qFGjtGnTJu3evVvvvfde/A0MADBERkamyflS+7xIOVxT616k9iD2JPYErEnM91hG/C2gzhlHRqx3Rqyz9OLW+0Urb2I4OTmZxaUxZsyYoVatWqlFixaSpBEjRmjr1q1atmyZunfvLnt7e4v9Nm/erEaNGumll1565nn9/PzUqVMnTZs2TWPHjtW5c+dUoUIF/fzzzwoICNCYMWN0/fp1vfnmmxo1apScnZ0lSVFRUfr999+1aNEiBQcHq0iRIurZs6caNmwoKfpaDRs2THv27FFwcLDy5s2rdu3aqXPnzsa5Y+Lk1157TTNmzFB4eLh8fHw0ZMgQOTo6JrktAQC2z1pM8KLGN8mJNkjeNkjMMRKcGI/P6tWr9csvv2j48OEqWbKkjh8/rmHDhilr1qxq1qyZsd2ECRM0ZMgQ5cuXT0OGDNFnn32ml156SUOHDpWzs7P69eunX375xbhRKEm7d+9W5syZNWfOHAUFBWnw4MHKkSOH+vfvL0n6/vvvtWnTJo0ZM0b58+fXtGnT9OGHH+rPP/+Um5tbclQvyR49eqSIiAi5urqmaTkA4EVz8uRJPXr0KNXPe/To0VQ/J1IW19Q2EXtaR+yJjCApMUJG/C2gzhlHRqx3RqyzlHHr/aIICwtTYGCgPv74Y2NZpkyZ9Prrr8vf39/qPgEBATp+/LiGDx+eqHNNnDhRw4YNM+LZfv36ycnJSWPHjtXDhw/1ySefaM6cOerevbskacqUKVq9erVGjBihIkWKaN++fRowYIBy5sypqlWrKioqSi+//LJ++eUXubm5yd/fX8OHD5eHh4d8fHyM8/r5+cnDw0OzZs3SpUuX1L9/f5UsWVKtWrVKQosBADKK+P6GI76hDaTUb4NkSYxPmDBBgwYNUv369SVJBQsW1JkzZ7Ro0SKzm5Ndu3ZV7dq1JUmdOnXSp59+qpkzZ+q1116TJLVs2VLLly83O7aTk5O+/fZbOTs7q3jx4urTp4++//579e3bV48fP9bChQs1evRo1a1bV5L09ddfa+fOnVq6dKk+/PDD5Khekv3444/KnTu3Xn/99TQtBwC8aJ41t3Byi4yM1NGjR1W2bFnZ29un6rmRMrim1sW0y4uO2NM6Yk9kBImJETLibwF1zhh1ljJmvTNinaUXt962Endas3XrVlWsWNF4Xbt2bQ0dOlSRkZFyd3c329bd3V3nzp2zepylS5eqWLFiqlSpUqLO369fP7N4duzYsdq8ebMKFiwoSWrQoIH8/PzUvXt3hYWFacqUKZoxY4ZR5oIFC+rAgQNatGiRqlatKkdHR/Xp08c4fsGCBXXo0CFt3LjRLDHu6uqq4cOHy97eXsWKFVPdunW1e/duEuMAgHhZ+xvuRY1vkhNtkLxtkJjY87kT4w8fPtSlS5c0dOhQDRs2zFgeERGhbNmymW0b+wMQEyjGXXb79m2LfWKG/pGkihUr6uHDh7p69aru3bun8PBwswDS0dFR5cqV09mzZ5+3as9l6tSpWr9+vWbPnq3MmTOnaVkA4EWTVsGAvb19hg1EbBXX1PYQe1pH7ImMIinf6Rnxt4A6ZxwZsd4Zsc5Sxq13elStWjV99dVXxmtnZ2eZTKZEHePx48dau3atevbsmejzx41nnZ2djaS4JOXKlcu4MXzx4kU9evRIXbt2NTtGeHi4SpYsabyeN2+eli1bpitXrujJkycKDw9XiRIlzPZ59dVXzd6DHh4eOnXqVKLLDwDIWOKLX4hvaAMp9dsgWRLjUnRvmfLly5uty5Qpk9nr2HPO2NnZRRfAwcFsWVRU1PMWKc398ccfmjp1qmbMmGERRAIAACDpiD0tEXsCAP4fe3ceHkWB7f//QzoJBIhRElBZZMYgTYBAyHDNwC+RIS4MuIVEQWUZFQWEsKoQCEviIGEdGUS/ICAuX+bivUTRUQQuMigMqAhEEgxBhAkgjlkQUUhI6OT3Bzf9pU1Alu6u7qr363l4Hru6uuqcU1J9qNNdDcB7QkJC1Lp1a5dlFRUVstlsKi0tdVleWlqqiIiIWttYt26dysvLlZSUdNn7/2U/e/7jmmU1PW5N77xkyRJdf/31LusFBwdLkj744APNnj1bEydOVJcuXdSoUSMtX75cX3755QX3W7Ofy/1AAAAAgNGuejAeERGhZs2a6ciRI7rvvvvcEZOLgoIClZeXq0GDBpKknJwcNWzYUDfeeKOuu+46BQUFadeuXWrRooWkc594zM3N1Z/+9Ce3x3Ipli5dqsWLF2v58uWKjo42JAYAAACzovd0Re8JAABgvODgYHXo0EHbt2/XHXfcIUmqqqrS9u3bNXDgwFrrZ2dnKzExUU2aNPFoXJGRkQoODtaxY8d066231rnOrl271KVLFw0YMMC57PDhwx6NCwAAwChu+Y3x0aNHa8aMGQoNDVVCQoIqKiqUl5enkydP6rHHHruqbVdUVCg9PV1PPfWUvv32W7344osaOHCgAgIC1LBhQz388MOaM2eOwsLC1Lx5cy1btkzl5eV64IEHnNsoLCzU6dOnVVxcrPLycuXn50v6f82hJB04cECVlZU6ceKETp065Vzn/NsK1Sw7deqUjh8/rvz8fAUFBalNmzaSzt3CcuHChZo/f75atGih4uJiSVLDhg3VqFGjq6oDAAAAzqH3pPcEAADwNY899pgmTpyojh07qlOnTnr99ddVVlam5ORkl/UKCwu1Y8cOvfLKKx6PqXHjxnr88ceVlZWl6upq/e53v9NPP/2kXbt2qXHjxurbt69at26tNWvWaMuWLWrZsqXeffdd5ebmqmXLlh6PDwAAwNvcMhh/8MEH1aBBAy1fvlxz5sxRw4YN1bZtW7d8c6Zbt25q3bq1BgwYoIqKCt1zzz0aNWqU8/lnnnlG1dXVmjBhgk6dOqWOHTtq2bJlCgsLc64zZcoUff75587HNbcp+uijj5xN3tChQ/Xtt9/WWqegoKDWMknau3ev3n//fbVo0UKbNm2SJK1atUqVlZUaPXq0Sw6pqakuMQMAAODK0XvSewIAAPiaPn366Pjx41q4cKGKi4sVFRWlZcuW1bqVenZ2tm644QbFx8d7Ja6xY8eqSZMmWrJkiY4eParQ0FC1b99ew4cPlyQ99NBDys/P17hx41SvXj3dfffdeuSRR/TJJ594JT4AAABvqlftwz8Gk5aWppMnT+rll182OhSvcTgcysnJ0aj8fG3/97+NDgcAvKpLs2baNXiw1/dbc+6NiYmRzWbz+v7hfhzTulGXi7Na70nfCX9yJT2CFc955GyNnCVr5m3FnCX/zdtf44bn0HsCgLVc7N9w9AnUQHJvDS5nWwFXtScAAAAAAAAAAAAAAHycW26lDgAAAAAAAAC4MtOmTdPf//73Op+799579dxzz3k5IgAAAPPx6cH4rFmzjA4BAAAAFkHvCQAAAKOMGTNGQ4YMqfO5xo0bezkaAAAAc/LpwTgAAAAAAAAAmF14eLjCw8ONDgMAAMDU+I1xAAAAAAAAAAAAAICpMRgHAAAAAAAAAAAAAJgat1L3UfYmTVReVWV0GADgVVHcNg4AvI6+E/6AHgEAAHOg9wQAa+DfcPBVDMZ91LJevWSz2YwOAwC8zlFVJVsANzQBAG+h74S/oEcAAMD/0XsCgHXwbzj4Iv6P9FEOh8PoEOAmDodDX331FcfURDimnkWzBADeZbX3Myu+j5slZ3oEAAD8n7/3I1fDLD3Z1bB6Dayev0QNJGvVgH/DwRfxfyXgBWVlZUaHADfjmAIA4L+s+D5uxZwBAAB8DT0ZNbB6/hI1kKgBYCQG4wAAAAAAAAAAAAAAU2MwDgAAAAAAAAAAAAAwNQbjAAAAAAAAAAAAAABTYzAOAAAAAAAAAAAAADA1BuOAF4SEhBgdAtyMYwoAgP+y4vu4FXMGAADwNfRk1MDq+UvUAICxAo0OAHWz2WxGhwA3sdlsat++vdFhwI04pp7hqKqSLYDPawGAt1mt77Ti+7i/5UxPAACAeVmt9zyfv/VknmD1Glg9f+nSasC/BwB4EoNxH/XE+vX6sqTE6DAAwCuiwsO18u67jQ4DACyJvhO+hJ4AAABzo/cEcDH8ewCApzEY91EFx49rd1GR0WEAAADA5Og7AQAA4C30ngAAwEjcjwIAAAAAAAAAAAAAYGoMxgEAAAAAAAAAAAAApsZgHAAAAAAAAAAAAABgagzGAQAAAAAAAAAAAACmxmAcAAAAAAAAAAAAAGBqDMYBAAAAAAAAAAAAAKbGYBwAAAAAAAAAAAAAYGoMxgEAAAAfkZiYqNdee83oMAAAAAAAAADTMcVgPC0tTXa7vdafwsJC7dixQ8OHD1d8fLzsdrs2btxY6/UbNmzQ448/rri4ONntduXn59da58yZM8rMzFRcXJy6dOmiUaNGqaSkxPn822+/XWcMdrtdpaWlHs0fAAAAV2/37t2KiorS0KFDjQ4FAAAAPsYb1x8BAADgWaYYjEtSQkKCtm7d6vKnZcuWOn36tOx2u6ZPn37B154+fVqxsbF65plnLrjOzJkz9Y9//EMLFizQm2++qaKiIqWmpjqf79OnT639x8fH69Zbb1V4eLhbcwUAAID7rV69WgMHDtSOHTv0/fffe2w/DodDVVVVfrdtAAAAq/P09UcAAAB4lmkG48HBwWratKnLH5vNph49emjcuHG68847L/japKQkpaamqlu3bnU+/9NPPyk7O1tpaWnq1q2bOnbsqJkzZ2r37t3KycmRJDVo0KDWvj/77DOlpKR4Il0AAAC40alTp7R27Vo9/PDD+sMf/qB33nnH5flNmzYpJSVF0dHRiouL08iRI53P/fjjj5owYYL+4z/+Q507d9YTTzyhf/3rX87n3377bXXt2lUfffSR+vTpo+joaB07dkylpaUaPny4OnXqpMTERL333nu14lqxYoXuvfdexcTEqEePHsrIyNCpU6d+ddsAAABwP09ef/w1drtdq1at0rBhw9S5c2f17t1bu3fvVmFhoQYNGqSYmBg99NBDOnz4sMvrNm7cqL59+yo6Olq33367Fi1apLNnzzqfv9R+c8uWLerdu7e6dOmiIUOGqKio6IryAAAAMFKg0QH4g7y8PFVWVqp79+7OZZGRkWrevLlycnIUExNT6zVr1qxRgwYN9Mc//tGLkQKAf3M4HIbu16j9w/04pnWjHhf24Ycf6uabb9bNN9+s++67TzNnztSwYcNUr149bd68WampqRo+fLjmzJmjyspKffzxx87XpqWlqbCwUP/n//wfNW7cWHPnztXQoUP1wQcfKCgoSJJUXl6upUuXasaMGbr22msVHh6u0aNHq6ioSG+88YYCAwM1Y8aMWj/BU69ePaWnp6tly5Y6cuSIMjMzNXfuXGVkZDjXqWvbgL9zx/nKiu8F5GwdVszbijlL/pu3v8XrL15++WWlpaUpLS1N8+bN09NPP61WrVpp6NChat68uSZPnqznnntOy5YtkyR98cUXmjhxoqZMmaKuXbvq8OHDmjp1qiQ574R5qf3mq6++qjlz5iggIEDPPvusZs+erfnz53u9BgCswczvI/763u5O1IAaSO6tweVswzSD8c2bN6tLly7OxwkJCVq4cKFbtl1SUqKgoCBdc801LsvDw8NVXFxc52tWr16te+65Rw0aNHBLDABgBQUFBSorKzNs/7m5uYbtG57BMcWlWr16te677z5J5/rIn376SZ9//rni4uK0ePFi9enTR6NHj3au365dO0nSv/71L23atEn/+Z//qdjYWEnSvHnz9Ic//EEbN25U7969JUmVlZXKyMhwvu7QoUP65JNP9N///d/q1KmTJOn5559Xnz59XOJ69NFHnf/dsmVLjR07VtOnT3e5UPnLbQNm4M6ewIrvBeRsHVbM24o5S9bN29d48vrjpUhOTnb2i08++aT69++vESNGKCEhQZI0ePBgTZo0ybn+okWLNHToUPXt21eS1KpVK40ZM0Zz5851DsYvtd/MzMzUTTfdJEkaMGCAXn75ZU+mCsDijL5G6A28t1MDiRpI3q+BaQbjcXFxLg1bSEiIYbHs3r1b33zzjebMmWNYDADgj+x2uyH7dTgcys3NVXR0tGw2myExwL04pnWrqQtcHTx4ULm5uXrppZckSYGBgerTp49Wr16tuLg45efn68EHH6zztd98840CAwPVuXNn57LrrrtOv/3tb/XNN984lwUFBbmc42pe17FjR+eyyMjIWh/E3LZtm5YsWaKDBw/q559/lsPh0JkzZ1RWVubsd3+5bcAM3PH/tBXfC8jZGjlL1szbijlL/pu3WftOo68/nv/+WHOXoLZt27osO3PmjH7++Wc1btxY+/bt065du7R48WLnOr/sJy+l3wwJCXEOxSWpWbNmte50BADuZOZ/4/rre7s7UQNqILm3BpfTe5pmMB4SEqLWrVt7ZNsRERGqrKzUyZMnXS5WlpaWqmnTprXW/+///m9FRUW5XOgEAPw6o5sAm81meAxwL44pLsXq1at19uxZ5zdtJKm6ulrBwcGaNm2aW+4A1KBBA9WrV++yXnP06FENGzZMDz/8sMaNG6ewsDDt3LlT6enpqqysdF6ovJJtA77OneduK74XkLN1WDFvK+YsWTdvX+PJ64+XouZneiQ5+7+6llVVVUmSTp8+rVGjRumuu+6qta369etfcr8ZGOh6CblevXqqrq52b3IAcB4rvOfx3k4NJGogeb8GphmMe1LHjh0VFBSk7du3q1evXpLOfbPo2LFjtX5f/NSpU/rwww/19NNPGxApAAAALsfZs2f17rvvKi0tTf/f//f/uTw3cuRIvf/++2rbtq22b9+ulJSUWq+PjIzU2bNn9eWXXzpvpf7DDz/o0KFDatOmzQX3e/PNN+vs2bPKy8tz3kr94MGDOnnypHOdvXv3qrq6WmlpaQoICJB07rfQAQAAgEvRvn17HTp06ILDfPpNAABgNaYfjJ86dUqHDx92Pj569Kjy8/MVFham5s2bS5JOnDih7777TkVFRZLO/eajdO6b4k2bNlVoaKhSUlI0a9YshYWFqXHjxpoxY4a6dOlSazC+du1aORwO529UAgAAwHdt3rxZP/74ox544AGFhoa6PHfXXXdp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rby8PBUWFmrQoEFKT093Wee//uu/tGbNGn399deSpA4dOmj8+PHO66sAAAD+whSDcUlKSEhQVlaWy7ImTZpo7dq1ysrKUmZmpjp37qzXX39dQ4YM0bp16xQeHq4bb7xRW7dudXndW2+9peXLl+u2226TJDkcDg0bNkwRERFatWqVioqKNHHiRAUFBWn8+PGSpPT0dD399NPObTgcDt1///364x//6OHMAQAArO1CfeC//vUv2e12paSkKDU1tc7Xnj59WrGxserdu7emTJnijXABAADgQ86/Lrh27VotXLhQ69atcy5r2LChEWFdspSUFH355ZcqKCio9ZzD4VD9+vU1aNAgrV+/vs7XV1RU6LrrrtNTTz2l1157rc51PvvsM919992KjY1VcHCwli1bpscff1wffPCBrr/+enemAwAA4FGmuZV6cHCwmjZt6vLHZrNpxYoV6tevn1JSUtSmTRtlZmaqQYMGys7OliTZbLZar9u4caN69+6tRo0aSTrXIB84cEBz585VVFSUevTooTFjxmjlypWqqKiQJIWGhrpsIy8vTz/++KOSk5MNqwkAAIAVXKgP7NGjh8aNG6c777zzgq9NSkpSamqqunXrdkX7ttvtWrVqlYYNG6bOnTurd+/e2r17t/PbNjExMXrooYd0+PBhl9dt3LhRffv2VXR0tG6//XYtWrRIZ8+edT6/YsUK3XvvvYqJiVGPHj2UkZGhU6dOOZ9/++231bVrV23ZskW9e/dWly5dNGTIEBUVFV1RHgAAAFZ1fg8ZGhqqevXquSxbu3atevfurejoaP3xj3/UypUrna89evSo7Ha71q5dq0ceeUSdOnVSSkqKDh06pD179ig5OVldunTRE088oePHjztfl5aWphEjRmjRokX6/e9/r9jYWE2bNs15nVE6N7CeMWOGunXrpujoaD388MPas2ePS+xTpkzRgAED1KpVqzpza9iwoTIzM9WvXz81bdq0znVatmypKVOmKCkpSaGhoXWuM3/+fA0YMEBRUVGKjIzUjBkzVFVVpe3bt19ynQEAAHyBab4xXpeKigrt3btXw4YNcy4LCAhQ9+7dtXv37jpfk5eXp/z8fE2bNs25LCcnR23btlVERIRzWXx8vDIyMnTgwAG1b9++1nZWr16t7t27q0WLFm7MCMCFOBwOr+/Lm/uEZ3FMzYdjWjfq4Rkv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tHTp0lrbeO2119SrVy916tRJPXr00MyZM3XmzJlL2v+OHTs0fPhwxcfHy263a+PGjZf0us8++0x9+/Z1xvz2229fetIAAADwC+f3quf/KSwsvKQ+csOGDXr88ccVFxcnu92u/Pz8WuucOXNGmZmZiouLU5cuXTRq1CiVlJS4rDNjxgwlJyerY8eOuv/++z2WLwAAANzjaq95VlZWatGiRbrjjjsUHR2t++67T5988skl759rngAAwOp8cjAuSQkJCdq6davWr1+vxx57TIsWLdLy5cv1888/a8iQIWrevLnefvttTZgwQYsWLdJbb73lfO3f//53zZ8/X6mpqVq7dq2ef/55rV27Vn/5y18uad+nT5+W3W7X9OnTLzneI0eOaNiwYYqLi9O7776rP/3pT5oyZYq2bNly2bkDAADAt9X0quf/admy5SX1kadPn1ZsbKyeeeaZC64zc+ZM/eMf/9CCBQv05ptvqqioSKmpqbXWS0lJUZ8+fdySEwAAADzvaq55LliwQG+99ZamTp2qtWvX6qGHHlJqaqq++uqrS9o31zwBAIDVBRodwIUEBweradOmkqRHHnlEGzdu1KZNmxQaGqrKykrNnDlTwcHBuuWWW5Sfn68VK1aof//+kqTdu3crNjZW9957rySpZcuWuueee/Tll19e0r579OihHj16XFa8q1atUsuWLZWWliZJioyM1M6dO/Xaa68pISHhsrYFAAAA33Z+r3q+S+kjk5KSJElHjx6t8/mffvpJ2dnZmjdvnrp16ybp3KC8T58+ysnJUUxMjCRpypQpkqTjx4+roKDgCjMBAACAN13NNc93331XTz31lLPffOSRR7R9+3a9+uqrmjdv3q/um2ueAADA6nx2MP5L9evX14kTJ5STk6OuXbsqODjY+Vx8fLyWLl2qH3/8UWFhYerSpYvee+897dmzR506ddKRI0f08ccfe/QWkzk5Oc4Ll+fHNXPmTI/tE7gQh8NhdAimVlNf6mweHFPz4ZjWjXr4h7y8PFVWVqp79+7OZZGRkWrevLnLYByX5pf/31vx/GDFnCVr5k3O1mHFvK2Ys+S/eftbvEa6nGuelZWVLs/XvH7Xrl0ei49rnlfvl3+Prfz3w+o1sHr+EjWQqIFEDSRqILm3BpezDZ8fjFdXV2v79u3aunWrBg4cqIKCArVs2dJlnYiICElSSUmJ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X8/25O1j4O35S4yBxBhIjIHEGEj2HYO81J4OaYwHBASoatWqNstSU1Pl6+urlJQUm+UpKSnW4vFmX331la5du6bOnTvnef9Fi/7/aRUpUsTmduayjIwMSTc+8SnduJz6PffcY7NeZhG7Zs0aTZo0ScOHD1e9evVUokQJJSQkaOfOnTnuN3M/zjhACu/lrX9AncXX15cx9zDMqedhTuEo9qh3c1KuXDmdOXPGZtn169d1/vx5m4O9knTfffdJuvEBzfT0dI0aNUq9e/fmeX+TnMbCG/8+eGPOknfmTc7ewxvz9sacJe/NW9Idj635+fllu/zw4cNq3bq1zbK6detmaYyXKFFCK1asyPL4tm3b2mzLYrFYm+KSFB4eroyMDB09etRa69WoUcOmKS7d+KrIadOmad++fTp//rw1n99++00PPvignn32WQ0ePFh79uxRkyZN1Lp161xdPTNzO0WKFJEkHTlyRK1atbJZJzw8XPPnz1d6err1+RMaGpplWwEBAdamuHSjHq1UqZL1MvGZy26tUXFn2b1uvfn1nMnbx8Db85cYA4kxkBgDiTGQCn8MfAprR/7+/goJCdGmTZusyzIyMrRp06ZsP5W5bNkytWzZMstlJO0tODhY/v7+OnXqlKpWrWrzk3mgcdu2bapXr56ef/551apVS1WrVtXx48cdGhcAAADcS17r3ZzUq1dPFy5c0O7du63LNm/erIyMDNWuXTvHxxljdP36desHQAEAANzZ/fffryJFiujw4cPZ3n/48GGVLVtWpUuXLtB+fHx8shwTvPUDkLkVEBBgczvzEuwlSpTQlClTtHTpUk2bNk3SjatVSlLz5s313//+VzExMfrzzz8VExOjSZMm3XFfmeOS2zPMc4pRyv5kn9udaAQAAOCuHHLGeE569eql4cOHKzQ0VLVr19a8efN09epVm8v5SDculbRlyxZ9+umnDo+pZMmS6t27tyZMmCBjjOrXr6+LFy9q27ZtKlmypLp06aKqVatq5cqV2rhxoypXrqx//etf2rVrV54LTwAAAHi23NS7p0+fVnJysvWDlgcOHFCJEiV03333qUyZMgoODlZkZKTefPNNjR49WmlpaRo7dqw6dOhgvcLRqlWrVLRoUVksFvn7+2vXrl1677331L59+xzPmgIAAHAngYGBatKkiT777DPFxMTYfM/46dOntXr1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de3aVaGhoXryySezxHDkyBH17NlTjRs3VlhYmFq1aqX3339faWlpjh8AAAAAOyvq7ABuJzIyUhMmTFBqaqq+/fZbjRkzRn5+fnr++efVp08fNWrUSKNHj9aBAwf0xhtvqHTp0urRo4fNNk6cOKFJkybl62Br5v4z+fv733b9L7/8UhMmTNDo0aNVp04dzZs3T3369NFXX32loKCgPO8fAADAVf3222+Kj4/Xxo0bde7cOZUvX16tWrXSwIEDFRgYKOlGk/aFF15QTExMnra9fPlyvfPOO9q6dWuW+ywWi6ZPn67WrVvbI418s1gs1t8DAgJUoUIFhYeHKzo6WqGhoU6La+nSpQoICHDa/gEAAGBftx6flKSyZcve8Tjkfffdp++++87mcYsWLVJCQoKaNWtms7xbt27auXOn9u/fn2X/fn5+6ty5s0JCQlSqVCnt27dPb775powxGjp0qP0TBgAAcCCXboz7+/urfPnykqTnnntO69at0/r161WqVCmlpaXpnXfekb+/vx566CHt3btXc+bMsWmMp6ena9iwYRo0aJB+/vlnXbhwId/7z405c+bo6aefVrdu3SRJo0eP1oYNG7Rs2TK99NJLedo3AACAq0pKSlKPHj1UrVo1TZ06VZUrV9bBgwf17rvvauPGjVq0aJHKlCnj7DCzlZqaescPO+bWhAkTFBkZqb/++kvHjh3T4sWL9fTTT+udd95R586dnRJj2bJl871fAAAAuJ6cjk/e6Tikr69vlsetW7dO7du3V4kSJazLRo4cKUk6c+ZMto3xKlWqqEqVKtbblSpV0k8//ZTth1gBAABcnUs3xm9111136dy5c9qxY4caNGhgc8CwadOmmjlzps6fP6+7775bkjR9+nQFBQXpqaee0s8//5zn/f30009q1KiRSpcurYYNG2rIkCHWM6BulZqaql9//VUvv/yydZmPj48aN26s7du353nfQG6lp6c7OwSvkznmjL3nYE49D3OaPXuNx+jRo+Xn56fZs2erWLFikqSKFSuqVq1aatOmjd5//30dOXJEJ0+e1IQJE6xnuGQeaFu+fLni4+N19uxZNW3aVPXr1893LPv379f48eO1Y8cOBQQEqG3btoqLi7Me7IuLi9OFCxcUFhamhQsXyt/fX+vXr9fKlSs1f/58HT16VMWLF1fDhg31xhtvWK/yc/78eY0Z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wDvk9TjksmXL1LJly3xfWfNWxhhdv36dOhQAALgdl26M56RTp07y8/PTiBEjdPDgQX355ZeaP3++evXqJUm66667VKNGDZuf0qVLq0SJEtmeMXSry5cva9KkSdqxY4dOnDihTZs2acCAAapataoiIyOt67344ov6xz/+Yb3dq1cvLV68WCtWrNDhw4f19ttv6+rVqzaXyQQAAHBngYGBatKkiT777LMs37l9+vRprV69Wl26dJF046zxWw+WBQcH65dffrFZtnPnznzFEhwcrP379+vKlSvWZdu2bZOPj48eeOCBHB935MgRnTt3TsOGDVODBg0UHByc5WwbSSpbtqy6dOmiKVOm6I033tCiRYvuGNO8efNUsmRJNW7cWNKNS6tv27bNZp1t27apWrVqXv+JYAAAAORfbo9DJiYmasuWLTZfJXTr/Xv37tXp06d17do17d27V3v37lVqaqokadWqVfryyy91+PBhJSUl6csvv9R7772n9u3b53iVKAAAAFfl0pdSz0mpUqWUkJCgMWPGqGvXrgoMDNSAAQPUo0cPu2zf19dXBw4c0MqVK3Xx4kVVqFBBTZo00SuvvGLTVE9KStLZs2ett6OionTmzBnFx8fr9OnTqlmzpmbNmsWl1AEAgEd588039cwzz6hPnz4aMmSIKleurIMHD+rdd99VtWrVrN+nXalSJW3ZskUdOnSQn5+fypYtq549e+rZZ59VQkKCWrVqpe+++y7LZdRzq1OnToqPj1dcXJxiY2N15swZjR07Vk8++eRt66+KFSvKz89PCxYs0LPPPqsDBw7o448/tlnnww8/VEhIiB566CGlpqZqw4YNWb5X/cKFCzp9+rRSU1N17NgxLVq0SOvWrdOkSZOsZ8z37t1b3bt31/Tp0xUVFaUdO3Zo4cKFeuutt/KVMwAAACDl/jjksmXLdO+996pp06bZbmfkyJH66aefrLczL7f+n//8R5UrV1bRokU1a9YsHT16VNKNWjo6OloxMTEOyQsAAMCRXLYxPnHixNve//DDD+uzzz6z2/ZuVqxYMSUkJNxxvfXr12dZFh0drejo6FzvCwAAwN1Uq1bNevnxIUOGKCUlRcYYtW3bVpMnT7ZeFnzw4MEaNWqUWrdurdTUVO3fv19169bV2LFj9dFHHyk+Pl6NGjVS//79szSmcyMgIEAJCQkaP368unfvroCAALVt21ZxcXG3fVzZsmU1ceJETZ06VQsWLFBISIiGDx+u/v37W9fx8/PT1KlTdfLkSRUrVkz169fX1KlTbbbz+uuvS7pxtaJ77rlH9evX15IlSxQSEmJdJyQkRB988IHi4+P1ySefqHz58ho8eDBXFAIAAMAd3el4Zm6OQw4dOlRDhw7N8f4FCxbc9vFRUVGKioq67ToAAADuwmUb4wAAAHBdlStXtjlQFx8frzlz5lib35JUt25drVq1Kstju3fvnuVSjr1797b+3rVr1xwbx/v377e5bbFYNH/+/BzjzOlgYseOHdWxY8cctz1gwAANGDAgx+3eGsfttGvXTu3atcvx/uw+bJndGAwaNEiDBg2yWXZrftltCwAAAAAAAICXNsa3bt2qvn375nj/9u3bCzEaAAAA9zd48GBVqlRJO3bsUO3ateXj4+PskAAAAAAAAADAyisb46GhoVq5cqWzwwAAAPAo3bp1c3YIAAAAAAAAAJAtr2yMFytWTFWrVnV2GAAAAAAAAAAAAACAQsA1LgEAAAAAAAAAAAAAHo3GOAAAAAAAAAAAAADAo9EYBwAAAAAAAAAAAAB4NK/8jnF3YClbVtcyMpwdBlxYzaAgZ4cAAAA8gLvUndQ+AAAA7s9das+ConYFAMA10Rh3UbPatZOvr6+zw4CLS8/IkK8PF34AAAD55051J7UPAACAe3On2rOgqF0BAHA9vDO7qPT0dGeHADtJT0/Xnj17HDKnFNcAAKCg3KnupPYBAABwb+5UexYUtSsAAK6Hd2egEFy9etXZIQAAAAAAAAAAAABei8Y4AAAAAAAAAAAAAMCj0RgHAAAAAAAAAAAAAHg0GuMAAAAAAAAAAAAAAI9GYxwoBAEBAc4OAQAAAAAAAAAAAPBaNMZdlK+vr7NDgJ34+vqqVq1adp/T9IwMu24PAAB4J1erO6lxAAAAPJer1Z65RY0KAIBnKOrsAJC9//v6a+1MTnZ2GHBRNYOCtLBDB2eHAQAAPIAr1Z3UOAAAAJ7NlWrP3KJGBQDAc9AYd1H7z5zR9j//dHYYAAAA8HDUnQAAACgs1J4AAMCZuJQ6AAAAAAAAAAAAAMCj0RgHAAAAAAAAAAAAAHg0GuMAAAAAAAAAAAAAAI9GYxwAAAAAAAAAAAAA4NFojAMAAAAAAAAAAAAAPBqNcQAAAAAAAAAAAACAR6MxDgAAAAAAAAAAAADwaDTGAQAAAAAAAAAAAAAezSUb43FxcbJYLLJYLAoNDVWbNm00bdo0Xb9+XX/99Zfi4uLUqVMn1apVSwMGDMjy+B9//NH6+Jt/Tp8+nedYPv30U1ksFo0fP/6O665du1aPP/64wsLC1KlTJ3377bd53h8AAADcS0Fr13//+9/q1auXGjZsqPDwcPXo0UMbN2687T5zs10AAAC4loLWjVu3btUzzzyjiIgI1a5dW48//rjmzp2b6/1v2bJF/fr1U9OmTWWxWLRu3bpcPe7HH39Uly5drDEvX7481/sEAABwJUWdHUBOIiMjNWHCBKWmpurbb7/VmDFj5Ofnp549e+quu+5Sz5499fXXX992G1999ZVKlixpvR0UFJSnGH755Rd9/vnnslgsd1x327ZtevXVVzV06FC1aNFCq1ev1sCBA7V8+XLVqFEjT/sFAACAeylI7bplyxY1btxYf/vb31S6dGktX75c/fv31+LFi1WrVq1sH5Oenp7rmhgAAACuoyB1Y/HixRUdHS2LxaKAgAD9/PPPeuuttxQQEKAePXrccd9XrlyRxWJRt27dFBsbm6t4k5KS9PLLL+uZZ57RlClTtGnTJo0cOVLly5dXZGRknnIHAABwNpdtjPv7+6t8+fKSpOeee07r1q3T+vXr9fLLL2v06NGSbjSjL1y4kOM2goKCVLp06Xzt//Lly/r73/+ucePG6ZNPPrnj+vPnz1dkZKT+7//+T5I0ZMgQ/fDDD/rHP/6hMWPG5CsGAAAAuIeC1K4jRoywuT106FD95z//0fr163NsjBcvXjzXNTEAAABcR0Hqxlq1atnUh5UrV9Y333yjrVu35qox3rx5czVv3jxP8X7++eeqXLmy4uLiJEnBwcH6+eefNXfuXBrjAADA7bhsY/xWd911l86dO5enx3Tu3Fmpqal66KGHFBsbq/r16+f6sWPGjFHz5s3VuHHjXDXGd+zYoZiYGJtlTZs2zfUliYD8SE9Pd3YIXilz3Bl/z8Gceh7mNHuMR+HJT+2aKSMjQ5cvX1aZMmXsGpM7ceRz1Rv/PnhjzpJ35k3O3sMb8/bGnCX3zdvd4nWmgtSNe/bs0fbt2zVkyBC7xnSzHTt2qFGjRjbLmjZtqnfeecdh+3RVBX1eu+vr2Z68fQy8PX+JMZAYA4kxkBgDyb5jkJdtuHxj3BijTZs26bvvvlN0dHSuHlO+fHmNHj1aoaGhSk1N1ZIlS/TCCy9o8eLFCgkJuePj16xZoz179mjp0qW5jjM5OVnlypWzWRYUFKTk5ORcbwPIq/379+vq1avODsNr7dq1y9khwM6YU8/DnKKw5ad2vVVCQoKuXLmi9u3b2zk691EYNY43/n3wxpwl78ybnL2HN+btjTlL3pu3JytI3disWTOdOXNG6enpio2N1VNPPeWgKLM/5lmuXDldunRJ165dU7FixRy2b1djrxqV1zNj4O35S4yBxBhIjIHEGEiFPwYu2xjfsGGD6tWrp7S0NBlj1LFjRw0aNChXj61evbqqV69uvR0eHq6kpCTNnTtX77777m0f+9tvv2n8+PGaPXu27rrrrgLlADiaxWJxdgheKT09Xbt27VJYWJh8fX2dHQ7sgDn1PMxp9jLHBfZXkNr1ZqtXr9b06dP18ccfKygoyAGRugdH1jje+PfBG3OWvDNvcvaOnCXvzNsbc5bcN2/qzpzZo25cuHChrly5op07d+q9995T1apV1bFjRwdFjEwFrVHd9fVsT94+Bt6ev8QYSIyBxBhIjIFk3zHIS+3pso3xiIgIvf322/Lz81OFChVUtGjBQg0LC9O2bdvuuN6vv/6qlJQUde3a1bosPT1dW7Zs0cKFC7Vr165sJ6hcuXJZzg5PSUnJ8olKwJ689Q+mq/D19WUOPAxz6nmYUxQWe9Sua9as0ciRI/Xhhx+qcePGDojSfRTG69Yb/z54Y86Sd+ZNzt7DG/P2xpwl783bE9mjbqxSpYqkG43a5ORkffTRRw5rjGd3zDM5OVklS5b0qrPFJfvVqLyeGQNvz19iDCTGQGIMJMZAKvwxcNnGeEBAgKpWrWq37e3bt0/ly5e/43oNGzbU6tWrbZa9/vrrql69uvr27Zvj5NStW1ebN2+2+Z7xH374QXXr1i1I2AAAAHADBa1dv/jiC73xxhuaOnWqHnvsMfsFBgAAAJdi72OeGRkZSktLs9v2blW3bl3973//s1nGMU8AAOCuXLYxfjuHDh1SWlqazp07p8uXL2vv3r2SpJo1a0qS5s6dq8qVK+uhhx7SX3/9pSVLlmjz5s2aPXv2HbddsmRJ1ahRw2ZZ8eLFVaZMGZvlr732mu655x69+uqrkqQXXnhBPXv21OzZs9W8eXN9+eWX2r17t8aMGWOvtAEAAOCG7lS7rl69WnFxcXrjjTdUp04dnT59WpJUrFgxlSpVSpL0j3/8Q998843mzZuX6+0CAADAvdypvlu4cKHuu+8+61dIbtmyRbNnz1bPnj1ztf3Lly/r+PHj1tsnTpzQ3r17dffdd6tixYqSpPfee09//PGHJk+eLEl65plntHDhQk2ePFndunXT5s2btXbtWs2YMcNueQMAABQWt2yMv/TSSzp58qT1dufOnSVJ+/fvlySlpaVp0qRJ+uOPPxQQEKAaNWpozpw5atiwod1i+O233+Tj42O9HR4erilTpuiDDz7Q1KlTVa1aNU2fPj1Lkx0AAADe5U616+LFi3X9+nWNGTPG5kOVXbp00cSJEyVJZ8+eVVJSUp62CwAAAPdyp/ouIyNDU6dO1YkTJ+Tr66v7779fw4YN0zPPPJOr7e/evVsvvPCC9faECRMk2dadp0+f1m+//WZdp0qVKpoxY4YmTJig+fPn695779W4ceMUGRlZoFwBAACcwSUb45mFWE7Wr19/2/v79u2rvn372i2eBQsW5GpZ+/bt1b59e7vtFwAAAK6voLVrdnXlrQYNGqRBgwblabsAAABwLQWtG3v27Jnrs8OzExERcccPUWYXY0REhFauXJnv/QIAALgKnzuvAgAAAAAAAAAAAACA+3LJM8Yd6dSpU+rQoUOO969Zs8b6nToAAAAAAAAA4Oo45gkAAHBnXtcYr1Chwm0v/VOhQoXCCwYAAAAAAAAACohjngAAAHfmdY3xokWLqmrVqs4OAwAAAAAAAADsgmOeAAAAd8Z3jAMAAAAAAAAAAAAAPBqNcQAAAAAAAAAAAACAR6MxDgAAAAAAAAAAAADwaF73HePuwlK2rK5lZDg7DLiomkFBzg4BAAB4CFeqO6lxAAAAPJsr1Z65RY0KAIDnoDHuoma1aydfX19nhwEXlp6RIV8fLvoAAAAKxtXqTmocAAAAz+VqtWduUaMCAOAZeDd3Uenp6c4OAXaSnp6uPXv22H1OKcYBAIA9uFrdSY0DAADguVyt9swtalQAADwD7+hAIbh69aqzQwAAAAAAAAAAAAC8Fo1xAAAAAAAAAAAAAIBHozEOAAAAAAAAAAAAAPBoNMYBAAAAAAAAAAAAAB6NxjgAAAAAAAAAAAAAwKPRGAcAAAAAAAAAAAAAeDQa4wAAAAAAAAAAAAAAj0ZjHAAAAAAAAAAAAADg0WiMAwAAAAAAAAAAAAA8Go1xAAAAAAAAAAAAAIBHozEOAAAAAAAAAAAAAPBoNMYBAAAAAAAAAAAAAB6NxjgAAAAAAAAAAAAAwKPRGAcAAAAAAAAAAAAAeDQa4wAAAAAAAAAAAAAAj0ZjHAAAAAAAAAAAAADg0WiMAwAAAAAAAAAAAAA8Go1xAAAAAAAAAAAAAIBHozEOAAAAAAAAAAAAAPBoNMYBAAAAAAAAAAAAAB6NxjgAAAAAAAAAAAAAwKPRGAcAAAAAAAAAAAAAeDQa4wAAAAAAAAAAAAAAj0ZjHAAAAAAAAAAAAADg0Yo6OwDYMsZIktLT05Wenu7kaGAPmfPIfHoO5tTzMKeehznNXuZ4ZNYb8G7eWnd6498Hb8xZ8s68ydl7eGPe3piz5L55U3fiVt5ae97MXV/P9uTtY+Dt+UuMgcQYSIyBxBhI9h2DvNSeRQwVqktJTU3Vrl27nB0GAADwYGFhYfL393d2GHAy6k4AAOBo1J3IRO0JAAAcLTe1J41xF5ORkaHr16/Lx8dHRYoUcXY4AADAgxhjlJGRoaJFi8rHh2/U8XbUnQAAwFGoO3Erak8AAOAoeak9aYwDAAAAAAAAAAAAADwaH9kEAAAAAAAAAAAAAHg0GuMAAAAAAAAAAAAAAI9GYxwAAAAAAAAAAAAA4NFojAMAAAAAAAAAAAAAPBqNcQAAAAAAAAAAAACAR6MxDgAAAAAAAAAAAADwaDTGAQAAAAAAAAAAAAAejcY4AAAAAAAAAAAAAMCj0RgHAAAAAAAAAAAAAHg0GuMuZOHChWrZsqXCwsL01FNP6ZdffnF2SMinGTNmqFu3bqpXr54aNWqkAQMG6MiRI84OC3b06aefymKxaPz48c4OBQXwxx9/aNiwYYqIiFDt2rXVqVMn7dq1y9lhIZ/S09P1wQcfqGXLlqpdu7Zat26t6dOnyxjj7NAAh8hr7bh27Vo9/vjjCgsLU6dOnfTtt9/a3G+M0YcffqimTZuqdu3aiomJ0bFjx2zWOXfunF599VWFh4erQYMGeuONN3T58mV7p3Zb9sw7LS1N7777rjp16qS6deuqadOmeu211/THH3/YbKNly5ayWCw2P59++qlD8suOvec6Li4uSz59+vSxWcfT5lpSlpwzf2bNmmVdx53m+uDBgxo0aJA15rlz5+Zrm3/99ZdGjx6tiIgI1atXT4MGDVJycrI907ote+ecm//FevbsmWWeR40aZe/UbsveeX/00UdZcnr88cdt1vG0uc7u9WqxWDR69GjrOu4214sXL9Zzzz2nRx55RI888ohiYmKyrO8u79fwfM6oRV2NM+pSV2Pv58HNRo0addsax1U4YgwOHz6sfv36qX79+qpbt666deumU6dOOSqFArP3GFy+fFljxoxRs2bNVLt2bUVFRemf//ynI1MoMGfU8a7GGXW9K3HEcyCTu/QiHDEGDjl+b+AS1qxZY0JCQszSpUvNwYMHzciRI02DBg1McnKys0NDPvTu3dssW7bMHDhwwOzdu9f07dvXPPbYY+by5cvODg12sHPnTtOiRQvTqVMnM27cOGeHg3w6d+6cadGihYmLizM7d+40x48fNxs3bjSJiYnODg359Mknn5hHH33U/Pe//zVJSUlm7dq1pm7dumbevHnODg2wu7zWjj///LOpWbOmmTlzpjl06JB5//33TUhIiNm/f791nRkzZpj69eubb775xuzdu9f069fPtGzZ0ly7ds26Tp8+fcwTTzxhduzYYbZs2WLatGljhg4d6vB8M9k77wsXLpiYmBizZs0ac/jwYbN9+3bTvXt306VLF5vttGjRwkybNs38+eef1p/CquscMdfDhw83ffr0scnn3LlzNtvxtLk2xtjk++eff5qlS5cai8Vijh8/bl3HneZ6586dZuLEieaLL74wTZo0MXPmzMnXNkeNGmWaN29ufvjhB7Nr1y7z9NNPmx49ejgqzTzHd7Pc5Jyb/8Wio6PNyJEjbeb54sWLjkozC0fkHR8fbzp06GCTU0pKis06njbXKSkpNvl+//33pkaNGmbz5s3WddxtrocOHWr+8Y9/mD179phDhw6ZuLg4U79+ffP7779b13GH92t4PmfVoq7EWXWpK3HE8yDTv//9b/PEE0+Ypk2bZvse4CocMQaJiYnm0UcfNZMmTTK//vqrSUxMNOvWrXPZPoEjxmDkyJGmdevWZvPmzSYpKcl8/vnnpmbNmmbdunWFlVaeOKuOdyXOqutdhSPyv3ldd+hFOGIMHHX8nsa4i+jevbsZPXq09XZ6erpp2rSpmTFjhhOjgr2kpKSYGjVqmJ9++snZoaCALl26ZNq2bWu+//57Ex0d7dJvRri9d9991zz77LPODgN29NJLL5nXX3/dZlls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+KJmzJjh7NAAu8pP7ViuXLksZ6PcvH758uWty3Jap1y5cjpz5ozN/devX9f58+etj3ckR+SdKS0tTUOGDNGpU6c0e/bsO56VU6dOHV2/fl0nTpzIRya558icb1alShUFBgYqMTHRug1PnWtJ2rp1q44ePZqrZqErz7U9tlmuXDmlpaXpwoULWdZx9Fw7+v/gvPwvVqdOHUmyvgYcqbD+/y9durSqVaum48ePS/LsuT558qR++OGHbL8a4VbuMtcJCQn69NNPlZCQoIcffti63B3er+H5nFWLuhJXqkudxRFjsHXrVqWkpKhFixbWY28nT57UpEmT1LJlS8ckUgCOGIPAwEAVLVo0y/Gq4OBglzxe5YgxuHbtmt5//329/vrratmypR5++GFFR0crKipKCQkJjkmkAJxVx7sSV6rrncER+btbL8JRzwFHHb+nMe4C/P39FRISok2bNlmXZWRkaNOmTapXr54TI0N+GWM0ZswYffPNN5o3b56qVKni7JBQQA0bNtTq1au1cuVK609oaKg6deqklStXytfX19khIo/Cw8Ot30Wd6dixY6pUqZKTIkJBXbt2Lcunyn19fWWMcVJEgGPkp3asW7euNm/ebLPshx9+UN26dSVJlStXVvny5W22eenSJe3cudO6zXr16unChQvavXu3dZ3NmzcrIyNDtWvXtld6OXJE3tL/f/AxMTFRc+fOVWBg4B1j2bt3r3x8fLJcJszeHJXzrX7//XedO3fOelDaU+c609KlSxUSEmLTbMqJK8+1PbYZGhoqPz8/m3WOHDmiU6dO3fY5Yw+O+j84P/+L7d27V5IKpWlYWP//X758WUlJSdacPHGuMy1fvlxBQUF67LHH7riuO8z1zJkz9fHHH2vWrFk23xMuucf7NTyfs2pRV+JKdamzOGIMnnzySa1atcrm2FuFChXUp08fzZo1y2G55JcjxsDf319hYWFuc7zKEWNw/fp1paWluc3xHWfV8a7Elep6Z3BE/u7Wi3DUc8Bhx+8NXMKaNWtMaGioWb58uTl06JB58803TYMGDczp06edHRry4a233jL169c3P/74o/nzzz+tP1evXnV2aLCj6OhoM27cOGeHgXzauXOnqVWrlvnkk0/MsWPHzKpVq0ydOnXMv/71L2eHhnwaPny4iYyMNP/9739NUlKS+fe//20iIiLM5MmTnR0a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\n"
          },
          "metadata": {}
        }
      ]
    }
  ]
}
</file>

<file path="README.md">
# üìä Documenta√ß√£o do projeto

**Prop√≥sito do Projeto**

<small>

Este projeto foi desenvolvido para realizar um ciclo completo de an√°lise de dados, desde a limpeza e prepara√ß√£o at√© a modelagem preditiva e avalia√ß√£o de performance. O objetivo principal √© transformar um conjunto de dados brutos de jogadores em insights acion√°veis e modelos de _machine learning_ robustos, capazes de prever tr√™s m√©tricas-alvo distintas (`Target1`, `Target2` e `Target3`).

O processo √© dividido em duas fases principais:

1.  **Fase de Limpeza e Prepara√ß√£o (V1)**: Focada em garantir a qualidade e a consist√™ncia dos dados. Nesta etapa, s√£o aplicadas t√©cnicas como tratamento de valores ausentes, remo√ß√£o de _outliers_, _feature engineering_ e sele√ß√£o de vari√°veis para criar um _dataset_ otimizado e confi√°vel.

2.  **Fase de Modelagem (V2)**: Utiliza o _dataset_ limpo para treinar, avaliar e comparar diversos algoritmos de regress√£o, como _Random Forest_, _XGBoost_ e _LightGBM_. O objetivo √© identificar os modelos com melhor desempenho para cada uma das vari√°veis-alvo, salvando-os para futura implementa√ß√£o em produ√ß√£o.

Ao final, o projeto entrega n√£o apenas os modelos treinados, mas tamb√©m an√°lises visuais e relat√≥rios que facilitam a interpreta√ß√£o dos resultados e a identifica√ß√£o das vari√°veis mais influentes.

</small>

<details>

<summary> üìä Fase V1 - Limpeza</summary>

### üß© **C√©lula 1/2 - Configura√ß√£o do Ambiente e Importa√ß√µes**

<small>
üìñ Explica√ß√£o:

Esta c√©lula inicializa o ambiente de trabalho. Primeiro, realiza a instala√ß√£o silenciosa das depend√™ncias externas necess√°rias para a manipula√ß√£o de planilhas e para a aplica√ß√£o de t√©cnicas de aprendizado de m√°quina. Em seguida, importa as bibliotecas e m√≥dulos que ser√£o utilizados ao longo das etapas de limpeza, transforma√ß√£o e an√°lise de dados.

<details>

<summary> Bibliotecas utilizadas: </summary>

<small>

- **xlsxwriter e openpyxl**:

Depend√™ncias utilizadas pelo Pandas para ler e escrever arquivos no formato Excel (.xlsx). A instala√ß√£o garante a compatibilidade com essas opera√ß√µes.

- **scikit-learn**:

Uma das principais bibliotecas de aprendizado de m√°quina em Python, que fornece ferramentas eficientes para pr√©-processamento, modelagem e avalia√ß√£o de dados.

- **pandas**:

Fundamental para a manipula√ß√£o e an√°lise de dados. √â utilizada para carregar os dados em estruturas conhecidas como DataFrames, que facilitam a limpeza e a transforma√ß√£o.

- **numpy**:

Essencial para computa√ß√£o num√©rica, oferece suporte a arrays e matrizes multidimensionais, al√©m de uma vasta cole√ß√£o de fun√ß√µes matem√°ticas de alto desempenho.

- **SimpleImputer**:

Uma classe do Scikit-learn usada para tratar dados ausentes (NaN), permitindo preench√™-los com uma estrat√©gia definida (como a m√©dia, mediana ou a moda da coluna).

- **StandardScaler**:

Uma classe do Scikit-learn utilizada para padronizar as features num√©ricas, redimensionando-as para que tenham m√©dia zero e desvio padr√£o igual a um, o que √© crucial para muitos algoritmos de machine learning.

- **datetime**:

M√≥dulo padr√£o do Python para manipula√ß√£o de datas e horas.

- **warnings**:

M√≥dulo para controlar a exibi√ß√£o de mensagens de aviso. A linha warnings.filterwarnings('ignore') √© usada para suprimir esses avisos e manter a sa√≠da do c√≥digo mais limpa e focada nos resultados.
</small>

</details>

---

### üß© **C√©lula 3 - DEFINI√á√ïES**

<details>

<summary> Trecho do codigo em Python </summary>

```python
COLUNAS_CATEGORICAS = [
    'Cor0202', 'Cor0204', 'Cor0206', 'Cor0208', 'Cor0209Outro',
    'P01', 'P02', 'P03', 'P04', 'P05', 'P07', 'P08', 'P09', 'P10',
    'P12', 'P13', 'P15', 'P12_1', 'P02_1', 'P03_1', 'P09_1'
]

COLUNAS_TARGETS = ['Target1', 'Target2', 'Target3']

COLUNAS_IGNORAR = [
    'C√≥digo de Acesso', 'Data/Hora √öltimo',
    'L0210 (n√£o likert)',
    'F0299 - Explica√ß√£o Tempo', 'T0499 - Explica√ß√£o Tempo',
    'PTempoTotalExpl', 'T1199Expl', 'T1205Expl', 'T1210Expl',
    'TempoTotalExpl'
]

print(f"üìã Categ√≥ricas: {len(COLUNAS_CATEGORICAS)} | Targets: {len(COLUNAS_TARGETS)}")
```

</details>
<small> üìñ Explica√ß√£o:

Esta c√©lula centraliza as **defini√ß√µes estruturais** do dataset, classificando as colunas em grupos conforme seu papel no processamento:

- **`COLUNAS_CATEGORICAS`**: lista de vari√°veis qualitativas ou de m√∫ltipla escolha, normalmente representadas por c√≥digos (`P01`, `P02`, etc.).
- **`COLUNAS_TARGETS`**: define as vari√°veis-alvo (targets) utilizadas em an√°lises ou modelagem.
- **`COLUNAS_IGNORAR`**: cont√©m vari√°veis irrelevantes ou auxiliares, como identificadores, timestamps e campos descritivos.
  </small>

---

### üß© **C√©lula 4 - Carregando Dataset Recebido**

<details>

<summary> Trecho do codigo em Python </summary>

```python
import pandas as pd

df_original = pd.read_excel('JogadoresV1.xlsx')
df = df_original.copy()
print(f"Dados carregados: {df.shape[0]} linhas, {df.shape[1]} colunas")
```

</details>
<small>
üìñ Explica√ß√£o:

Nesta c√©lula, realizamos a leitura do arquivo Excel contendo o dataset bruto e criamos uma c√≥pia para preservar o original.

- `pd.read_excel()` carrega o arquivo no formato Excel.
- `.copy()` evita modifica√ß√µes acidentais no dataset original.  
  </small>

---

### üß© **C√©lula 5 - TRATAMENTO F0103**

<details>

<summary> Trecho do codigo em Python </summary>

```python
if 'F0103' in df.columns and df['F0103'].dtype == 'object':
    print("\nüîß Convertendo F0103 (v√≠rgula ‚Üí ponto)")
    df['F0103'] = df['F0103'].str.replace(',', '.').astype(float)
    print("   ‚úÖ Convertido!")
```

</details>

<small> üìñ Explica√ß√£o:

Nesta c√©lula, corrigimos a coluna chamada `F0103` para garantir que os n√∫meros estejam em um formato que o Python consegue entender corretamente.

- Primeiro verificamos se a coluna `F0103` existe na tabela e se ela est√° como texto.

- Em seguida, substitu√≠mos todas as v√≠rgulas `,` por pontos `.` ‚Äî isso √© importante porque em alguns arquivos, n√∫meros decimais v√™m escritos como `3,14` em vez de `3.14`.
- Por fim, transformamos essa coluna em n√∫meros de ponto flutuante (`float`), para que possa ser usada em c√°lculos, an√°lises e modelos sem causar erros.

Esse passo garante que a informa√ß√£o da coluna `F0103` seja precisa e utiliz√°vel em todas as etapas seguintes do processamento de dados.
</small>

---

### üß© **C√©lula 6 ‚Äî REMO√á√ÉO DE NEGATIVOS**

<details>

<summary> Trecho do codigo em Python </summary>

```python
print("\n" + "=" * 80)
print("ETAPA 1: REMO√á√ÉO DE NEGATIVOS ‚Üí NaN")
print("=" * 80)

colunas_numericas = df.select_dtypes(include=[np.number]).columns.tolist()
colunas_numericas = [col for col in colunas_numericas if col not in COLUNAS_TARGETS]

contador = 0
for col in colunas_numericas:
    negativos = (df[col] < 0).sum()
    if negativos > 0:
        df.loc[df[col] < 0, col] = np.nan
        contador += negativos

print(f"‚úÖ {contador} negativos convertidos ‚Üí NaN")

```

</details>

<small> üìñ Explica√ß√£o:

Nesta c√©lula, identificamos todas as colunas num√©ricas e substitu√≠mos valores negativos por valores vazios (NaN).

- Primeiro, usamos `df.select_dtypes(include=[np.number])` para selecionar todas as colunas que cont√™m n√∫meros.

- Em seguida, removemos da lista as colunas-alvo definidas em `COLUNAS_TARGETS`, pois essas n√£o devem ser modificadas nesse passo.

- Para cada coluna num√©rica restante, verificamos quantos valores s√£o negativos usando `(df[col] < 0).sum()`.

- Quando valores negativos s√£o encontrados, usamos `df.loc[df[col] < 0, col] = np.nan` para substitu√≠-los.

- Ao final, imprimimos a quantidade total de valores negativos convertidos.

</small>

---

### üß© **C√©lula 7 - Remo√ß√£o de Colunas com Muito Missing**

<details>

<summary> Trecho do codigo em Python </summary>

```python
print("\n" + "=" * 80)
print("ETAPA 2: AN√ÅLISE DE MISSING")
print("=" * 80)

missing_info = pd.DataFrame({
    'Coluna': df.columns,
    'Missing': df.isna().sum(),
    'Percentual': (df.isna().sum() / len(df) * 100).round(2)
})
missing_info = missing_info[missing_info['Missing'] > 0].sort_values('Percentual', ascending=False)

threshold = 70
colunas_remover = missing_info[missing_info['Percentual'] > threshold]['Coluna'].tolist()

if colunas_remover:
    print(f"üóëÔ∏è  Removendo {len(colunas_remover)} colunas (>{threshold}% missing)")
    df = df.drop(columns=colunas_remover)

print(f"‚úÖ Shape: {df.shape}")

```

</details>

<small> üìñ Explica√ß√£o:

Nesta c√©lula, realizamos uma an√°lise de dados faltantes (`missing values`) em cada coluna e removemos aquelas que possuem um percentual alto de aus√™ncia de dados.

- Usamos `df.isna().sum()` para contar quantos valores est√£o faltando em cada coluna.

- Calculamos o percentual de valores faltantes dividindo pela quantidade total de linhas (`len(df)`).

- Criamos o DataFrame `missing_info`, que cont√©m o nome da coluna, quantidade de valores ausentes e percentual de aus√™ncia.

- Ordenamos `missing_info` pelo percentual de aus√™ncia em ordem decrescente para focar nas colunas com mais dados faltantes.

- Definimos um limite (`threshold`) de 70%. Isso significa que qualquer coluna com mais de 70% de valores faltantes ser√° removida.

- Usamos `df.drop(columns=colunas_remover)` para eliminar essas colunas do dataset.

- Por fim, imprimimos quantas colunas foram removidas e o novo formato da tabela (`df.shape`).

</small>

---

### üß© **C√©lula 8 - Remo√ß√£o de Jogadores sem Targets**

<details>

<summary> Trecho do codigo em Python </summary>

```python
print("\n" + "=" * 80)
print("ETAPA 3: REMO√á√ÉO DE JOGADORES SEM TARGETS")
print("=" * 80)

antes = len(df)
df = df.dropna(subset=COLUNAS_TARGETS, how='all')
depois = len(df)

print(f"‚úÖ Jogadores mantidos: {depois} (removidos: {antes-depois})")

```

</details>

<small> üìñ Explica√ß√£o:

Nesta c√©lula, garantimos que todos os registros (linhas) do dataset contenham pelo menos uma informa√ß√£o nos campos-alvo definidos em `COLUNAS_TARGETS`.

- Usamos `len(df)` para contar quantas linhas existem antes da limpeza (antes).

- O comando `df.dropna(subset=COLUNAS_TARGETS, how='all')` remove todas as linhas em que todos os campos de target estejam vazios (`NaN`).

- Calculamos novamente o tamanho do dataset (`depois`) para saber quantos registros restaram.

- Imprimimos a quantidade de jogadores mantidos e removidos ap√≥s o filtro.

</small>

---

### **üß© C√©lula 9 - Imputa√ß√£o de Valores Faltantes**

<details>

<summary> Trecho do codigo em Python </summary>

```python
# Num√©ricas: MEDIANA
colunas_num_imputar = [
    col for col in df.select_dtypes(include=[np.number]).columns
    if col not in COLUNAS_TARGETS and col not in COLUNAS_IGNORAR
]

if colunas_num_imputar:
    imputer_num = SimpleImputer(strategy='median')
    df[colunas_num_imputar] = imputer_num.fit_transform(df[colunas_num_imputar])
    print(f"‚úÖ {len(colunas_num_imputar)} num√©ricas imputadas (mediana)")

# Categ√≥ricas: MODA
colunas_cat_imputar = [col for col in COLUNAS_CATEGORICAS if col in df.columns]

if colunas_cat_imputar:
    imputer_cat = SimpleImputer(strategy='most_frequent')
    df[colunas_cat_imputar] = imputer_cat.fit_transform(df[colunas_cat_imputar])
    print(f"‚úÖ {len(colunas_cat_imputar)} categ√≥ricas imputadas (moda)")


```

</details>

<small> üìñ Explica√ß√£o:

Nesta c√©lula, tratamos os valores faltantes no dataset usando imputa√ß√£o ‚Äî ou seja, substitu√≠mos valores ausentes (`NaN`) por valores calculados com base nos dados dispon√≠veis.

- Colunas num√©ricas:

  - Identificamos todas as colunas num√©ricas usando `df.select_dtypes(include=[np.number])`.

  - Removemos as colunas-alvo (`COLUNAS_TARGETS`) e as colunas marcadas para ignorar (`COLUNAS_IGNORAR`).

  - Criamos um imputador (`SimpleImputer`) usando a estrat√©gia `median` para substituir valores ausentes pela mediana daquela coluna.

  - Aplicamos a imputa√ß√£o usando `fit_transform`.

- Colunas categ√≥ricas:

  - Identificamos as colunas categ√≥ricas presentes (`COLUNAS_CATEGORICAS`).

  - Criamos um imputador usando a estrat√©gia `most_frequent` para substituir valores ausentes pelo valor mais frequente da coluna (moda).

  - Aplicamos a imputa√ß√£o usando fit_transform.

</small>

---

### **üß© C√©lula 10 - Tratamento de Outliers (IQR + Mediana)**

<details>

<summary> Trecho do codigo em Python </summary>

```python
colunas_outliers = [
    col for col in colunas_num_imputar
    if col not in ['QtdHorasSono', 'QtdHorasDormi', 'Acordar']
]

outliers_tratados = 0
for col in colunas_outliers:
    Q1 = df[col].quantile(0.25)
    Q3 = df[col].quantile(0.75)
    IQR = Q3 - Q1

    limite_inf = Q1 - 1.5 * IQR
    limite_sup = Q3 + 1.5 * IQR

    outliers_mask = (df[col] < limite_inf) | (df[col] > limite_sup)
    n_outliers = outliers_mask.sum()

    if n_outliers > 0:
        mediana = df[col].median()
        df.loc[outliers_mask, col] = mediana
        outliers_tratados += n_outliers

print(f"‚úÖ {outliers_tratados} outliers tratados (substitu√≠dos por mediana)")

```

</details>

<small> üìñ Explica√ß√£o:

Nesta c√©lula, detectamos e tratamos outliers ‚Äî valores extremos que podem distorcer an√°lises e modelos ‚Äî utilizando o m√©todo do Intervalo Interquart√≠lico (IQR) e substituindo-os pela mediana da coluna.

- Primeiro identificamos as colunas num√©ricas a serem tratadas (`colunas_outliers`), excluindo colunas espec√≠ficas como `QtdHorasSono`, `QtdHorasDormi` e `Acordar`.

- Para cada coluna:

  - Calculamos o **primeiro quartil** (`Q1`) e o **terceiro quartil** (`Q3`).

  - Determinamos o **Intervalo Interquart√≠lico (IQR)** como `Q3 - Q1`.

  - Definimos limites inferior (`limite_inf`) e superior (`limite_sup`) como `Q1 - 1.5*IQR` e `Q3 + 1.5*IQR`, respectivamente.

  - Criamos uma m√°scara (`outliers_mask`) identificando valores fora desses limites.

  - Quando outliers s√£o encontrados, substitu√≠mos esses valores pela mediana da coluna.

  - Contabilizamos quantos outliers foram tratados.

</small>

---

### **üß© C√©lula 11 - One-Hot Encoding**

<details>

<summary> Trecho do codigo em Python </summary>

```python
colunas_cat_presentes = [col for col in COLUNAS_CATEGORICAS if col in df.columns]

if colunas_cat_presentes:
    colunas_antes = df.shape[1]
    df = pd.get_dummies(df, columns=colunas_cat_presentes, prefix=colunas_cat_presentes, drop_first=False)
    colunas_depois = df.shape[1]

    print(f"‚úÖ One-Hot conclu√≠do: {colunas_antes} ‚Üí {colunas_depois} colunas")

```

</details>

<small> üìñ Explica√ß√£o:

Nesta c√©lula, aplicamos a t√©cnica de One-Hot Encoding, que transforma colunas categ√≥ricas em vari√°veis num√©ricas bin√°rias, permitindo que algoritmos de machine learning trabalhem com esses dados.

- Identificamos as colunas categ√≥ricas presentes no dataset (`colunas_cat_presentes`) comparando `COLUNAS_CATEGORICAS` com as colunas reais do `df`.

- Guardamos o n√∫mero inicial de colunas (`colunas_antes`).

- Usamos `pd.get_dummies()` para criar colunas bin√°rias para cada categoria, mantendo o prefixo original para identifica√ß√£o.

- N√£o usamos `drop_first=True` para preservar todas as categorias.

- Calculamos o n√∫mero final de colunas (`colunas_depois`) ap√≥s a transforma√ß√£o.

- Imprimimos quantas colunas foram adicionadas no processo.

</small>

---

### **üß© C√©lula 12 - Feature Engineering (Agrega√ß√µes)**

<details>

<summary> Trecho do codigo em Python </summary>

```python
# Agrega√ß√£o F11*
f11_cols = [c for c in df.columns if c.startswith('F11') and pd.api.types.is_numeric_dtype(df[c])]
if len(f11_cols) > 2:
    df['F11_mean'] = df[f11_cols].mean(axis=1)
    print(f"‚úÖ F11_mean criada ({len(f11_cols)} colunas)")

# Agrega√ß√£o F07*
f07_cols = [c for c in df.columns if c.startswith('F07') and pd.api.types.is_numeric_dtype(df[c])]
if len(f07_cols) > 2:
    df['F07_mean'] = df[f07_cols].mean(axis=1)
    print(f"‚úÖ F07_mean criada ({len(f07_cols)} colunas)")
```

</details>

<small> üìñ Explica√ß√£o:

Nesta c√©lula, realizamos Feature Engineering, criando novas colunas que representam agrega√ß√µes de vari√°veis relacionadas, para facilitar a an√°lise e potencialmente melhorar a performance de modelos.

- **Agrega√ß√£o F11**:

  - Identificamos colunas cujo nome come√ßa com "`F11`" e que s√£o num√©ricas.

  - Se existirem mais de duas colunas nesse grupo, calculamos a m√©dia delas linha a linha (`mean(axis=1)`), criando a nova coluna `F11_mean`.

  - Exibimos quantas colunas foram utilizadas para essa agrega√ß√£o.

- **Agrega√ß√£o F07**:

  - De forma semelhante, identificamos colunas que come√ßam com "`F07`" e que s√£o num√©ricas.

  - Se houver mais de duas, calculamos a m√©dia e criamos `F07_mean`.

  - Exibimos quantas colunas contribu√≠ram para essa agrega√ß√£o.

</small>

---

### **üß© C√©lula 13 - üîß Corre√ß√£o 1 - Converter BOOL ‚Üí INT**

<details>

<summary> Trecho do codigo em Python </summary>

```python
bool_cols = df.select_dtypes(include=['bool']).columns.tolist()

if bool_cols:
    print(f"üìã Convertendo {len(bool_cols)} colunas booleanas...")
    df[bool_cols] = df[bool_cols].astype(int)
    print(f"‚úÖ VERDADEIRO/FALSO ‚Üí 1/0")
    print(f"   Exemplo: {bool_cols[:3]}")
else:
    print("‚ÑπÔ∏è  Nenhuma coluna booleana encontrada")
```

</details>

<small> üìñ Explica√ß√£o:

Nesta c√©lula, corrigimos o formato das colunas booleanas do dataset, transformando valores `True`/`False` em `1/0`. Isso √© necess√°rio porque muitos algoritmos de machine learning requerem que todos os dados sejam num√©ricos.

- Usamos `df.select_dtypes(include=['bool'])` para identificar todas as colunas que cont√™m valores booleanos (`True` ou `False`).

- Se houver colunas booleanas (`bool_cols`), exibimos quantas ser√£o convertidas.

- Aplicamos `.astype(int)` para transformar os valores em n√∫meros inteiros (`1` para `True`, `0` para `False`).

- Exibimos alguns exemplos de colunas convertidas para confirmar a a√ß√£o.

- Caso n√£o existam colunas booleanas, uma mensagem informativa √© exibida.

</small>

---

### **üß© C√©lula 14 - Feature Selection por Correla√ß√£o**

<details>

<summary> Trecho do codigo em Python </summary>

```python
print("\n" + "=" * 80)
print("ETAPA 8: FEATURE SELECTION")
print("=" * 80)

features_numericas_finais = [
    col for col in df.columns
    if col not in COLUNAS_TARGETS
    and col not in COLUNAS_IGNORAR
    and pd.api.types.is_numeric_dtype(df[col])
]

print(f"üìä Features dispon√≠veis: {len(features_numericas_finais)}")

corr_t1 = df[features_numericas_finais].corrwith(df['Target1']).abs()
corr_t2 = df[features_numericas_finais].corrwith(df['Target2']).abs()
corr_t3 = df[features_numericas_finais].corrwith(df['Target3']).abs()

corr_mean = (corr_t1 + corr_t2 + corr_t3) / 3

threshold = 0.20
features_selecionadas = corr_mean[corr_mean > threshold].index.tolist()

print(f"‚úÖ Features mantidas: {len(features_selecionadas)} (threshold={threshold})")
print(f"‚úÖ Features removidas: {len(features_numericas_finais) - len(features_selecionadas)}")

# Top 10
print(f"\nüèÜ TOP 10 FEATURES:")
top10 = corr_mean.sort_values(ascending=False).head(10)
for idx, (feat, corr) in enumerate(top10.items(), 1):
    print(f"   {idx:2d}. {feat:30s} | Corr: {corr:.4f}")
```

</details>

<small> üìñ Explica√ß√£o:

Nesta c√©lula, realizamos a **sele√ß√£o de features** com base na correla√ß√£o entre vari√°veis num√©ricas e os targets (`Target1`, `Target2`, `Target3`). O objetivo √© manter apenas as colunas que t√™m relev√¢ncia estat√≠stica para o modelo.

- Definimos `features_numericas_finais` como todas as colunas num√©ricas que n√£o s√£o targets nem est√£o na lista `COLUNAS_IGNORAR`.

- Calculamos a correla√ß√£o absoluta (`.abs()`) entre cada feature e cada target (`corr_t1`, `corr_t2`, `corr_t3`).

- Obtemos a m√©dia das correla√ß√µes (`corr_mean`) para avaliar a import√¢ncia geral da feature em rela√ß√£o a todos os targets.

- Definimos um **threshold** (limite) de 0.20; apenas features com correla√ß√£o m√©dia acima desse valor s√£o mantidas (`features_selecionadas`).

- Informamos quantas features foram mantidas e quantas removidas.

- Exibimos as **Top 10 features** com maior correla√ß√£o m√©dia, ordenadas do maior para o menor valor, para refer√™ncia.

</small>

---

### **üß© C√©lula 15 - Criar DataFrames Finais**

<details>

<summary> Trecho do codigo em Python </summary>

```python
df_final_nao_normalizado = df[features_selecionadas + COLUNAS_TARGETS].copy()
print(f"‚úÖ DataFrame N√ÉO-NORMALIZADO: {df_final_nao_normalizado.shape}")

df_final_normalizado = df_final_nao_normalizado.copy()

# Identificar categ√≥ricas (One-Hot) para N√ÉO normalizar
features_cat_onehot = [
    col for col in features_selecionadas
    if any(cat in col for cat in COLUNAS_CATEGORICAS)
]

features_numericas_normalizar = [
    col for col in features_selecionadas
    if col not in features_cat_onehot
]

print(f"üî¢ Num√©ricas a normalizar: {len(features_numericas_normalizar)}")
print(f"üìù Categ√≥ricas (preservadas): {len(features_cat_onehot)}")

if features_numericas_normalizar:
    scaler = StandardScaler()
    df_final_normalizado[features_numericas_normalizar] = scaler.fit_transform(
        df_final_normalizado[features_numericas_normalizar]
    )
    print(f"‚úÖ Normaliza√ß√£o conclu√≠da!")

print(f"‚úÖ DataFrame NORMALIZADO: {df_final_normalizado.shape}")
```

</details>

<small> üìñ Explica√ß√£o:

Nesta c√©lula, preparamos os **DataFrames finais** para an√°lise e modelagem, criando vers√µes normalizadas e n√£o-normalizadas.

- Criamos `df_final_nao_normalizado` contendo apenas as **features selecionadas** e os **targets**, preservando o formato original.

- Criamos uma c√≥pia chamada `df_final_normalizado` para aplicar normaliza√ß√£o sem alterar o original.

- Identificamos colunas categ√≥ricas geradas pelo **One-Hot Encoding** (`features_cat_onehot`) para garantir que elas n√£o sejam normalizadas.

- Definimos `features_numericas_normalizar` como todas as features num√©ricas restantes.

- Informamos quantas features num√©ricas ser√£o normalizadas e quantas categ√≥ricas ser√£o preservadas.

- Aplicamos o `StandardScaler` √†s features num√©ricas, padronizando-as para m√©dia zero e desvio padr√£o igual a um.

- Exibimos o tamanho final de cada DataFrame, garantindo que ambos estejam prontos para uso posterior.

</small>

---

### **üß© C√©lula 16 - Exportar para Excel**

<details>

<summary> Trecho do codigo em Python </summary>

```python
output_file = 'Dados_Otimizados_V4.xlsx'

writer = pd.ExcelWriter(output_file, engine='xlsxwriter')
workbook = writer.book

header_format = workbook.add_format({
    'bold': True, 'text_wrap': True, 'valign': 'vcenter',
    'align': 'center', 'fg_color': '#1F4E78',
    'font_color': 'white', 'border': 1
})

title_format = workbook.add_format({
    'bold': True, 'font_size': 16,
    'fg_color': '#4472C4', 'font_color': 'white',
    'align': 'center', 'valign': 'vcenter', 'border': 2
})

# Aba 1: Dados n√£o-normalizados
df_final_nao_normalizado.to_excel(writer, sheet_name='Dados_Para_Analise', index=False, startrow=2)
worksheet1 = writer.sheets['Dados_Para_Analise']
worksheet1.merge_range('A1:Z1', 'üìã DADOS LIMPOS - Vers√£o Otimizada', title_format)
worksheet1.freeze_panes(3, 0)

# Aba 2: Dados normalizados
df_final_normalizado.to_excel(writer, sheet_name='Dados_Para_Modelo', index=False, startrow=2)
worksheet2 = writer.sheets['Dados_Para_Modelo']
worksheet2.merge_range('A1:Z1', 'üìä DADOS NORMALIZADOS - Para ML', title_format)
worksheet2.freeze_panes(3, 0)

# Aba 3: Resumo estat√≠stico
summary = df_final_nao_normalizado[COLUNAS_TARGETS].describe().T
summary.to_excel(writer, sheet_name='Resumo_Estatistico', startrow=2)
worksheet3 = writer.sheets['Resumo_Estatistico']
worksheet3.merge_range('A1:I1', 'üìä RESUMO ESTAT√çSTICO', title_format)

# Aba 4: Correla√ß√µes
correlations_df = pd.DataFrame({
    'Feature': corr_mean.index,
    'Corr_Target1': corr_t1.values,
    'Corr_Target2': corr_t2.values,
    'Corr_Target3': corr_t3.values,
    'Corr_Media': corr_mean.values,
    'Mantida': ['‚úÖ' if f in features_selecionadas else '‚ùå' for f in corr_mean.index]
}).sort_values('Corr_Media', ascending=False)

correlations_df.to_excel(writer, sheet_name='Correlacoes', index=False, startrow=2)
worksheet4 = writer.sheets['Correlacoes']
worksheet4.merge_range('A1:F1', 'üîç AN√ÅLISE DE CORRELA√á√ïES', title_format)

writer.close()

print(f"‚úÖ Arquivo '{output_file}' criado!")
```

</details>

<small> üìñ Explica√ß√£o:

Nesta c√©lula, exportamos os resultados finais para um arquivo Excel estruturado, criando m√∫ltiplas abas para facilitar a an√°lise e utiliza√ß√£o dos dados.

- Definimos o nome do arquivo de sa√≠da como `Dados_Otimizados_V4.xlsx`.

- Criamos um escritor Excel (`pd.ExcelWriter`) usando o engine `xlsxwriter`.

- Definimos formata√ß√µes personalizadas para cabe√ßalhos (`header_format`) e t√≠tulos (`title_format`) para melhor visualiza√ß√£o.

**Aba 1 ‚Äì Dados n√£o-normalizados:**

- Exporta `df_final_nao_normalizado`.

- Inclui um t√≠tulo e congela a visualiza√ß√£o para facilitar navega√ß√£o.

**Aba 2 ‚Äì Dados normalizados:**

- Exporta `df_final_normalizado`.

- Inclui t√≠tulo e congelamento de linhas.

**Aba 3 ‚Äì Resumo estat√≠stico:**

- Cria resumo com estat√≠sticas descritivas dos targets (`describe().T`).

**Aba 4 ‚Äì Correla√ß√µes:**

- Exporta tabela contendo correla√ß√µes m√©dias entre features e targets.

- Indica quais features foram mantidas na sele√ß√£o.

- Fecha o arquivo Excel (`writer.close()`) e confirma a cria√ß√£o.

Essa celula entrega um arquivo organizado e documentado, pronto para an√°lise e uso em modelos de machine learning.

</small>

---

### ‚úÖ **Resumo Geral da Etapa de Limpeza**

Ap√≥s a execu√ß√£o de todas as c√©lulas, o dataset estar√° pronto para ser utilizado nas pr√≥ximas fases do projeto, com:

- C√≥digos inv√°lidos convertidos em `NaN`.
- Colunas pouco informativas removidas.
- Targets completos e consistentes.
- Estrutura final reduzida, por√©m mais confi√°vel e analis√°vel.

---

</details>

<details>

<summary> üìä Fase V2 - Modelagem </summary>

### **üß© C√©lula 1 - Instala√ß√£o de Bibliotecas**

<details>

<summary> Trecho do codigo em Python </summary>

```python
!pip install xgboost lightgbm catboost scikit-learn pandas matplotlib seaborn plotly -q
print("‚úÖ Bibliotecas instaladas com sucesso!")
```

</details>

<small> üìñ Explica√ß√£o:

Esta c√©lula instala todas as bibliotecas necess√°rias para rodar o projeto de modelagem avan√ßada e visualiza√ß√µes.

O comando `!pip install` funciona dentro de notebooks Jupyter ou Google Colab e serve para instalar pacotes Python diretamente no ambiente.  
Aqui, estamos instalando:

- **xgboost, lightgbm, catboost** ‚Üí algoritmos de aprendizado de m√°quina muito eficientes para regress√£o e classifica√ß√£o.
- **scikit-learn** ‚Üí biblioteca com ferramentas para pr√©-processamento, modelagem e avalia√ß√£o de dados.
- **pandas** ‚Üí manipula√ß√£o e an√°lise de dados em tabelas.
- **matplotlib, seaborn** ‚Üí gera√ß√£o de gr√°ficos e visualiza√ß√µes.
- **plotly** ‚Üí cria√ß√£o de gr√°ficos interativos.

</small>

---

### **üß© C√©lula 2 - Importa√ß√£o de Bibliotecas**

<details>

<summary> Trecho do codigo em Python </summary>

```python
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.linear_model import LinearRegression, Ridge
from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
import xgboost as xgb
import lightgbm as lgb
from catboost import CatBoostRegressor
import pickle

warnings.filterwarnings('ignore')
sns.set_style('whitegrid')

print("\n" + "=" * 80)
print("     FASE 3 COMPLETA: MODELAGEM AVAN√áADA + VISUALIZA√á√ïES")
print("=" * 80)

```

</details>

<small> üìñ Explica√ß√£o:

Nesta c√©lula, carregamos todas as bibliotecas necess√°rias para manipula√ß√£o, an√°lise, modelagem e visualiza√ß√£o dos dados.

- **pandas** e **numpy**: manipula√ß√£o e c√°lculo de dados.
- **matplotlib.pyplot** e **seaborn**: cria√ß√£o de gr√°ficos est√°ticos.
- **warnings**: para suprimir mensagens de aviso indesejadas.
- **sklearn.model_selection**: fun√ß√µes para divis√£o dos dados e valida√ß√£o cruzada.
- **sklearn.linear_model**: modelos de regress√£o Linear e Ridge.
- **sklearn.ensemble**: algoritmos ensemble como Random Forest e Gradient Boosting.
- **sklearn.metrics**: c√°lculo de m√©tricas de avalia√ß√£o como RMSE e R¬≤.
- **xgboost, lightgbm, catboost**: algoritmos de machine learning de alta performance.
- **pickle**: salvar e carregar modelos treinados.

As √∫ltimas linhas configuram o estilo dos gr√°ficos (`sns.set_style('whitegrid')`) e imprimem um t√≠tulo indicando o in√≠cio da fase 3.

</small>

---

### **üß© C√©lula 3 - Carregamento dos Dados**

<details>

<summary> Trecho do codigo em Python </summary>

```python
df = pd.read_excel('Dados_para_modelo.xlsx')

print(f"‚úÖ Dados carregados com sucesso. Shape: {df.shape}")
print(f"   Total de Jogadores: {len(df)}")
print(f"   Total de Colunas: {len(df.columns)}")

```

</details>

<small> üìñ Explica√ß√£o:

Esta c√©lula carrega os dados de um arquivo Excel chamado `'Dados_para_modelo.xlsx'` usando a biblioteca **pandas** e armazena em um DataFrame chamado `df`.

O DataFrame √© uma estrutura de dados semelhante a uma tabela, muito utilizada em an√°lise de dados.

- `df.shape` retorna uma tupla (n√∫mero de linhas, n√∫mero de colunas) para verificar o tamanho do dataset.
- `len(df)` retorna o n√∫mero total de linhas, representando a quantidade de jogadores.
- `len(df.columns)` retorna o n√∫mero total de colunas, representando as vari√°veis dispon√≠veis.

Essas impress√µes garantem que os dados foram carregados corretamente antes de prosseguir.

</small>

---

### **üß© C√©lula 4 - Separa√ß√£o de Features (X) e Targets (y)**

<details>

<summary> Trecho do codigo em Python </summary>

```python
targets = ['Target1', 'Target2', 'Target3']
X = df.drop(columns=targets)
y1 = df['Target1']
y2 = df['Target2']
y3 = df['Target3']

print(f"‚úÖ Features (X) separadas. Total de features: {X.shape[1]}")
print(f"‚úÖ Targets (y1, y2, y3) separados.")
```

</details>

<small> üìñ Explica√ß√£o:

Nesta c√©lula, o dataset √© separado em duas partes principais:

- **Features (X)**: as vari√°veis de entrada que ser√£o usadas para prever algo.
- **Targets (y)**: as vari√°veis que queremos prever.

No c√≥digo:

- `targets` √© uma lista com os nomes das colunas alvo (`Target1`, `Target2`, `Target3`).
- `X` cont√©m todas as colunas exceto as targets, obtido com `df.drop(columns=targets)`.
- `y1`, `y2` e `y3` cont√™m cada uma das targets separadamente.

</small>

---

### **üß© C√©lula 5 - Divis√£o em Dados de Treino e Teste (80/20)**

<details>

<summary> Trecho do codigo em Python </summary>

```python
X_train, X_test, y1_train, y1_test = train_test_split(X, y1, test_size=0.2, random_state=42)
_, _, y2_train, y2_test = train_test_split(X, y2, test_size=0.2, random_state=42)
_, _, y3_train, y3_test = train_test_split(X, y3, test_size=0.2, random_state=42)

print(f"‚úÖ Dados divididos em 80% treino e 20% teste.")
print(f"   Tamanho do treino: {len(X_train)} jogadores")
print(f"   Tamanho do teste:  {len(X_test)} jogadores")
```

</details>

<small> üìñ Explica√ß√£o:

Esta c√©lula divide os dados em conjuntos de treino e teste usando a fun√ß√£o `train_test_split` do **scikit-learn**.

- `test_size=0.2` significa que 20% dos dados ser√£o usados para teste e 80% para treino.
- `random_state=42` garante que a divis√£o seja reproduz√≠vel (sempre igual).

Para cada target (`y1`, `y2`, `y3`), s√£o criados conjuntos separados:

- `X_train`, `X_test`: dados de entrada para treino e teste.
- `y1_train`, `y1_test`, etc.: valores alvo correspondentes.

</small>

---

### **üß© C√©lula 6 - Defini√ß√£o dos Modelos a Serem Testados**

<details>

<summary> Trecho do codigo em Python </summary>

```python
modelos = {
    'Linear Regression': LinearRegression(),
    'Ridge': Ridge(alpha=1.0),
    'Random Forest': RandomForestRegressor(n_estimators=100, max_depth=10, random_state=42, n_jobs=-1),
    'Gradient Boosting': GradientBoostingRegressor(n_estimators=100, max_depth=5, random_state=42),
    'XGBoost': xgb.XGBRegressor(n_estimators=100, max_depth=6, learning_rate=0.1, random_state=42, n_jobs=-1),
    'LightGBM': lgb.LGBMRegressor(n_estimators=100, max_depth=6, learning_rate=0.1, random_state=42, n_jobs=-1, verbose=-1),
    'CatBoost': CatBoostRegressor(iterations=100, depth=6, learning_rate=0.1, random_state=42, verbose=False)
}
print(f"‚úÖ {len(modelos)} modelos definidos para teste.")
```

</details>

<small> üìñ Explica√ß√£o:

Nesta c√©lula definimos um dicion√°rio chamado `modelos` contendo v√°rios algoritmos de machine learning para serem testados no projeto.

Cada chave √© o nome do modelo e cada valor √© uma inst√¢ncia do modelo com par√¢metros definidos:

- **Linear Regression** e **Ridge**: modelos lineares b√°sicos.
- **Random Forest**: modelo ensemble baseado em √°rvores, com par√¢metros como `n_estimators` (n√∫mero de √°rvores) e `max_depth` (profundidade m√°xima).
- **Gradient Boosting**: modelo ensemble que ajusta sequencialmente as √°rvores para reduzir erros.
- **XGBoost, LightGBM, CatBoost**: algoritmos avan√ßados e muito eficientes para regress√£o, com par√¢metros como `learning_rate`, `max_depth` e n√∫mero de itera√ß√µes (`n_estimators` ou `iterations`).

</small>

---

### **üß© C√©lula 7 - Fun√ß√£o de Treinamento e Avalia√ß√£o**

<details>

<summary> Trecho do codigo em Python </summary>

```python
def treinar_avaliar_modelo(modelo, X_train, X_test, y_train, y_test):
    """Fun√ß√£o para treinar, prever e avaliar um modelo, retornando as m√©tricas e o modelo treinado."""
    modelo.fit(X_train, y_train)
    y_pred = modelo.predict(X_test)
    r2 = r2_score(y_test, y_pred)
    rmse = np.sqrt(mean_squared_error(y_test, y_pred))
    mae = mean_absolute_error(y_test, y_pred)
    return {'modelo': modelo, 'y_pred': y_pred, 'r2': r2, 'rmse': rmse, 'mae': mae}

```

</details>

<small> üìñ Explica√ß√£o:

Esta c√©lula define uma fun√ß√£o chamada `treinar_avaliar_modelo` que serve para treinar um modelo de machine learning e avaliar seu desempenho.

Par√¢metros da fun√ß√£o:

- `modelo`: objeto do modelo a ser treinado.
- `X_train`, `X_test`: dados de entrada para treino e teste.
- `y_train`, `y_test`: valores alvo para treino e teste.

O processo realizado dentro da fun√ß√£o:

1. `modelo.fit(X_train, y_train)` ‚Üí treina o modelo com os dados de treino.
2. `modelo.predict(X_test)` ‚Üí faz previs√µes com os dados de teste.
3. Calcula m√©tricas de avalia√ß√£o:
   - **R¬≤ (r2_score)**: mede a qualidade da previs√£o (quanto mais pr√≥ximo de 1, melhor).
   - **RMSE (root mean squared error)**: erro m√©dio quadr√°tico.
   - **MAE (mean absolute error)**: erro absoluto m√©dio.

A fun√ß√£o retorna um dicion√°rio com o modelo treinado, previs√µes e m√©tricas calculadas.

</small>

---

### **üß© C√©lula 8 - Treinamento e Avalia√ß√£o de Todos os Modelos**

<details>

<summary> Trecho do codigo em Python </summary>

```python
print("\n" + "=" * 80)
print("ETAPA 5: TREINAMENTO E AVALIA√á√ÉO DOS MODELOS")
print("=" * 80)

# --- Target 1 ---
resultados_t1 = {}
for nome, modelo in modelos.items():
    resultados_t1[nome] = treinar_avaliar_modelo(type(modelo)(**modelo.get_params()), X_train, X_test, y1_train, y1_test)
melhor_t1 = max(resultados_t1.items(), key=lambda x: x[1]['r2'])
print(f"üéØ Target 1 | Melhor Modelo: {melhor_t1[0]:<20} | R¬≤ = {melhor_t1[1]['r2']:.4f}")

# --- Target 2 ---
resultados_t2 = {}
for nome, modelo in modelos.items():
    resultados_t2[nome] = treinar_avaliar_modelo(type(modelo)(**modelo.get_params()), X_train, X_test, y2_train, y2_test)
melhor_t2 = max(resultados_t2.items(), key=lambda x: x[1]['r2'])
print(f"üéØ Target 2 | Melhor Modelo: {melhor_t2[0]:<20} | R¬≤ = {melhor_t2[1]['r2']:.4f}")

# --- Target 3 ---
resultados_t3 = {}
for nome, modelo in modelos.items():
    resultados_t3[nome] = treinar_avaliar_modelo(type(modelo)(**modelo.get_params()), X_train, X_test, y3_train, y3_test)
melhor_t3 = max(resultados_t3.items(), key=lambda x: x[1]['r2'])
print(f"üéØ Target 3 | Melhor Modelo: {melhor_t3[0]:<20} | R¬≤ = {melhor_t3[1]['r2']:.4f}")
```

</details>

<small> üìñ Explica√ß√£o:

Esta c√©lula realiza o treinamento e avalia√ß√£o de todos os modelos definidos para cada target (Target1, Target2, Target3).

O processo √© feito em tr√™s blocos:

1. Para cada target, criamos um dicion√°rio (`resultados_t1`, `resultados_t2`, `resultados_t3`) para armazenar os resultados.
2. Usamos um loop `for` para percorrer cada modelo definido no dicion√°rio `modelos`.
   - `type(modelo)(**modelo.get_params())` cria uma nova inst√¢ncia do modelo com os mesmos par√¢metros.
   - Chamamos a fun√ß√£o `treinar_avaliar_modelo` para treinar e avaliar o modelo.
3. Usamos `max(..., key=lambda x: x[1]['r2'])` para selecionar o modelo com melhor R¬≤ para cada target.

Ao final, imprimimos o nome do melhor modelo e seu R¬≤ para cada target.  
Isso ajuda a identificar qual modelo performou melhor para cada vari√°vel alvo.

</small>

---

### **üß© C√©lula 9 - Visualiza√ß√£o 1: Previsto vs. Real (Gr√°fico de Dispers√£o)**

<details>

<summary> Trecho do codigo em Python </summary>

```python
fig, axes = plt.subplots(1, 3, figsize=(18, 5))
fig.suptitle('An√°lise de Previs√£o vs. Valor Real para os Melhores Modelos', fontsize=16, fontweight='bold')

# Gr√°fico para Target 1
y1_pred = melhor_t1[1]['y_pred']
axes[0].scatter(y1_test, y1_pred, alpha=0.7, color='blue', edgecolors='k')
axes[0].plot([y1_test.min(), y1_test.max()], [y1_test.min(), y1_test.max()], 'r--', lw=2, label='Linha Perfeita')
axes[0].set_xlabel('Valores Reais', fontsize=12)
axes[0].set_ylabel('Valores Previstos', fontsize=12)
axes[0].set_title(f'Target 1 - {melhor_t1[0]}\nR¬≤={melhor_t1[1]["r2"]:.3f}', fontsize=14)
axes[0].legend()
axes[0].grid(True)

# Gr√°fico para Target 2
y2_pred = melhor_t2[1]['y_pred']
axes[1].scatter(y2_test, y2_pred, alpha=0.7, color='green', edgecolors='k')
axes[1].plot([y2_test.min(), y2_test.max()], [y2_test.min(), y2_test.max()], 'r--', lw=2, label='Linha Perfeita')
axes[1].set_xlabel('Valores Reais', fontsize=12)
axes[1].set_ylabel('Valores Previstos', fontsize=12)
axes[1].set_title(f'Target 2 - {melhor_t2[0]}\nR¬≤={melhor_t2[1]["r2"]:.3f}', fontsize=14)
axes[1].legend()
axes[1].grid(True)

# Gr√°fico para Target 3
y3_pred = melhor_t3[1]['y_pred']
axes[2].scatter(y3_test, y3_pred, alpha=0.7, color='purple', edgecolors='k')
axes[2].plot([y3_test.min(), y3_test.max()], [y3_test.min(), y3_test.max()], 'r--', lw=2, label='Linha Perfeita')
axes[2].set_xlabel('Valores Reais', fontsize=12)
axes[2].set_ylabel('Valores Previstos', fontsize=12)
axes[2].set_title(f'Target 3 - {melhor_t3[0]}\nR¬≤={melhor_t3[1]["r2"]:.3f}', fontsize=14)
axes[2].legend()
axes[2].grid(True)

plt.tight_layout(rect=[0, 0, 1, 0.96])
plt.savefig('grafico_dispersao_previsto_vs_real.png', dpi=300, bbox_inches='tight')
print("‚úÖ Gr√°fico de Dispers√£o (Previsto vs. Real) salvo como 'grafico_dispersao_previsto_vs_real.png'")
```

</details>

<small> üìñ Explica√ß√£o:

Esta c√©lula cria gr√°ficos de dispers√£o comparando valores previstos pelos melhores modelos com os valores reais para cada target (Target1, Target2, Target3).

O processo inclui:

- Cria√ß√£o de uma figura com tr√™s subplots (`plt.subplots(1, 3, figsize=(18, 5))`).
- Para cada target:
  - Plotar valores reais (`y_test`) vs. valores previstos (`y_pred`) usando `scatter()`.
  - Adicionar uma linha pontilhada (`plot()`) representando a previs√£o perfeita (quando previsto = real).
  - Configurar t√≠tulo, r√≥tulos e legenda.
- `plt.tight_layout()` ajusta o espa√ßamento entre gr√°ficos.
- `plt.savefig()` salva a figura como `'grafico_dispersao_previsto_vs_real.png'`.

Esse tipo de gr√°fico ajuda a visualizar a precis√£o do modelo e identificar padr√µes ou desvios.

</small>

---

### **üß© C√©lula 10 - Visualiza√ß√£o 2: Import√¢ncia das Features**

<details>

<summary> Trecho do codigo em Python </summary>

```python
def plotar_importancia(melhor_modelo_info, target_name, feature_names, ax):
    """Fun√ß√£o auxiliar para plotar a import√¢ncia das features em um eixo do matplotlib."""
    nome_modelo = melhor_modelo_info[0]
    modelo = melhor_modelo_info[1]['modelo']

    if hasattr(modelo, 'feature_importances_'):
        importances = modelo.feature_importances_
    else: # CatBoost
        importances = modelo.get_feature_importance()

    df_importances = pd.DataFrame({'feature': feature_names, 'importance': importances}).sort_values('importance', ascending=True).tail(15)

    ax.barh(df_importances['feature'], df_importances['importance'], color='darkcyan')
    ax.set_title(f'Top 15 Features - {target_name}\n(Modelo: {nome_modelo})', fontsize=14)
    ax.set_xlabel('Import√¢ncia')

fig, axes = plt.subplots(1, 3, figsize=(20, 8))
fig.suptitle('An√°lise de Import√¢ncia das Features para os Melhores Modelos', fontsize=16, fontweight='bold')

plotar_importancia(melhor_t1, 'Target 1', X.columns, axes[0])
plotar_importancia(melhor_t2, 'Target 2', X.columns, axes[1])
plotar_importancia(melhor_t3, 'Target 3', X.columns, axes[2])

plt.tight_layout(rect=[0, 0, 1, 0.95])
plt.savefig('grafico_feature_importance.png', dpi=300, bbox_inches='tight')
print("‚úÖ Gr√°fico de Import√¢ncia das Features salvo como 'grafico_feature_importance.png'")
```

</details>

<small> üìñ Explica√ß√£o:

Esta c√©lula cria gr√°ficos mostrando a import√¢ncia das features para os melhores modelos de cada target.

O processo inclui:

- Defini√ß√£o da fun√ß√£o `plotar_importancia()`, que:

  - Recebe informa√ß√µes do melhor modelo (`melhor_modelo_info`), o nome do target, os nomes das features e um eixo (`ax`) para plotagem.
  - Verifica se o modelo possui atributo `feature_importances_` (m√©todo comum em modelos de √°rvore). Caso seja CatBoost, usa `get_feature_importance()`.
  - Cria um DataFrame com nomes e import√¢ncias das features, ordenando e selecionando as 15 mais importantes.
  - Plota um gr√°fico de barras horizontais (`barh`).

- Cria√ß√£o de uma figura com tr√™s subplots para cada target.
- Chamadas da fun√ß√£o `plotar_importancia` para cada target.
- Ajuste de layout e salvamento do gr√°fico como `'grafico_feature_importance.png'`.

Esses gr√°ficos ajudam a entender quais vari√°veis t√™m maior influ√™ncia na previs√£o do modelo.

</small>

---

### **üß© C√©lula 11 - Salvando os Melhores Modelos**

<details>

<summary> Trecho do codigo em Python </summary>

```python
with open('modelo_target1_final.pkl', 'wb') as f: pickle.dump(melhor_t1[1]['modelo'], f)
print(f"‚úÖ Modelo para Target 1 ({melhor_t1[0]}) salvo como 'modelo_target1_final.pkl'")

with open('modelo_target2_final.pkl', 'wb') as f: pickle.dump(melhor_t2[1]['modelo'], f)
print(f"‚úÖ Modelo para Target 2 ({melhor_t2[0]}) salvo como 'modelo_target2_final.pkl'")

with open('modelo_target3_final.pkl', 'wb') as f: pickle.dump(melhor_t3[1]['modelo'], f)
print(f"‚úÖ Modelo para Target 3 ({melhor_t3[0]}) salvo como 'modelo_target3_final.pkl'")
```

</details>

<small> üìñ Explica√ß√£o:

Esta c√©lula salva os melhores modelos encontrados para cada target usando a biblioteca **pickle**.

O processo:

- Para cada target, abrimos um arquivo `.pkl` em modo de escrita bin√°ria (`'wb'`).
- Usamos `pickle.dump()` para salvar o modelo treinado (`melhor_tX[1]['modelo']`).
- Cada arquivo recebe um nome correspondente ao target (`modelo_target1_final.pkl`, etc.).
- Mensagens confirmam que os modelos foram salvos com sucesso.

Esses arquivos `.pkl` podem ser carregados posteriormente para fazer previs√µes sem precisar treinar novamente o modelo.

</small>

---

### **üß© C√©lula 12 - Relat√≥rio Final dos Resultados**

<details>

<summary> Trecho do codigo em Python </summary>

```python
print("\n" + "=" * 80)
print("üéâ FASE 3 COMPLETA - RELAT√ìRIO FINAL üéâ")
print("=" * 80)

print("\nüìä RESUMO DOS MELHORES MODELOS:\n")

print(f"  TARGET 1")
print(f"  - Melhor Modelo: {melhor_t1[0]}")
print(f"  - R¬≤ (R-quadrado): {melhor_t1[1]['r2']:.4f}  (Explica ~{melhor_t1[1]['r2']:.1%} da vari√¢ncia)")
print(f"  - RMSE (Erro M√©dio): {melhor_t1[1]['rmse']:.2f} pontos")
print(f"  - MAE (Erro Absoluto M√©dio): {melhor_t1[1]['mae']:.2f} pontos\n")

print(f"  TARGET 2")
print(f"  - Melhor Modelo: {melhor_t2[0]}")
print(f"  - R¬≤ (R-quadrado): {melhor_t2[1]['r2']:.4f}  (Explica ~{melhor_t2[1]['r2']:.1%} da vari√¢ncia)")
print(f"  - RMSE (Erro M√©dio): {melhor_t2[1]['rmse']:.2f} pontos")
print(f"  - MAE (Erro Absoluto M√©dio): {melhor_t2[1]['mae']:.2f} pontos\n")

print(f"  TARGET 3")
print(f"  - Melhor Modelo: {melhor_t3[0]}")
print(f"  - R¬≤ (R-quadrado): {melhor_t3[1]['r2']:.4f}  (Explica ~{melhor_t3[1]['r2']:.1%} da vari√¢ncia)")
print(f"  - RMSE (Erro M√©dio): {melhor_t3[1]['rmse']:.2f} pontos")
print(f"  - MAE (Erro Absoluto M√©dio): {melhor_t3[1]['mae']:.2f} pontos\n")

print("üìÅ ARQUIVOS GERADOS:")
print("  ‚úÖ modelo_target1_final.pkl")
print("  ‚úÖ modelo_target2_final.pkl")
print("  ‚úÖ modelo_target3_final.pkl")
print("  ‚úÖ grafico_dispersao_previsto_vs_real.png")
print("  ‚úÖ grafico_feature_importance.png")

print("\nüöÄ PR√ìXIMOS PASSOS:")
print("  1. Usar os arquivos '.pkl' salvos para carregar os modelos no seu backend (Node.js/FastAPI).")
print("  2. Criar as rotas da API que recebem novos dados de jogadores e usam os modelos para prever os targets.")
print("  3. Desenvolver o dashboard interativo que consome essa API e exibe os resultados e insights.")
print("  4. Preparar a apresenta√ß√£o de slides contando a hist√≥ria do projeto, dos dados aos resultados.")

print("\n‚ú® Excelente trabalho! A etapa de modelagem e an√°lise est√° conclu√≠da. ‚ú®")
```

</details>

<small> üìñ Explica√ß√£o:

Esta c√©lula gera um relat√≥rio final resumindo os resultados obtidos na fase de modelagem.

O conte√∫do inclui:

- **Resumo dos Melhores Modelos** para cada target, exibindo:
  - Nome do modelo com melhor performance.
  - R¬≤ (R-quadrado): mede a qualidade da previs√£o.
  - RMSE: erro m√©dio quadr√°tico.
  - MAE: erro absoluto m√©dio.
- **Lista dos arquivos gerados** no processo, incluindo modelos `.pkl` e gr√°ficos.
- **Pr√≥ximos passos sugeridos**, como integrar os modelos salvos a uma API e criar dashboards interativos.

</small>

---

</details>

---

**üìà Vis√£o Geral dos Resultados da Modelagem**

<small>
Nesta fase, o dataset limpo e otimizado foi utilizado para treinar e avaliar **7 algoritmos de regress√£o diferentes**, com o objetivo de encontrar o melhor modelo para prever cada uma das tr√™s m√©tricas-alvo.

Ap√≥s o treinamento e a valida√ß√£o, os modelos com melhor desempenho, medido pelo coeficiente de determina√ß√£o (R¬≤), foram:

- **Target 1**: **CatBoost**, com **R¬≤ = 0.577**. Isso indica que o modelo consegue explicar aproximadamente **57,7%** da varia√ß√£o nos dados.
- **Target 2**: **Random Forest**, com **R¬≤ = 0.406**, explicando cerca de **40,6%** da vari√¢ncia.
- **Target 3**: **Random Forest**, com **R¬≤ = 0.420**, explicando aproximadamente **42,0%** da vari√¢ncia.

A imagem abaixo apresenta uma an√°lise visual da performance desses tr√™s modelos. Cada gr√°fico de dispers√£o compara os **valores reais** (eixo X) com os **valores previstos** pelo modelo (eixo Y). A "Linha Perfeita" (tracejada em vermelho) representa o cen√°rio ideal, onde a previs√£o √© exatamente igual ao valor real.

Quanto mais pr√≥ximos os pontos estiverem dessa linha, mais precisas s√£o as previs√µes do modelo. Essa visualiza√ß√£o ajuda a entender rapidamente a capacidade preditiva dos modelos escolhidos.
</small>

![alt text](data/processed/02_model_ready/grafico_dispersao_previsto_vs_real.png)
</file>

<file path="dashboard/frontend/Dockerfile">
FROM python:3.10-slim

WORKDIR /app

# Instala depend√™ncias
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copia o c√≥digo da aplica√ß√£o
COPY dashboard_dash.py .

# Expor a porta do Dash (8050 √© o padr√£o do Plotly Dash)
EXPOSE 8050

# Comando para rodar a aplica√ß√£o Dash
# O Dash √© executado como um script Python normal (dashboard_dash.py), 
# onde a porta 8050 e o host 0.0.0.0 j√° est√£o definidos internamente.
CMD ["python", "dashboard_dash.py"]
</file>

<file path="dashboard/frontend/requirements.txt">
requests # Para fazer chamadas HTTP ao Flask
pandas
plotly-express
plotly
xlsxwriter
shap
matplotlib
dash 
dash-bootstrap-components 
dash-core-components 
dash-html-components 
dash-table 
numpy 
shap
</file>

<file path="dashboard/docker-compose.yml">
version: '3.8'

services:
  # 1. SERVI√áO DO BANCO DE DADOS (PostgreSQL)
  db:
    image: postgres:15-alpine
    restart: always
    environment:
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}
    ports:
      - "5433:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data/
    networks:
      - daruma_net

  # 2. SERVI√áO DA API (Flask/FastAPI)
  backend:
    build: ./backend
    restart: always
    environment:
      # Vari√°veis de ambiente para o Flask se conectar ao DB
      DATABASE_URL: postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@db:5432/${POSTGRES_DB}
      JWT_SECRET_KEY: ${JWT_SECRET_KEY}
    depends_on:
      - db
    networks:
      - daruma_net

  # 3. SERVI√áO DO DASHBOARD (PLOTLY DASH)
  frontend:
    build:
      context: ./frontend  # Assumindo que o Dockerfile e o c√≥digo est√£o em uma pasta 'frontend'
    restart: always
    environment:
      # Vari√°vel para o Dash saber onde est√° o Backend
      BACKEND_URL: http://backend:5000
    depends_on:
      - backend
    ports:
      # CORRE√á√ÉO: Mapeando a porta padr√£o do Dash (8050)
      - "127.0.0.1:8050:8050"
    networks:
      - daruma_net

networks:
  daruma_net:
    driver: bridge

volumes:
  postgres_data:
</file>

<file path="dashboard/backend/Dockerfile">
FROM python:3.10-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copia todos os arquivos da aplica√ß√£o
COPY . .

EXPOSE 5000

# Comando para rodar a aplica√ß√£o com Uvicorn (servidor ASGI para FastAPI)
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "5000"]
</file>

<file path="dashboard/backend/main.py">
# main.py (VERS√ÉO FINAL CORRIGIDA E ROBUSTA)

import os
import pickle
import joblib
import pandas as pd
import numpy as np
import shap
from fastapi import FastAPI, Depends, HTTPException, UploadFile, File, status
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError
from sqlalchemy import func
import crud
import models
import schemas
import auth
import database
from sklearn.ensemble import StackingRegressor
from sklearn.metrics import silhouette_score
from flask_bcrypt import Bcrypt
from core import app
from io import BytesIO
import warnings
from pandas.errors import SettingWithCopyWarning
import traceback

# Silenciar warnings espec√≠ficos
warnings.simplefilter(action="ignore", category=FutureWarning)
warnings.filterwarnings("ignore", message="Mean of empty slice")
warnings.filterwarnings("ignore", message="DataFrame is highly fragmented")

# Cria tabelas no DB (se n√£o existirem) ao iniciar
try:
    models.Base.metadata.create_all(bind=database.engine)
except Exception as e:
    print(f"Aviso: N√£o foi poss√≠vel criar tabelas do DB na inicializa√ß√£o (pode ser normal se j√° existirem): {e}")

# --- Carregamento de Artefatos de ML ---
ARTIFACTS_PATH = os.getenv('ARTIFACTS_PATH', 'ml_artifacts')
MODELS, SCALERS, FEATURES, EXPLAINERS = {}, {}, {}, {}
CLUSTERING_MODELS = {}

try:
    # Target 1 (modelo √∫nico)
    MODELS['target1'] = joblib.load(f"{ARTIFACTS_PATH}/modelo_target1.pkl")
    SCALERS['target1'] = joblib.load(f"{ARTIFACTS_PATH}/scaler_target1.pkl")
    with open(f"{ARTIFACTS_PATH}/features_target1.pkl", "rb") as f:
        FEATURES['target1'] = pickle.load(f)
    EXPLAINERS['target1'] = shap.TreeExplainer(MODELS['target1'])

    # Targets 2 e 3 (ensemble de 3 modelos cada)
    for target in ['target2', 'target3']:
        MODELS[target] = []
        for i in range(3):
            model = joblib.load(f"{ARTIFACTS_PATH}/modelo_{target}_ensemble_{i}.pkl")
            MODELS[target].append(model)
        
        SCALERS[target] = joblib.load(f"{ARTIFACTS_PATH}/scaler_{target}.pkl")
        with open(f"{ARTIFACTS_PATH}/features_{target}.pkl", "rb") as f:
            FEATURES[target] = pickle.load(f)
        
        EXPLAINERS[target] = [shap.TreeExplainer(m) for m in MODELS[target]]

    # Carregamento dos modelos de clustering
    CLUSTERING_MODELS['kmeans'] = joblib.load(f"{ARTIFACTS_PATH}/kmeans_model.pkl")
    CLUSTERING_MODELS['pca'] = joblib.load(f"{ARTIFACTS_PATH}/pca_model.pkl")
    CLUSTERING_MODELS['scaler'] = joblib.load(f"{ARTIFACTS_PATH}/scaler_cluster.pkl")
    with open(f"{ARTIFACTS_PATH}/cluster_features.pkl", "rb") as f:
        CLUSTERING_MODELS['features'] = pickle.load(f)
    with open(f"{ARTIFACTS_PATH}/cluster_names.pkl", "rb") as f:
        CLUSTERING_MODELS['names'] = pickle.load(f)

    print("‚úÖ Todos os artefatos de ML (Previs√£o e Clustering) carregados com sucesso.")
except Exception as e:
    print(f"‚ùå ERRO CR√çTICO ao carregar artefatos de ML: {e}")
    MODELS = None

# --- FUN√á√ÉO CR√çTICA: CORRIGIR COLUNAS DUPLICADAS ---
def fix_duplicate_columns(df):
    cols = pd.Series(df.columns)
    duplicated = cols[cols.duplicated()].unique()
    if len(duplicated) > 0:
        print(f"‚ö†Ô∏è Colunas duplicadas detectadas: {list(duplicated)}")
        for dup in duplicated:
            mask = cols == dup
            indices = cols[mask].index.tolist()
            for i, idx in enumerate(indices[1:], 1):
                new_name = f"{dup}_v{i+1}"
                cols.iloc[idx] = new_name
                print(f"  ‚úèÔ∏è Renomeando '{dup}' (ocorr√™ncia {i+1}) para '{new_name}'")
        df.columns = cols
        print("‚úÖ Colunas duplicadas corrigidas!")
    return df

# --- FUN√á√ïES AUXILIARES SEGURAS ---
def safe_mean(df, columns, axis=1):
    valid_cols = [col for col in columns if col in df.columns]
    if not valid_cols: return pd.Series(0, index=df.index)
    return df[valid_cols].mean(axis=axis)

def safe_std(df, columns, axis=1):
    valid_cols = [col for col in columns if col in df.columns]
    if not valid_cols: return pd.Series(0, index=df.index)
    return df[valid_cols].std(axis=axis)

def safe_min(df, columns, axis=1):
    valid_cols = [col for col in columns if col in df.columns]
    if not valid_cols: return pd.Series(0, index=df.index)
    return df[valid_cols].min(axis=axis)

def safe_max(df, columns, axis=1):
    valid_cols = [col for col in columns if col in df.columns]
    if not valid_cols: return pd.Series(0, index=df.index)
    return df[valid_cols].max(axis=axis)

# --- Fun√ß√µes de Pr√©-processamento (sem altera√ß√µes) ---
def preprocess_target1(df_input):
    df = fix_duplicate_columns(df_input.copy())
    if 'F0103' in df.columns: df['F0103'] = pd.to_numeric(df['F0103'].astype(str).str.replace(',', '.'), errors='coerce')
    p_cols = [c for c in df.columns if c.startswith('P') and any(char.isdigit() for char in c)]
    t_cols = [c for c in df.columns if c.startswith('T') and any(char.isdigit() for char in c)]
    f_cols = [c for c in df.columns if c.startswith('F') and len(c) > 1 and any(char.isdigit() for char in c)]
    new_cols = {}
    if p_cols: new_cols['taxa_pulos_P'] = sum((df[col] == -1).sum() for col in p_cols if col in df.columns) / len(p_cols)
    else: new_cols['taxa_pulos_P'] = 0
    if t_cols: new_cols['taxa_pulos_T'] = sum((df[col] == -1).sum() for col in t_cols if col in df.columns) / len(t_cols)
    else: new_cols['taxa_pulos_T'] = 0
    total = len(p_cols) + len(t_cols)
    new_cols['taxa_pulos_geral'] = (new_cols['taxa_pulos_P'] * len(p_cols) + new_cols['taxa_pulos_T'] * len(t_cols)) / total if total > 0 else 0
    for col in p_cols + t_cols + f_cols:
        if col in df.columns:
            df[col] = pd.to_numeric(df[col], errors='coerce').replace(-1, np.nan)
            if df[col].isnull().sum() > 0: df[col].fillna(df[col].median(), inplace=True)
    if 'QtdHorasDormi' in df.columns and 'Acordar' in df.columns:
        new_cols.update({'sono_total': df['QtdHorasDormi'], 'sono_x_acordar': df['QtdHorasDormi'] * df['Acordar'], 'sono_squared': df['QtdHorasDormi'] ** 2, 'sono_irregular': np.abs(df['QtdHorasDormi'] - df['QtdHorasDormi'].median())})
    if p_cols:
        new_cols.update({'P_mean': safe_mean(df, p_cols), 'P_std': safe_std(df, p_cols), 'P_min': safe_min(df, p_cols), 'P_max': safe_max(df, p_cols)})
        new_cols['P_range'] = new_cols['P_max'] - new_cols['P_min']
        new_cols['P_late'] = safe_mean(df, [c for name in ['P09', 'P12', 'P13', 'P15'] for c in df.columns if c.startswith(name)])
        new_cols['P_early'] = safe_mean(df, [c for name in ['P01', 'P02', 'P03', 'P04'] for c in df.columns if c.startswith(name)])
    if t_cols: new_cols.update({'T_mean': safe_mean(df, t_cols), 'T_std': safe_std(df, t_cols), 'T_min': safe_min(df, t_cols), 'T_max': safe_max(df, t_cols)})
    f_perfil = [c for c in f_cols if c.startswith('F01') or c.startswith('F02')]
    if f_perfil: new_cols.update({'F_perfil_mean': safe_mean(df, f_perfil), 'F_perfil_std': safe_std(df, f_perfil)})
    f_sono = [c for c in f_cols if c.startswith('F07')]
    if f_sono: new_cols.update({'F_sono_mean': safe_mean(df, f_sono), 'F_sono_std': safe_std(df, f_sono)})
    f_final = [c for c in f_cols if c.startswith('F11')]
    if f_final: new_cols.update({'F_final_mean': safe_mean(df, f_final), 'F_final_std': safe_std(df, f_final)})
    if f_cols: new_cols['F_mean_geral'] = safe_mean(df, f_cols)
    df = pd.concat([df, pd.DataFrame(new_cols, index=df.index)], axis=1)
    top3 = [f for f in FEATURES['target1'] if '_X_' not in f][:3]
    for i, f1 in enumerate(top3):
        for f2 in top3[i+1:]:
            interaction_name = f'{f1}_X_{f2}'; df[interaction_name] = df[f1] * df[f2] if f1 in df.columns and f2 in df.columns else 0
    return SCALERS['target1'].transform(df.reindex(columns=FEATURES['target1'], fill_value=0))

def preprocess_target2(df_input):
    df = fix_duplicate_columns(df_input.copy())
    if 'F0103' in df.columns: df['F0103'] = pd.to_numeric(df['F0103'].astype(str).str.replace(',', '.'), errors='coerce')
    all_cols = [c for c in df.columns if (c.startswith(('P', 'T')) or (c.startswith('F') and len(c) > 1)) and any(char.isdigit() for char in c)]
    for col in all_cols:
        if col in df.columns:
            df[col] = pd.to_numeric(df[col], errors='coerce').replace(-1, np.nan)
            if df[col].isnull().sum() > 0: df[col].fillna(df[col].median(), inplace=True)
    new_cols = {}
    if 'QtdHorasDormi' in df.columns and 'Acordar' in df.columns: new_cols.update({'sono_total': df['QtdHorasDormi'], 'acordar': df['Acordar']})
    f_cols = [c for c in df.columns if c.startswith('F') and len(c) > 1 and any(char.isdigit() for char in c)]
    if f_sono := [c for c in f_cols if c.startswith('F07')]: new_cols['F_sono_mean'] = safe_mean(df, f_sono)
    if f_final := [c for c in f_cols if c.startswith('F11')]: new_cols['F_final_mean'] = safe_mean(df, f_final)
    if p_cols := [c for c in df.columns if c.startswith('P') and any(char.isdigit() for char in c)]: new_cols['P_mean'] = safe_mean(df, p_cols)
    df = pd.concat([df, pd.DataFrame(new_cols, index=df.index)], axis=1)
    base_features = [f for f in FEATURES['target2'] if '_X_' not in f]
    if len(base_features) >= 2:
        f1, f2 = base_features[0], base_features[1]
        interaction_name = f'{f1}_X_{f2}'
        if interaction_name in FEATURES['target2']:
            df[interaction_name] = df[f1] * df[f2] if f1 in df.columns and f2 in df.columns else 0
    return SCALERS['target2'].transform(df.reindex(columns=FEATURES['target2'], fill_value=0))

def preprocess_target3(df_input):
    df = fix_duplicate_columns(df_input.copy())
    if 'F0103' in df.columns: df['F0103'] = pd.to_numeric(df['F0103'].astype(str).str.replace(',', '.'), errors='coerce')
    all_cols = [c for c in df.columns if (c.startswith(('P', 'T')) or (c.startswith('F') and len(c) > 1)) and any(char.isdigit() for char in c)]
    for col in all_cols:
        if col in df.columns:
            df[col] = pd.to_numeric(df[col], errors='coerce').replace(-1, np.nan)
            if df[col].isnull().sum() > 0: df[col].fillna(df[col].median(), inplace=True)
    new_cols = {}
    if p_cols := [c for c in df.columns if c.startswith('P') and any(char.isdigit() for char in c)]:
        new_cols.update({'P_mean': safe_mean(df, p_cols), 'P_std': safe_std(df, p_cols)})
        new_cols['P_late'] = safe_mean(df, [c for name in ['P09', 'P12', 'P13', 'P15'] for c in df.columns if c.startswith(name)])
        new_cols['P_early'] = safe_mean(df, [c for name in ['P01', 'P02', 'P03', 'P04'] for c in df.columns if c.startswith(name)])
    if t_cols := [c for c in df.columns if c.startswith('T') and any(char.isdigit() for char in c)]: new_cols.update({'T_mean': safe_mean(df, t_cols), 'T_std': safe_std(df, t_cols)})
    if 'QtdHorasSono' in df.columns:
        f_cols = [c for c in df.columns if c.startswith('F') and len(c) > 1 and any(char.isdigit() for char in c)]
        if f_sono := [c for c in f_cols if '07' in c]: new_cols.update({'F_sono_mean': safe_mean(df, f_sono), 'F_sono_std': safe_std(df, f_sono), 'F_sono_max': safe_max(df, f_sono)})
        if 'Acordar' in df.columns: new_cols.update({'sono_x_acordar': df['QtdHorasSono'] * df['Acordar'], 'acordar_squared': df['Acordar'] ** 2})
    if f_final := [c for c in f_cols if '11' in c]: new_cols['F_final_mean'] = safe_mean(df, f_final)
    df = pd.concat([df, pd.DataFrame(new_cols, index=df.index)], axis=1)
    if 'F1103' in df.columns and 'P_mean' in df.columns and 'F1103_X_P_mean' in FEATURES['target3']: df['F1103_X_P_mean'] = df['F1103'] * df['P_mean']
    return SCALERS['target3'].transform(df.reindex(columns=FEATURES['target3'], fill_value=0))

# --- Rotas da API ---

@app.get("/health", status_code=status.HTTP_200_OK)
def health_check():
    if MODELS is None: raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail="Modelos de ML n√£o carregados.")
    return {"status": "ok"}

@app.post("/register", status_code=status.HTTP_201_CREATED)
def register(user: schemas.UserCreate, db: Session = Depends(database.get_db)):
    if crud.get_user_by_username(db, username=user.username): raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail="Usu√°rio j√° existe")
    try:
        crud.create_user(db=db, user_schema=user)
        return {"msg": "Usu√°rio registrado com sucesso"}
    except IntegrityError:
        db.rollback(); raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail="Usu√°rio j√° existe")

@app.post("/login", response_model=schemas.Token)
def login(form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(database.get_db)):
    user = crud.get_user_by_username(db, username=form_data.username)
    if not user or not auth.verify_password(form_data.password, user.password_hash):
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Credenciais inv√°lidas")
    access_token = auth.create_access_token(data={"sub": str(user.id)})
    return {"access_token": access_token, "token_type": "bearer"}

# ############### IN√çCIO DA CORRE√á√ÉO ###############
@app.post("/clustering")
async def get_clustering_analysis(file: UploadFile = File(...), user_id: str = Depends(auth.get_current_user_id)):
    if not CLUSTERING_MODELS:
        raise HTTPException(status_code=503, detail="Modelos de clustering n√£o dispon√≠veis.")
    
    try:
        contents = await file.read()
        df = pd.read_excel(BytesIO(contents))
        
        # Guarda uma c√≥pia do dataframe original ANTES de qualquer modifica√ß√£o
        df_original_para_previsao = df.copy()
        
        df = fix_duplicate_columns(df)
        
        # Recria as features necess√°rias para o clustering
        p_cols = [c for c in df.columns if c.startswith('P') and any(char.isdigit() for char in c)]
        t_cols = [c for c in df.columns if c.startswith('T') and any(char.isdigit() for char in c)]
        
        for col in p_cols + t_cols:
            if col in df.columns:
                df[col] = pd.to_numeric(df[col], errors='coerce').replace(-1, np.nan)
                if df[col].isnull().sum() > 0:
                    df[col].fillna(df[col].median(), inplace=True)
        
        if p_cols:
            df['P_mean'] = safe_mean(df, p_cols)
            df['P_std'] = safe_std(df, p_cols)
            df['P_max'] = safe_max(df, p_cols)
        
        if t_cols:
            df['T_mean'] = safe_mean(df, t_cols)
            df['T_total'] = df[t_cols].sum(axis=1) if t_cols else 0
        
        f_cols = [c for c in df.columns if c.startswith('F') and len(c) > 1 and any(char.isdigit() for char in c)]
        if f_sono := [c for c in f_cols if c.startswith('F07')]: df['F_sono_mean'] = safe_mean(df, f_sono)
        if f_final := [c for c in f_cols if c.startswith('F11')]: df['F_final_mean'] = safe_mean(df, f_final)
        
        X_cluster = df.reindex(columns=CLUSTERING_MODELS['features'], fill_value=0)
        
        X_scaled = CLUSTERING_MODELS['scaler'].transform(X_cluster)
        clusters = CLUSTERING_MODELS['kmeans'].predict(X_scaled)
        X_pca = CLUSTERING_MODELS['pca'].transform(X_scaled)
        
        # Usa a c√≥pia original do DF para as previs√µes, evitando erros
        df['Previs√£o T1'] = MODELS['target1'].predict(preprocess_target1(df_original_para_previsao.copy()))
        df['Previs√£o T2'] = np.mean([m.predict(preprocess_target2(df_original_para_previsao.copy())) for m in MODELS['target2']], axis=0)
        df['Previs√£o T3'] = np.mean([m.predict(preprocess_target3(df_original_para_previsao.copy())) for m in MODELS['target3']], axis=0)
        df['Cluster'] = clusters
        
        stats = {}
        cluster_names = CLUSTERING_MODELS['names']
        for cid in np.unique(clusters):
            mask = clusters == cid
            def safe_float(value): return 0.0 if pd.isna(value) else float(value)
            stats[str(cid)] = {
                "name": cluster_names.get(cid, f"Cluster {cid}"),
                "count": int(mask.sum()),
                "percentage": float(mask.sum() / len(clusters) * 100) if len(clusters) > 0 else 0.0,
                "P_mean": safe_float(df.loc[mask, 'P_mean'].mean()) if 'P_mean' in df.columns else 0.0,
                "Target1": safe_float(df.loc[mask, 'Previs√£o T1'].mean()),
                "Target2": safe_float(df.loc[mask, 'Previs√£o T2'].mean()),
                "Target3": safe_float(df.loc[mask, 'Previs√£o T3'].mean())
            }

        jogadores = df_original_para_previsao['C√≥digo de Acesso'].tolist() if 'C√≥digo de Acesso' in df_original_para_previsao.columns else list(range(len(df)))
        counts = {str(i): float(np.sum(clusters == i) / len(clusters)) for i in np.unique(clusters)}
        
        return {
            "pca_coords": X_pca.tolist(), "clusters": clusters.tolist(),
            "jogadores": jogadores, "stats": stats, "counts": counts
        }
        
    except Exception as e:
        print(f"‚ùå ERRO EXPL√çCITO NO ENDPOINT DE CLUSTERING: {e}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Erro interno no processo de clustering: {e}")

# ############### FIM DA CORRE√á√ÉO ###############

@app.post("/predict")
async def predict(file: UploadFile = File(...), user_id: str = Depends(auth.get_current_user_id), db: Session = Depends(database.get_db)):
    if MODELS is None: raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail="Modelos de ML n√£o est√£o dispon√≠veis.")
    try:
        contents = await file.read(); buffer = BytesIO(contents); df_new = pd.read_excel(buffer)
        df_new = fix_duplicate_columns(df_new)
        if 'C√≥digo de Acesso' not in df_new.columns: raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Coluna 'C√≥digo de Acesso' n√£o encontrada.")
    except Exception as e: raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=f"Erro ao ler o arquivo Excel: {e}")
    df_results = df_new.copy(); shap_data = {}
    try:
        X_scaled_t1 = preprocess_target1(df_new)
        df_results['Previs√£o T1'] = MODELS['target1'].predict(X_scaled_t1).round(2)
        X_scaled_t2 = preprocess_target2(df_new)
        df_results['Previs√£o T2'] = np.mean([model.predict(X_scaled_t2) for model in MODELS['target2']], axis=0).round(2)
        X_scaled_t3 = preprocess_target3(df_new)
        df_results['Previs√£o T3'] = np.mean([model.predict(X_scaled_t3) for model in MODELS['target3']], axis=0).round(2)
        
        shap_values_t1 = EXPLAINERS['target1'].shap_values(X_scaled_t1)
        shap_values_t2 = np.mean([explainer.shap_values(X_scaled_t2) for explainer in EXPLAINERS['target2']], axis=0)
        shap_values_t3 = np.mean([explainer.shap_values(X_scaled_t3) for explainer in EXPLAINERS['target3']], axis=0)

        for i, j_id in enumerate(df_results['C√≥digo de Acesso']):
            shap_data[str(j_id)] = {
                'T1': {'shap_values': shap_values_t1[i].tolist(), 'feature_names': FEATURES['target1']},
                'T2': {'shap_values': shap_values_t2[i].tolist(), 'feature_names': FEATURES['target2']},
                'T3': {'shap_values': shap_values_t3[i].tolist(), 'feature_names': FEATURES['target3']}
            }
    except Exception as e: raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"Erro no pipeline de previs√£o: {e}")
    try:
        for _, row in df_results.iterrows():
            db.add(models.Prediction(user_id=int(user_id), jogador_id=str(row['C√≥digo de Acesso']), pred_t1=row['Previs√£o T1'], pred_t2=row['Previs√£o T2'], pred_t3=row['Previs√£o T3']))
        db.commit()
    except Exception as e:
        db.rollback(); raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"Erro ao salvar previs√£o no banco de dados: {e}")
    return {
        "predictions": df_results[['C√≥digo de Acesso', 'Previs√£o T1', 'Previs√£o T2', 'Previs√£o T3']].to_dict('records'),
        "shap_data": shap_data
    }

@app.get("/history")
def get_history(user_id: str = Depends(auth.get_current_user_id), db: Session = Depends(database.get_db)):
    query = db.query(
        models.Prediction.upload_timestamp, func.count(models.Prediction.id).label('num_jogadores')
    ).filter(models.Prediction.user_id == int(user_id)).group_by(models.Prediction.upload_timestamp).order_by(models.Prediction.upload_timestamp.desc()).all()
    return [{"timestamp": r.upload_timestamp.strftime("%Y-%m-%d %H:%M:%S"), "num_jogadores": r.num_jogadores} for r in query]

@app.get("/feature_importance")
def get_feature_importance(user_id: str = Depends(auth.get_current_user_id)):
    if MODELS is None: raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail="Modelos de ML n√£o carregados.")
    importances_data = {}
    try:
        if hasattr(MODELS['target1'], 'feature_importances_'):
            df_imp_t1 = pd.DataFrame({'feature': FEATURES['target1'], 'importance': MODELS['target1'].feature_importances_}).sort_values(by='importance', ascending=False).head(20)
            importances_data['Target1'] = df_imp_t1.to_dict('records')
        
        for target_key, target_name in [('target2', 'Target2'), ('target3', 'Target3')]:
            if all_importances := [model.feature_importances_ for model in MODELS[target_key] if hasattr(model, 'feature_importances_')]:
                df_imp = pd.DataFrame({'feature': FEATURES[target_key], 'importance': np.mean(all_importances, axis=0)}).sort_values(by='importance', ascending=False).head(20)
                importances_data[target_name] = df_imp.to_dict('records')
        return importances_data
    except Exception as e: raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"Erro ao calcular feature importance: {e}")
</file>

<file path="dashboard/backend/requirements.txt">
fastapi
uvicorn[standard]
python-multipart
sqlalchemy
psycopg2-binary
python-jose[cryptography]
pandas
scikit-learn==1.7.2 # Fixando a vers√£o para consist√™ncia
joblib
openpyxl
catboost
shap
Flask-Bcrypt 
optuna
lightgbm
xgboost
reportlab
</file>

<file path="dashboard/frontend/dashboard_dash.py">
# dashboard/frontend/dashboard_dash.py (VERS√ÉO FINAL REFATORADA E ROBUSTA)

import dash
from dash import dcc, html, dash_table
from dash.dependencies import Input, Output, State
from dash.exceptions import PreventUpdate
import dash_bootstrap_components as dbc
import requests
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
import os
from io import BytesIO
import base64
import numpy as np

# --- Configura√ß√£o ---
BACKEND_URL = os.getenv('BACKEND_URL', 'http://localhost:5000') 
app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP], suppress_callback_exceptions=True)
app.title = "üéØ Projeto Daruma: Dashboard de Previs√£o"
server = app.server

# =============================================================================
# FUN√á√ïES DE API E UTILIT√ÅRIAS
# =============================================================================

def login_api(username, password):
    try:
        response = requests.post(f"{BACKEND_URL}/login", data={'username': username, 'password': password})
        if response.status_code == 200: return response.json().get('access_token'), None
        return None, response.json().get('detail', 'Erro desconhecido no login.')
    except requests.exceptions.RequestException as e: return None, f"Erro de conex√£o com o backend: {e}"

def register_api(username, password):
    try:
        response = requests.post(f"{BACKEND_URL}/register", json={'username': username, 'password': password})
        return (True, response.json().get('msg')) if response.status_code == 201 else (False, response.json().get('msg', 'Erro desconhecido'))
    except requests.exceptions.RequestException as e: return False, f"Erro de conex√£o com o backend: {e}"

def parse_contents(contents):
    _, content_string = contents.split(',')
    return base64.b64decode(content_string)

def convert_df_to_excel(df):
    output = BytesIO()
    with pd.ExcelWriter(output, engine='xlsxwriter') as writer: df.to_excel(writer, index=False, sheet_name='Previsoes')
    return base64.b64encode(output.getvalue()).decode('utf-8')

# =============================================================================
# COMPONENTES DE LAYOUT E STORES
# =============================================================================

store = dcc.Store(id='session-store', storage_type='session', data={'logged_in': False, 'token': None, 'username': None, 'last_results': None})
upload_data_store = dcc.Store(id='upload-data-store', storage_type='memory')
cluster_data_store = dcc.Store(id='cluster-data-store', storage_type='memory')

auth_layout = dbc.Container(dbc.Row(dbc.Col(dbc.Card(dbc.CardBody([
    html.H3("üéØ Bem-vindo ao Projeto Daruma", className="text-center mb-4"),
    dbc.Alert(id='auth-message', color='danger', is_open=False),
    dbc.RadioItems(id='auth-mode', options=[{'label': 'Login', 'value': 'login'}, {'label': 'Registrar', 'value': 'register'}], value='login', inline=True, className="mb-3 d-flex justify-content-center"),
    dbc.Input(id='username-input', placeholder='Usu√°rio', type='text', className="mb-3"),
    dbc.Input(id='password-input', placeholder='Senha', type='password', className="mb-3"),
    dbc.Button("Acessar", id='auth-button', color='primary', className="w-100")
])), width=4), justify="center", align="center", className="vh-100"), fluid=True)

main_dashboard_layout = dbc.Container([
    dbc.Row([
        dbc.Col(html.H2("üéØ Projeto Daruma: Dashboard de Previs√£o"), width='auto'),
        dbc.Col(html.Div(id='welcome-user-message'), className="text-center my-auto"),
        dbc.Col(dbc.Button("Logout", id='logout-button', color='danger'), width='auto', className="ms-auto")
    ], className="mb-4 align-items-center"),
    dbc.Tabs([
        dbc.Tab(label="üìä Nova Previs√£o", tab_id="predict-tab", children=[
            dcc.Upload(id='upload-data', children=html.Div(['Arraste e solte ou ', html.A('Selecione um Arquivo Excel (.xlsx)')]),
                style={'width': '100%', 'height': '60px', 'lineHeight': '60px', 'borderWidth': '1px', 'borderStyle': 'dashed', 'borderRadius': '5px', 'textAlign': 'center', 'margin': '20px 0'}, multiple=False),
            html.Div(id='upload-status', className="mb-3"),
            dbc.Button("Executar An√°lise Completa", id='predict-button', color='success', className="mb-4", disabled=True),
            dcc.Loading(type="default", children=[
                html.Div(id='prediction-results-output'),
                html.Div(id='shap-analysis-output', className="mt-4")
            ])
        ]),
        dbc.Tab(label="üìà Vis√£o Geral", tab_id="overview-tab", children=[dcc.Loading(html.Div(id='overview-output', className="mt-3"))]),
        dbc.Tab(label="üß¨ An√°lise de Perfis", tab_id="clustering-tab", children=[dcc.Loading(html.Div(id='clustering-output', className="mt-3"))]),
        dbc.Tab(label="üî¨ Performance do Modelo", tab_id="performance-tab", children=[html.Div(id='performance-output', className="mt-3")]),
        dbc.Tab(label="üß† An√°lise de Features", tab_id="analysis-tab", children=[dcc.Loading(html.Div(id='feature-importance-output'))]),
        dbc.Tab(label="‚è≥ Hist√≥rico", tab_id="history-tab", children=[dcc.Loading(html.Div(id='history-output'))]),
    ], id="tabs", active_tab="predict-tab"),
], fluid=True)

app.layout = html.Div([dcc.Location(id='url', refresh=False), store, upload_data_store, cluster_data_store, html.Div(id='page-content')])

# =============================================================================
# FUN√á√ïES DE RENDERIZA√á√ÉO DAS ABAS (sem altera√ß√µes)
# =============================================================================
def render_prediction_results(predictions_data):
    if not predictions_data: return dbc.Alert("Nenhuma previs√£o retornada.", color="warning")
    try:
        df_output = pd.DataFrame(predictions_data); excel_base64 = convert_df_to_excel(df_output)
        return html.Div([
            html.H4("Resultados da Previs√£o", className="mt-4"),
            dash_table.DataTable(id='predictions-table', columns=[{"name": i, "id": i} for i in df_output.columns], data=df_output.to_dict('records'),
                style_table={'overflowX': 'auto'}, sort_action="native", filter_action="native", page_action="native", page_current=0, page_size=10,
                style_header={'backgroundColor': 'rgb(230, 230, 230)', 'fontWeight': 'bold'}),
            html.A(dbc.Button("üì• Baixar Resultados (.xlsx)", color="info", className="mt-3"), id='download-link',
                   href=f"data:application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;base64,{excel_base64}", download="previsoes_daruma.xlsx")])
    except Exception as e: return dbc.Alert(f"Erro ao processar dados de previs√£o: {e}", color="danger")

def render_overview_results(predictions_data):
    if not predictions_data: return dbc.Alert("Dados de previs√£o n√£o dispon√≠veis.", color="warning")
    try:
        df = pd.DataFrame(predictions_data)
        kpis = dbc.Row([
            dbc.Col(dbc.Card([dbc.CardHeader("Total de Jogadores"), dbc.CardBody(html.H2(f"{len(df)}"))], color="primary", inverse=True)),
            dbc.Col(dbc.Card([dbc.CardHeader("M√©dia Target 1"), dbc.CardBody(html.H2(f"{df['Previs√£o T1'].mean():.2f}"))], color="success", inverse=True)),
            dbc.Col(dbc.Card([dbc.CardHeader("M√©dia Target 2"), dbc.CardBody(html.H2(f"{df['Previs√£o T2'].mean():.2f}"))], color="info", inverse=True)),
            dbc.Col(dbc.Card([dbc.CardHeader("M√©dia Target 3"), dbc.CardBody(html.H2(f"{df['Previs√£o T3'].mean():.2f}"))], color="secondary", inverse=True)),
        ])
        fig_hist = px.histogram(df.melt(id_vars=['C√≥digo de Acesso'], value_vars=['Previs√£o T1', 'Previs√£o T2', 'Previs√£o T3']),
                            x="value", color="variable", facet_col="variable", title="Distribui√ß√£o das Previs√µes por Target")
        fig_hist.update_xaxes(matches=None)
        fig_box = px.box(df[['Previs√£o T1', 'Previs√£o T2', 'Previs√£o T3']], title="Box Plot Comparativo dos Targets")
        corr = df[['Previs√£o T1', 'Previs√£o T2', 'Previs√£o T3']].corr()
        fig_heatmap = go.Figure(data=go.Heatmap(z=corr.values, x=corr.columns, y=corr.columns, colorscale='Viridis'))
        fig_heatmap.update_layout(title="Heatmap de Correla√ß√£o entre Targets Previstos")
        return html.Div([kpis, dcc.Graph(figure=fig_hist), dbc.Row([dbc.Col(dcc.Graph(figure=fig_box), md=6), dbc.Col(dcc.Graph(figure=fig_heatmap), md=6)])])
    except Exception as e: return dbc.Alert(f"Erro ao renderizar a vis√£o geral: {e}", color="danger")
    
def render_clustering_results(cluster_data):
    if not cluster_data: return dbc.Alert("Dados de clustering n√£o dispon√≠veis.", color="warning")
    try:
        df_pca = pd.DataFrame(cluster_data['pca_coords'], columns=['PC1', 'PC2'])
        df_pca['Cluster'] = [f"Cluster {c}" for c in cluster_data['clusters']]; df_pca['Jogador'] = cluster_data['jogadores']
        fig_pca = px.scatter(df_pca, x='PC1', y='PC2', color='Cluster', hover_name='Jogador', title="Visualiza√ß√£o dos Perfis de Jogadores (PCA + K-Means)")
        stats_cards = []
        for cluster_id, stats in cluster_data['stats'].items():
            percentage = stats.get('percentage', 0)
            stats_cards.append(dbc.Col(dbc.Card([
                dbc.CardHeader(f"üìä Cluster {cluster_id} ({percentage:.1f}% dos jogadores)"),
                dbc.CardBody([
                    html.P(f"‚Ä¢ Performance m√©dia (P_mean): {stats.get('P_mean', 0):.2f}"), html.P(f"‚Ä¢ M√©dia Target 1: {stats.get('Target1', 0):.2f}"),
                    html.P(f"‚Ä¢ M√©dia Target 2: {stats.get('Target2', 0):.2f}"), html.P(f"‚Ä¢ M√©dia Target 3: {stats.get('Target3', 0):.2f}"),
                ])
            ])))
        return html.Div([html.H3("An√°lise de Perfis (Clustering)"), dbc.Row(stats_cards, className="mb-4"), dcc.Graph(figure=fig_pca)])
    except Exception as e: return dbc.Alert(f"Erro ao renderizar os resultados do clustering: {e}", color="danger")

def render_performance_results():
    metrics = {'Target 1': {'R¬≤ LOO-CV': 0.5558, 'Overfitting': 11.0, 'Features': 33}, 'Target 2': {'R¬≤ LOO-CV': 0.4137, 'Overfitting': 14.2, 'Features': 13}, 'Target 3': {'R¬≤ LOO-CV': 0.4285, 'Overfitting': -1.0, 'Features': 16}}
    cards = [dbc.Col(dbc.Card([dbc.CardHeader(f"üéØ {target}"), dbc.CardBody([html.P(f"‚Ä¢ R¬≤ LOO-CV: {data['R¬≤ LOO-CV']:.4f} ‚≠ê"), html.P(f"‚Ä¢ Overfitting: {data['Overfitting']:.1f}%"), html.P(f"‚Ä¢ Features: {data['Features']}")])], color="light")) for target, data in metrics.items()]
    df_perf = pd.DataFrame(metrics).T.reset_index().rename(columns={'index': 'Target'})
    fig_r2 = px.bar(df_perf, x='R¬≤ LOO-CV', y='Target', orientation='h', title="Comparativo de Performance (R¬≤)")
    return html.Div([html.H3("Performance dos Modelos em Valida√ß√£o Cruzada"), dbc.Row(cards, className="mb-4"), dcc.Graph(figure=fig_r2)])

def get_history_layout(headers):
    try:
        response = requests.get(f"{BACKEND_URL}/history", headers=headers)
        if response.status_code == 200:
            history_data = response.json()
            if not history_data: return dbc.Alert("Nenhum hist√≥rico encontrado.", color="info")
            df_history = pd.DataFrame(history_data)
            return dash_table.DataTable(columns=[{'name': 'Data do Upload', 'id': 'timestamp'}, {'name': 'N¬∫ de Jogadores', 'id': 'num_jogadores'}], data=df_history.to_dict('records'), sort_action="native")
        return dbc.Alert(f"Erro ao buscar hist√≥rico: {response.json().get('detail')}", color="danger")
    except requests.exceptions.RequestException as e: return dbc.Alert(f"Erro de conex√£o: {e}", color="danger")

def get_feature_importance_layout(headers):
    try:
        response = requests.get(f"{BACKEND_URL}/feature_importance", headers=headers)
        if response.status_code == 200:
            importances = response.json(); graphs = []
            for target, features in importances.items():
                if not features: continue
                df_importance = pd.DataFrame(features)
                fig = px.bar(df_importance, x='importance', y='feature', orientation='h', title=f"Import√¢ncia para o {target}")
                fig.update_layout(yaxis={'categoryorder':'total ascending'}); graphs.append(dcc.Graph(figure=fig))
            return html.Div(graphs) if graphs else dbc.Alert("Nenhuma informa√ß√£o dispon√≠vel.", color="info")
        return dbc.Alert(f"Erro ao buscar dados: {response.json().get('detail')}", color="danger")
    except requests.exceptions.RequestException as e: return dbc.Alert(f"Erro de conex√£o com o backend: {e}", color="danger")

# =============================================================================
# CALLBACKS DE CONTROLE E AUTENTICA√á√ÉO
# =============================================================================
@app.callback(Output('page-content', 'children'), [Input('session-store', 'data')])
def render_page_content(data): return main_dashboard_layout if data and data.get('logged_in') else auth_layout

@app.callback(
    [Output('url', 'pathname', allow_duplicate=True), Output('session-store', 'data'), Output('auth-message', 'children'), Output('auth-message', 'is_open')],
    Input('auth-button', 'n_clicks'),
    [State('auth-mode', 'value'), State('username-input', 'value'), State('password-input', 'value'), State('session-store', 'data')], prevent_initial_call=True)
def handle_auth(n_clicks, mode, user, pwd, data):
    if not user or not pwd: return dash.no_update, dash.no_update, "Usu√°rio e senha s√£o obrigat√≥rios.", True
    if mode == 'login':
        token, error = login_api(user, pwd)
        if token: data.update({'logged_in': True, 'token': token, 'username': user}); return '/', data, "", False
        return dash.no_update, dash.no_update, error, True
    elif mode == 'register':
        success, message = register_api(user, pwd)
        return dash.no_update, dash.no_update, message, True
    return dash.no_update, dash.no_update, "", False

@app.callback(Output('welcome-user-message', 'children'), Input('session-store', 'data'))
def update_welcome_message(data): return f"Bem-vindo(a), {data.get('username')}!" if data and data.get('logged_in') else ""

@app.callback(
    [Output('url', 'pathname', allow_duplicate=True), Output('session-store', 'data', allow_duplicate=True)],
    Input('logout-button', 'n_clicks'), [State('session-store', 'data')], prevent_initial_call=True)
def handle_logout(n_clicks, data):
    if n_clicks: data.update({'logged_in': False, 'token': None, 'username': None, 'last_results': None}); return '/', data
    return dash.no_update, dash.no_update

@app.callback(
    [Output('upload-data-store', 'data'), Output('upload-status', 'children'), Output('predict-button', 'disabled')],
    Input('upload-data', 'contents'), State('upload-data', 'filename'), prevent_initial_call=True)
def handle_upload(contents, filename):
    if contents:
        decoded = parse_contents(contents); stored_data = {'filename': filename, 'contents': base64.b64encode(decoded).decode('utf-8')}
        return stored_data, html.Div(['Arquivo selecionado: ', html.B(filename)]), False
    return None, "", True

# =============================================================================
# ############### IN√çCIO DA REFATORA√á√ÉO DOS CALLBACKS ###############
# =============================================================================

# CALLBACK 1: Bot√£o "Executar" -> Chama as APIs e armazena os resultados
@app.callback(
    [Output('session-store', 'data', allow_duplicate=True), Output('cluster-data-store', 'data'),
     Output('upload-status', 'children', allow_duplicate=True), Output('tabs', 'active_tab')],
    Input('predict-button', 'n_clicks'),
    [State('session-store', 'data'), State('upload-data-store', 'data')], prevent_initial_call=True)
def run_api_calls(n_clicks, session_data, upload_data):
    if not n_clicks or not upload_data or not session_data: raise PreventUpdate
    if not session_data.get('token'):
        return dash.no_update, dash.no_update, dbc.Alert("Token n√£o encontrado. Fa√ßa login.", color="danger"), "predict-tab"

    headers = {'Authorization': f'Bearer {session_data["token"]}'}
    files = {'file': (upload_data['filename'], base64.b64decode(upload_data['contents']), 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')}
    
    try: # API de Previs√£o
        response_pred = requests.post(f"{BACKEND_URL}/predict", headers=headers, files=files)
        if response_pred.status_code != 200:
            msg = f"Erro na API de Previs√£o: {response_pred.json().get('detail')}"
            return dash.no_update, dash.no_update, dbc.Alert(msg, color="danger"), "predict-tab"
        session_data['last_results'] = response_pred.json()
    except requests.exceptions.RequestException as e:
        return dash.no_update, dash.no_update, dbc.Alert(f"Erro de conex√£o: {e}", color="danger"), "predict-tab"
    
    cluster_data = None # API de Clustering
    try:
        files_cluster = {'file': (upload_data['filename'], base64.b64decode(upload_data['contents']), 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')}
        response_cluster = requests.post(f"{BACKEND_URL}/clustering", headers=headers, files=files_cluster)
        if response_cluster.status_code == 200: cluster_data = response_cluster.json()
        else: print(f"Aviso de Clustering: {response_cluster.json().get('detail')}")
    except requests.exceptions.RequestException as e: print(f"Aviso de Clustering: {e}")

    return session_data, cluster_data, "", 'overview-tab'

# CALLBACK 2: Atualiza a Aba de Previs√£o Individual e SHAP quando os dados de previs√£o mudam
@app.callback(
    [Output('prediction-results-output', 'children'), Output('shap-analysis-output', 'children')],
    Input('session-store', 'data'))
def update_prediction_tab(session_data):
    if not session_data or 'last_results' not in session_data or not session_data['last_results']: return "", ""
    predictions = session_data['last_results'].get('predictions', [])
    shap_data = session_data['last_results'].get('shap_data')
    prediction_layout = render_prediction_results(predictions)
    
    shap_layout = None
    if shap_data:
        jogadores = list(shap_data.keys())
        shap_layout = html.Div([
            html.H4("An√°lise de Contribui√ß√£o (SHAP)", className="mt-5"),
            html.P("Selecione um jogador para ver a contribui√ß√£o de cada feature."),
            dbc.Row([dbc.Col(dcc.Dropdown(id='shap-player-dropdown', options=[{'label': j, 'value': j} for j in jogadores], value=jogadores[0], clearable=False), width=12, md=6, lg=4)], className="mb-4"),
            dcc.Loading(html.Div(id='shap-graphs-container'))])
            
    return prediction_layout, shap_layout

# CALLBACK 3: Atualiza a Aba de Vis√£o Geral quando os dados de previs√£o mudam
@app.callback(Output('overview-output', 'children'), Input('session-store', 'data'))
def update_overview_tab(session_data):
    if not session_data or 'last_results' not in session_data or not session_data['last_results']: return ""
    return render_overview_results(session_data['last_results'].get('predictions', []))

# CALLBACK 4: Atualiza a Aba de Clustering quando os dados de cluster mudam
@app.callback(Output('clustering-output', 'children'), Input('cluster-data-store', 'data'))
def update_clustering_tab(cluster_data):
    if not cluster_data: return dbc.Alert("Execute uma nova an√°lise para ver os perfis.", color="info")
    return render_clustering_results(cluster_data)

# CALLBACK 5: Popula as abas "est√°ticas" ou "pregui√ßosas" quando s√£o selecionadas
@app.callback(
    [Output('history-output', 'children'), Output('feature-importance-output', 'children'), Output('performance-output', 'children')],
    Input('tabs', 'active_tab'), State('session-store', 'data'))
def update_lazy_tabs(active_tab, session_data):
    if not session_data.get('token'): raise PreventUpdate
    headers = {'Authorization': f'Bearer {session_data["token"]}'}
    
    if active_tab == 'history-tab': return get_history_layout(headers), dash.no_update, dash.no_update
    if active_tab == 'analysis-tab': return dash.no_update, get_feature_importance_layout(headers), dash.no_update
    if active_tab == 'performance-tab': return dash.no_update, dash.no_update, render_performance_results()
    
    raise PreventUpdate

# =============================================================================
# CALLBACKS DE INTERATIVIDADE (SHAP)
# =============================================================================
@app.callback(
    Output('shap-graphs-container', 'children'),
    Input('shap-player-dropdown', 'value'), State('session-store', 'data'), prevent_initial_call=True)
def update_shap_graphs(selected_player, session_data):
    if not selected_player or not session_data or not session_data.get('last_results'): return None
    all_preds = session_data['last_results'].get('predictions', [])
    shap_data = session_data['last_results'].get('shap_data', {})
    player_preds = next((p for p in all_preds if str(p['C√≥digo de Acesso']) == str(selected_player)), None)
    player_shap = shap_data.get(str(selected_player))
    if not player_shap or not player_preds: return dbc.Alert("Dados SHAP n√£o encontrados.", color="warning")

    kpis = dbc.Row([
        dbc.Col(dbc.Card([dbc.CardHeader("Previs√£o T1"), dbc.CardBody(html.H4(f"{player_preds.get('Previs√£o T1', 'N/A')}"))], color="primary", inverse=True)),
        dbc.Col(dbc.Card([dbc.CardHeader("Previs√£o T2"), dbc.CardBody(html.H4(f"{player_preds.get('Previs√£o T2', 'N/A')}"))], color="success", inverse=True)),
        dbc.Col(dbc.Card([dbc.CardHeader("Previs√£o T3"), dbc.CardBody(html.H4(f"{player_preds.get('Previs√£o T3', 'N/A')}"))], color="info", inverse=True))
    ], className="mb-4")
    graphs = []
    for target_key, data in player_shap.items():
        df_shap = pd.DataFrame({'feature': data['feature_names'], 'shap_value': data['shap_values']}).sort_values(by='shap_value', key=abs, ascending=False).head(15)
        fig = px.bar(df_shap, x='shap_value', y='feature', orientation='h', title=f"Contribui√ß√µes (SHAP) para {target_key}", labels={'shap_value': 'Impacto', 'feature': 'Feature'})
        fig.update_layout(yaxis={'categoryorder': 'total ascending'}); graphs.append(dcc.Graph(figure=fig))
    return html.Div([kpis] + graphs)

# =============================================================================
# EXECU√á√ÉO DO SERVIDOR
# =============================================================================
if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=8050)
</file>

</files>
