This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.repomixignore
dashboard/backend/auth.py
dashboard/backend/core.py
dashboard/backend/crud.py
dashboard/backend/database.py
dashboard/backend/Dockerfile
dashboard/backend/export_artifacts_target1.py
dashboard/backend/export_artifacts_target2.py
dashboard/backend/export_artifacts_target3.py
dashboard/backend/export_hibrido_target1.py
dashboard/backend/export_hibrido_target2.py
dashboard/backend/export_hibrido_target3.py
dashboard/backend/main.py
dashboard/backend/models.py
dashboard/backend/README.md
dashboard/backend/requirements.txt
dashboard/backend/schemas.py
dashboard/docker-compose.yml
dashboard/frontend/dashboard_dash.py
dashboard/frontend/Dockerfile
dashboard/frontend/README.md
dashboard/frontend/requirements.txt
dashboard/README.md
notebooks/PROJETOFINAL.ipynb
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".repomixignore">
# Arquivos de configuração de ambiente e exemplos
dashboard/.env.example
.env

# Arquivos gerados pelo Git e editores
.gitignore

# Dados de treinamento e artefatos de ML (gerados pelos scripts)
# É melhor ignorá-los se a lógica principal está nos scripts de exportação
# e no notebook. O repomix já ignora binários como .pkl por padrão.
dashboard/backend/ml_artifacts/
*.pkl
*.joblib

# Dados brutos e intermediários (se existirem)
notebooks/JogadoresV1.xlsx
Dados_Otimizados_V4.xlsx
Dados_para_modelo.xlsx

# Arquivos de cache e logs do treinamento do CatBoost
dashboard/backend/catboost_info/

# Arquivos de cache do Python
__pycache__/
*.pyc

# Pontos de verificação de notebooks
.ipynb_checkpoints/
</file>

<file path="dashboard/backend/auth.py">
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from datetime import datetime, timedelta
import os
from core import bcrypt # <--- IMPORTAÇÃO CHAVE

SECRET_KEY = os.getenv('JWT_SECRET_KEY', 'default_secret_key')
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="login")

def verify_password(plain_password, hashed_password):
    """Verifica a senha usando bcrypt."""
    # A biblioteca Flask-Bcrypt espera que o hash seja um bytes-like object
    return bcrypt.check_password_hash(hashed_password.encode('utf-8'), plain_password)

def get_password_hash(password):
    """Gera o hash da senha usando bcrypt."""
    return bcrypt.generate_password_hash(password).decode('utf-8')

def create_access_token(data: dict):
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

async def get_current_user_id(token: str = Depends(oauth2_scheme)):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        user_id: str = payload.get("sub")
        if user_id is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception
    return user_id
</file>

<file path="dashboard/backend/core.py">
from fastapi import FastAPI
from flask_bcrypt import Bcrypt

app = FastAPI(title="API do Projeto Daruma")

# Instancia o Bcrypt diretamente, sem associar a um app Flask.
bcrypt = Bcrypt()
</file>

<file path="dashboard/backend/crud.py">
# crud.py
from sqlalchemy.orm import Session
import models
import auth

def get_user_by_username(db: Session, username: str):
    return db.query(models.User).filter(models.User.username == username).first()

def create_user(db: Session, user_schema: models.User):
    hashed_password = auth.get_password_hash(user_schema.password)
    db_user = models.User(username=user_schema.username, password_hash=hashed_password)
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user
</file>

<file path="dashboard/backend/database.py">
# database.py
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
import os

SQLALCHEMY_DATABASE_URL = os.getenv('DATABASE_URL', 'postgresql://user:password@db:5432/daruma_db')

engine = create_engine(SQLALCHEMY_DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

# Dependency para obter a sessão do DB
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
</file>

<file path="dashboard/backend/export_artifacts_target1.py">
# export_artifacts_target1.py

import pandas as pd
import numpy as np
import os
import pickle
import joblib
import optuna
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import RobustScaler
from sklearn.feature_selection import VarianceThreshold
from sklearn.metrics import r2_score
from catboost import CatBoostRegressor

print("="*80)
print("INICIANDO EXPORTAÇÃO DE ARTEFATOS PARA O TARGET 1")
print("="*80)

# --- 1. CONFIGURAÇÕES ---
ARTIFACTS_PATH = "ml_artifacts"
if not os.path.exists(ARTIFACTS_PATH):
    os.makedirs(ARTIFACTS_PATH)
TARGET = 'Target1'
RAW_DATA_FILE = 'JogadoresV1.xlsx'
RANDOM_STATE = 42

# --- 2. CARREGAMENTO E FEATURE ENGINEERING (Lógica do Notebook Fase 2) ---
print(f"\n[FASE 1] Carregando e processando dados de '{RAW_DATA_FILE}'...")
try:
    df = pd.read_excel(RAW_DATA_FILE)
except FileNotFoundError:
    print(f"❌ ERRO: Arquivo '{RAW_DATA_FILE}' não encontrado.")
    exit()

df.dropna(subset=[TARGET], inplace=True)

# Limpeza e conversão de tipos
if 'F0103' in df.columns:
    df['F0103'] = pd.to_numeric(df['F0103'].astype(str).str.replace(',', '.'), errors='coerce')

p_cols = [c for c in df.columns if c.startswith('P') and any(char.isdigit() for char in c)]
t_cols = [c for c in df.columns if c.startswith('T') and any(char.isdigit() for char in c)]
f_cols = [c for c in df.columns if c.startswith('F') and len(c) > 1 and any(char.isdigit() for char in c)]

for col in p_cols + t_cols + f_cols:
    df[col] = pd.to_numeric(df[col], errors='coerce')
    df[col].replace(-1, np.nan, inplace=True)

# Imputação com mediana
for col in p_cols + t_cols + f_cols:
    if df[col].isnull().sum() > 0:
        df[col].fillna(df[col].median(), inplace=True)

# Feature Engineering
if 'QtdHorasDormi' in df.columns and 'Acordar' in df.columns:
    df['sono_total'] = df['QtdHorasDormi']
    df['sono_x_acordar'] = df['QtdHorasDormi'] * df['Acordar']

if p_cols:
    df['P_mean'] = df[p_cols].mean(axis=1)
    df['P_std'] = df[p_cols].std(axis=1)

if t_cols:
    df['T_mean'] = df[t_cols].mean(axis=1)

# Agregações conceituais de F
f_sono = [c for c in f_cols if c.startswith('F07')]
if f_sono:
    df['F_sono_mean'] = df[f_sono].mean(axis=1)

print("✅ Dados processados e features criadas.")

# --- 3. SELEÇÃO DE FEATURES ---
print("\n[FASE 2] Selecionando as melhores features...")
numeric_features = df.select_dtypes(include=np.number).columns.tolist()
features_to_exclude = ['Target1', 'Target2', 'Target3']
feature_candidates = [f for f in numeric_features if f not in features_to_exclude]

X_temp = df[feature_candidates].fillna(0)
selector = VarianceThreshold(threshold=0.01)
selector.fit(X_temp)
feature_cols_var = X_temp.columns[selector.get_support()].tolist()

correlations = [(col, abs(df[col].corr(df[TARGET]))) for col in feature_cols_var]
correlations = [corr for corr in correlations if not np.isnan(corr[1])]
correlations.sort(key=lambda x: x[1], reverse=True)

TOP_K = 30
selected_features = [col for col, _ in correlations[:TOP_K]]

# Interações
top3_features = selected_features[:3]
for i, f1 in enumerate(top3_features):
    for f2 in top3_features[i+1:]:
        interaction_name = f'{f1}_X_{f2}'
        df[interaction_name] = df[f1] * df[f2]
        selected_features.append(interaction_name)

selected_features = list(dict.fromkeys(selected_features))
print(f"✅ {len(selected_features)} features finais selecionadas para {TARGET}.")

# --- 4. PREPARAÇÃO FINAL E SALVAMENTO DE ARTEFATOS ---
X = df[selected_features]
y = df[TARGET]

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=RANDOM_STATE)

# Scaler
scaler = RobustScaler()
X_train_scaled = scaler.fit_transform(X_train)
joblib.dump(scaler, f'{ARTIFACTS_PATH}/scaler_{TARGET.lower()}.pkl')
print(f"💾 Scaler para {TARGET} salvo em: {ARTIFACTS_PATH}/scaler_{TARGET.lower()}.pkl")

# Lista de Features
with open(f'{ARTIFACTS_PATH}/features_{TARGET.lower()}.pkl', 'wb') as f:
    pickle.dump(selected_features, f)
print(f"💾 Lista de features para {TARGET} salva em: {ARTIFACTS_PATH}/features_{TARGET.lower()}.pkl")

# --- 5. OTIMIZAÇÃO E TREINAMENTO DO MODELO (Lógica do Notebook Fase 3) ---
print(f"\n[FASE 3] Otimizando e treinando o modelo para {TARGET}...")

def objective_t1(trial):
    params = {
        'iterations': 500,
        'learning_rate': trial.suggest_float('learning_rate', 0.01, 0.1, log=True),
        'depth': trial.suggest_int('depth', 3, 6),
        'l2_leaf_reg': trial.suggest_float('l2_leaf_reg', 10, 100, log=True),
        'verbose': False,
        'random_seed': RANDOM_STATE
    }
    model = CatBoostRegressor(**params)
    model.fit(X_train_scaled, y_train, eval_set=[(scaler.transform(X_test), y_test)], early_stopping_rounds=50, verbose=False)
    preds = model.predict(scaler.transform(X_test))
    return r2_score(y_test, preds)

study = optuna.create_study(direction='maximize')
study.optimize(objective_t1, n_trials=50) # 50 trials for a good balance
best_params = study.best_params
best_params['iterations'] = 500 # Re-set iterations
best_params['verbose'] = False
best_params['random_seed'] = RANDOM_STATE

final_model = CatBoostRegressor(**best_params)
final_model.fit(X_train_scaled, y_train)

print(f"✅ Modelo {TARGET} treinado com R² de {study.best_value:.4f} na otimização.")

# Salvamento do Modelo
joblib.dump(final_model, f'{ARTIFACTS_PATH}/modelo_{TARGET.lower()}.pkl')
print(f"💾 Modelo para {TARGET} salvo em: {ARTIFACTS_PATH}/modelo_{TARGET.lower()}.pkl")
print("\n--- Concluído para Target 1 ---")
</file>

<file path="dashboard/backend/export_artifacts_target2.py">
# export_artifacts_target2.py

import pandas as pd
import numpy as np
import os
import pickle
import joblib
import optuna
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.preprocessing import RobustScaler, PolynomialFeatures
from sklearn.ensemble import RandomForestRegressor, StackingRegressor
from sklearn.linear_model import Ridge
from catboost import CatBoostRegressor
import lightgbm as lgb
import xgboost as xgb

print("="*80)
print("INICIANDO EXPORTAÇÃO DE ARTEFATOS PARA O TARGET 2")
print("="*80)

# --- 1. CONFIGURAÇÕES ---
ARTIFACTS_PATH = "ml_artifacts"
if not os.path.exists(ARTIFACTS_PATH):
    os.makedirs(ARTIFACTS_PATH)
TARGET = 'Target2'
RAW_DATA_FILE = 'JogadoresV1.xlsx'
RANDOM_STATE = 42

# --- 2. CARREGAMENTO E FEATURE ENGINEERING ---
print(f"\n[FASE 1] Carregando e processando dados de '{RAW_DATA_FILE}'...")
try:
    df = pd.read_excel(RAW_DATA_FILE)
except FileNotFoundError:
    print(f"❌ ERRO: Arquivo '{RAW_DATA_FILE}' não encontrado.")
    exit()

df.dropna(subset=[TARGET], inplace=True)

# Limpeza e FE simples
if 'F0103' in df.columns:
    df['F0103'] = pd.to_numeric(df['F0103'].astype(str).str.replace(',', '.'), errors='coerce')
if 'QtdHorasDormi' in df.columns and 'Acordar' in df.columns:
    df['sono_total'] = df['QtdHorasDormi']
    df['sono_x_acordar'] = df['QtdHorasDormi'] * df['Acordar']

p_cols = [c for c in df.columns if c.startswith('P') and any(char.isdigit() for char in c)]
t_cols = [c for c in df.columns if c.startswith('T') and any(char.isdigit() for char in c)]
f_cols = [c for c in df.columns if c.startswith('F') and len(c) > 1 and any(char.isdigit() for char in c)]

for col in p_cols + t_cols + f_cols:
    df[col] = pd.to_numeric(df[col], errors='coerce')

if p_cols:
    df['P_mean'] = df[p_cols].mean(axis=1)
if t_cols:
    df['T_mean'] = df[t_cols].mean(axis=1)
if f_cols:
    df['F_mean'] = df[f_cols].mean(axis=1)

# Imputação final antes de separar
numeric_cols = df.select_dtypes(include=np.number).columns
for col in numeric_cols:
    df[col].fillna(df[col].median(), inplace=True)

print("✅ Dados processados e features base criadas.")

# --- 3. PREPARAÇÃO E SEPARAÇÃO DE DADOS ---
features_to_exclude = ['Target1', 'Target2', 'Target3', 'Código de Acesso', 'Data/Hora Último']
initial_features = [col for col in df.columns if col not in features_to_exclude and pd.api.types.is_numeric_dtype(df[col])]

X = df[initial_features]
y = df[TARGET]

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=RANDOM_STATE)

# --- 4. FEATURE ENGINEERING AVANÇADA E SELEÇÃO ---
print("\n[FASE 2] Criando features polinomiais e selecionando as melhores...")
# Features Polinomiais
rf_poly_selector = RandomForestRegressor(n_estimators=100, random_state=RANDOM_STATE, n_jobs=-1)
rf_poly_selector.fit(X_train, y_train)
importances = pd.Series(rf_poly_selector.feature_importances_, index=X_train.columns).sort_values(ascending=False)
top_features_for_poly = importances.head(15).index.tolist()

poly = PolynomialFeatures(degree=2, include_bias=False, interaction_only=True)
X_train_poly = poly.fit_transform(X_train[top_features_for_poly])
poly_names = [f"poly_{name}" for name in poly.get_feature_names_out(top_features_for_poly)]
X_train_poly_df = pd.DataFrame(X_train_poly, columns=poly_names, index=X_train.index)
X_train_expanded = X_train.join(X_train_poly_df)

# Seleção Híbrida
correlations = X_train_expanded.corrwith(y_train).abs().sort_values(ascending=False)
top_corr_features = correlations.head(60).index.tolist()
rf_final_selector = RandomForestRegressor(n_estimators=100, random_state=RANDOM_STATE, n_jobs=-1)
rf_final_selector.fit(X_train_expanded, y_train)
importances_final = pd.Series(rf_final_selector.feature_importances_, index=X_train_expanded.columns).sort_values(ascending=False)
top_rf_features = importances_final.head(60).index.tolist()

final_feature_list = list(set(top_corr_features + top_rf_features))
X_train_selected = X_train_expanded[final_feature_list]

print(f"✅ {len(final_feature_list)} features finais selecionadas para {TARGET}.")

# --- 5. SALVAMENTO DE ARTEFATOS DE PRÉ-PROCESSAMENTO ---
# Scaler
scaler = RobustScaler()
scaler.fit(X_train_selected)
joblib.dump(scaler, f'{ARTIFACTS_PATH}/scaler_{TARGET.lower()}.pkl')
print(f"💾 Scaler para {TARGET} salvo.")

# Transformador Polinomial e sua lista de features
joblib.dump(poly, f'{ARTIFACTS_PATH}/poly_transformer_{TARGET.lower()}.pkl')
with open(f'{ARTIFACTS_PATH}/poly_features_list_{TARGET.lower()}.pkl', 'wb') as f:
    pickle.dump(top_features_for_poly, f)
print(f"💾 Transformador polinomial e lista de features para {TARGET} salvos.")

# Lista final de Features
with open(f'{ARTIFACTS_PATH}/features_{TARGET.lower()}.pkl', 'wb') as f:
    pickle.dump(final_feature_list, f)
print(f"💾 Lista final de features para {TARGET} salva.")


# --- 6. OTIMIZAÇÃO E TREINAMENTO DO MODELO STACKING ---
print(f"\n[FASE 3] Otimizando modelos base e treinando o Stacking para {TARGET}...")

def tune_model(model_name, X, y):
    def objective(trial):
        if model_name == 'catboost':
            params = {'iterations': trial.suggest_int('iterations', 100, 500), 'depth': trial.suggest_int('depth', 3, 7), 'learning_rate': trial.suggest_float('learning_rate', 0.01, 0.3, log=True), 'l2_leaf_reg': trial.suggest_float('l2_leaf_reg', 2, 20, log=True), 'verbose': 0}
            model = CatBoostRegressor(**params, random_state=RANDOM_STATE)
        # Adicione lgb e xgb se necessário
        score = cross_val_score(model, X, y, cv=3, scoring='r2', n_jobs=-1).mean()
        return score
    
    study = optuna.create_study(direction='maximize')
    study.optimize(objective, n_trials=30)
    print(f"  - Melhor R² CV para {model_name}: {study.best_value:.4f}")
    return study.best_params

best_catboost_params = tune_model('catboost', scaler.transform(X_train_selected), y_train)

base_models = [
    ('catboost', CatBoostRegressor(**best_catboost_params, verbose=0, random_state=RANDOM_STATE)),
    ('random_forest', RandomForestRegressor(n_estimators=150, random_state=RANDOM_STATE))
]
meta_model = Ridge(random_state=RANDOM_STATE)
stacking_model = StackingRegressor(estimators=base_models, final_estimator=meta_model, cv=5, n_jobs=-1)

stacking_model.fit(scaler.transform(X_train_selected), y_train)
print(f"✅ Modelo Stacking para {TARGET} treinado.")

# Salvamento do Modelo
joblib.dump(stacking_model, f'{ARTIFACTS_PATH}/modelo_{TARGET.lower()}.pkl')
print(f"💾 Modelo para {TARGET} salvo em: {ARTIFACTS_PATH}/modelo_{TARGET.lower()}.pkl")
print("\n--- Concluído para Target 2 ---")
</file>

<file path="dashboard/backend/export_artifacts_target3.py">
# export_artifacts_target3.py

import pandas as pd
import numpy as np
import os
import pickle
import joblib
import optuna
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.preprocessing import RobustScaler, PolynomialFeatures
from sklearn.ensemble import RandomForestRegressor, StackingRegressor
from sklearn.linear_model import Ridge
from catboost import CatBoostRegressor
import lightgbm as lgb
import xgboost as xgb

print("="*80)
print("INICIANDO EXPORTAÇÃO DE ARTEFATOS PARA O TARGET 3")
print("="*80)

# --- 1. CONFIGURAÇÕES ---
ARTIFACTS_PATH = "ml_artifacts"
if not os.path.exists(ARTIFACTS_PATH):
    os.makedirs(ARTIFACTS_PATH)
TARGET = 'Target3' # <- ALTERADO
RAW_DATA_FILE = 'JogadoresV1.xlsx'
RANDOM_STATE = 42

# --- 2. CARREGAMENTO E FEATURE ENGINEERING ---
print(f"\n[FASE 1] Carregando e processando dados de '{RAW_DATA_FILE}'...")
try:
    df = pd.read_excel(RAW_DATA_FILE)
except FileNotFoundError:
    print(f"❌ ERRO: Arquivo '{RAW_DATA_FILE}' não encontrado.")
    exit()

df.dropna(subset=[TARGET], inplace=True)

# Limpeza e FE simples
if 'F0103' in df.columns:
    df['F0103'] = pd.to_numeric(df['F0103'].astype(str).str.replace(',', '.'), errors='coerce')
if 'QtdHorasDormi' in df.columns and 'Acordar' in df.columns:
    df['sono_total'] = df['QtdHorasDormi']
    df['sono_x_acordar'] = df['QtdHorasDormi'] * df['Acordar']

p_cols = [c for c in df.columns if c.startswith('P') and any(char.isdigit() for char in c)]
t_cols = [c for c in df.columns if c.startswith('T') and any(char.isdigit() for char in c)]
f_cols = [c for c in df.columns if c.startswith('F') and len(c) > 1 and any(char.isdigit() for char in c)]

for col in p_cols + t_cols + f_cols:
    df[col] = pd.to_numeric(df[col], errors='coerce')

if p_cols:
    df['P_mean'] = df[p_cols].mean(axis=1)
if t_cols:
    df['T_mean'] = df[t_cols].mean(axis=1)
if f_cols:
    df['F_mean'] = df[f_cols].mean(axis=1)

# Imputação final antes de separar
numeric_cols = df.select_dtypes(include=np.number).columns
for col in numeric_cols:
    df[col].fillna(df[col].median(), inplace=True)

print("✅ Dados processados e features base criadas.")

# --- 3. PREPARAÇÃO E SEPARAÇÃO DE DADOS ---
features_to_exclude = ['Target1', 'Target2', 'Target3', 'Código de Acesso', 'Data/Hora Último']
initial_features = [col for col in df.columns if col not in features_to_exclude and pd.api.types.is_numeric_dtype(df[col])]

X = df[initial_features]
y = df[TARGET]

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=RANDOM_STATE)

# --- 4. FEATURE ENGINEERING AVANÇADA E SELEÇÃO ---
print("\n[FASE 2] Criando features polinomiais e selecionando as melhores...")
# Features Polinomiais
rf_poly_selector = RandomForestRegressor(n_estimators=100, random_state=RANDOM_STATE, n_jobs=-1)
rf_poly_selector.fit(X_train, y_train)
importances = pd.Series(rf_poly_selector.feature_importances_, index=X_train.columns).sort_values(ascending=False)
top_features_for_poly = importances.head(15).index.tolist()

poly = PolynomialFeatures(degree=2, include_bias=False, interaction_only=True)
X_train_poly = poly.fit_transform(X_train[top_features_for_poly])
poly_names = [f"poly_{name}" for name in poly.get_feature_names_out(top_features_for_poly)]
X_train_poly_df = pd.DataFrame(X_train_poly, columns=poly_names, index=X_train.index)
X_train_expanded = X_train.join(X_train_poly_df)

# Seleção Híbrida
correlations = X_train_expanded.corrwith(y_train).abs().sort_values(ascending=False)
top_corr_features = correlations.head(60).index.tolist()
rf_final_selector = RandomForestRegressor(n_estimators=100, random_state=RANDOM_STATE, n_jobs=-1)
rf_final_selector.fit(X_train_expanded, y_train)
importances_final = pd.Series(rf_final_selector.feature_importances_, index=X_train_expanded.columns).sort_values(ascending=False)
top_rf_features = importances_final.head(60).index.tolist()

final_feature_list = list(set(top_corr_features + top_rf_features))
X_train_selected = X_train_expanded[final_feature_list]

print(f"✅ {len(final_feature_list)} features finais selecionadas para {TARGET}.")

# --- 5. SALVAMENTO DE ARTEFATOS DE PRÉ-PROCESSAMENTO ---
# Scaler
scaler = RobustScaler()
scaler.fit(X_train_selected)
joblib.dump(scaler, f'{ARTIFACTS_PATH}/scaler_{TARGET.lower()}.pkl') # <- NOME ALTERADO
print(f"💾 Scaler para {TARGET} salvo.")

# Transformador Polinomial e sua lista de features
joblib.dump(poly, f'{ARTIFACTS_PATH}/poly_transformer_{TARGET.lower()}.pkl') # <- NOME ALTERADO
with open(f'{ARTIFACTS_PATH}/poly_features_list_{TARGET.lower()}.pkl', 'wb') as f: # <- NOME ALTERADO
    pickle.dump(top_features_for_poly, f)
print(f"💾 Transformador polinomial e lista de features para {TARGET} salvos.")

# Lista final de Features
with open(f'{ARTIFACTS_PATH}/features_{TARGET.lower()}.pkl', 'wb') as f: # <- NOME ALTERADO
    pickle.dump(final_feature_list, f)
print(f"💾 Lista final de features para {TARGET} salva.")


# --- 6. OTIMIZAÇÃO E TREINAMENTO DO MODELO STACKING ---
print(f"\n[FASE 3] Otimizando modelos base e treinando o Stacking para {TARGET}...")

def tune_model(model_name, X, y):
    def objective(trial):
        if model_name == 'catboost':
            params = {'iterations': trial.suggest_int('iterations', 100, 500), 'depth': trial.suggest_int('depth', 3, 7), 'learning_rate': trial.suggest_float('learning_rate', 0.01, 0.3, log=True), 'l2_leaf_reg': trial.suggest_float('l2_leaf_reg', 2, 20, log=True), 'verbose': 0}
            model = CatBoostRegressor(**params, random_state=RANDOM_STATE)
        score = cross_val_score(model, X, y, cv=3, scoring='r2', n_jobs=-1).mean()
        return score
    
    study = optuna.create_study(direction='maximize')
    study.optimize(objective, n_trials=30)
    print(f"  - Melhor R² CV para {model_name}: {study.best_value:.4f}")
    return study.best_params

best_catboost_params = tune_model('catboost', scaler.transform(X_train_selected), y_train)

base_models = [
    ('catboost', CatBoostRegressor(**best_catboost_params, verbose=0, random_state=RANDOM_STATE)),
    ('random_forest', RandomForestRegressor(n_estimators=150, random_state=RANDOM_STATE))
]
meta_model = Ridge(random_state=RANDOM_STATE)
stacking_model = StackingRegressor(estimators=base_models, final_estimator=meta_model, cv=5, n_jobs=-1)

stacking_model.fit(scaler.transform(X_train_selected), y_train)
print(f"✅ Modelo Stacking para {TARGET} treinado.")

# Salvamento do Modelo
joblib.dump(stacking_model, f'{ARTIFACTS_PATH}/modelo_{TARGET.lower()}.pkl') # <- NOME ALTERADO
print(f"💾 Modelo para {TARGET} salvo em: {ARTIFACTS_PATH}/modelo_{TARGET.lower()}.pkl")
print("\n--- Concluído para Target 3 ---")
</file>

<file path="dashboard/backend/export_hibrido_target1.py">
# =============================================================================
# EXPORT HÍBRIDO - TARGET 1 (R1)
# =============================================================================
# Este script replica a SEÇÃO 2 do notebook híbrido definitivo
# Treina o modelo R1 e salva os artefatos necessários para a API

import pandas as pd
import numpy as np
import warnings
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.preprocessing import RobustScaler
from sklearn.feature_selection import VarianceThreshold
from catboost import CatBoostRegressor
import optuna
import joblib
import pickle
import os

warnings.filterwarnings('ignore')
optuna.logging.set_verbosity(optuna.logging.WARNING)

# Configuração de caminhos
ARTIFACTS_PATH = 'ml_artifacts'
os.makedirs(ARTIFACTS_PATH, exist_ok=True)

print("=" * 100)
print("🎯 TREINAMENTO TARGET 1 (R1) - MODELO HÍBRIDO".center(100))
print("=" * 100)

# =============================================================================
# CARREGAMENTO E PRÉ-PROCESSAMENTO
# =============================================================================

df_raw = pd.read_excel('JogadoresV3.xlsx')
df = df_raw.copy()

print(f"\n✅ Dados carregados: {len(df)} linhas")

# Converter F0103
if 'F0103' in df.columns:
    df['F0103'] = pd.to_numeric(df['F0103'].astype(str).str.replace(',', '.'), errors='coerce')

# Identificar colunas P, T, F
p_cols = [col for col in df.columns if col.startswith('P') and any(c.isdigit() for c in col)]
t_cols = [col for col in df.columns if col.startswith('T') and any(c.isdigit() for c in col)]
f_cols = [col for col in df.columns if col.startswith('F') and len(col) > 1 and any(c.isdigit() for c in col)]

# Tratar colunas duplicadas
print("\n[1/6] Tratando colunas duplicadas...")
cols = pd.Series(df.columns)
duplicated_cols = cols[cols.duplicated()].unique()

if len(duplicated_cols) > 0:
    for dup in duplicated_cols:
        indices = cols[cols == dup].index.tolist()
        for i, idx in enumerate(indices):
            cols.iloc[idx] = f'{dup}_{i}'
    df.columns = cols
    # Atualizar listas de colunas
    p_cols = [col for col in df.columns if col.startswith('P') and any(c.isdigit() for c in col)]
    t_cols = [col for col in df.columns if col.startswith('T') and any(c.isdigit() for c in col)]
    f_cols = [col for col in df.columns if col.startswith('F') and len(col) > 1 and any(c.isdigit() for c in col)]
    print(f"  ✅ Colunas duplicadas renomeadas")
else:
    print("  ✅ Sem duplicatas")

# Converter para numérico
for col in p_cols + t_cols + f_cols:
    if col in df.columns:
        df[col] = pd.to_numeric(df[col], errors='coerce')

# Remover outliers extremos
numeric_cols = [col for col in df.select_dtypes(include=[np.number]).columns if 'Target' not in col]
for col in numeric_cols:
    if col in df.columns:
        df.loc[df[col] < -100, col] = np.nan
        if df[col].max() > 10000:
            df.loc[df[col] > 10000, col] = np.nan

# =============================================================================
# FEATURE ENGINEERING
# =============================================================================

print("\n[2/6] Criando features comportamentais...")

# Taxa de pulos (-1)
p_minus_ones = sum((df[col] == -1).sum() for col in p_cols if col in df.columns)
t_minus_ones = sum((df[col] == -1).sum() for col in t_cols if col in df.columns)

df['taxa_pulos_P'] = p_minus_ones / len(p_cols) if len(p_cols) > 0 else 0
df['taxa_pulos_T'] = t_minus_ones / len(t_cols) if len(t_cols) > 0 else 0
df['taxa_pulos_geral'] = (p_minus_ones + t_minus_ones) / (len(p_cols) + len(t_cols))

# Substituir -1 por NaN e preencher com mediana
for col in p_cols + t_cols + f_cols:
    if col in df.columns:
        df[col] = df[col].replace(-1, np.nan)
        df[col] = df[col].replace(-1.0, np.nan)
        if df[col].isnull().sum() > 0:
            df[col].fillna(df[col].median(), inplace=True)

print("\n[3/6] Feature engineering avançado...")

# Features de SONO
if 'QtdHorasDormi' in df.columns and 'Acordar' in df.columns:
    df['sono_total'] = df['QtdHorasDormi']
    df['sono_x_acordar'] = df['QtdHorasDormi'] * df['Acordar']
    df['sono_squared'] = df['QtdHorasDormi'] ** 2
    df['sono_irregular'] = np.abs(df['QtdHorasDormi'] - df['QtdHorasDormi'].median())
    print(f"  ✅ Sono: 4 features")

# Features de PERFORMANCE
if len(p_cols) > 0:
    df['P_mean'] = df[p_cols].mean(axis=1)
    df['P_std'] = df[p_cols].std(axis=1)
    df['P_min'] = df[p_cols].min(axis=1)
    df['P_max'] = df[p_cols].max(axis=1)
    df['P_range'] = df['P_max'] - df['P_min']
    df['P_late'] = df[['P09', 'P12', 'P13', 'P15']].mean(axis=1) if all(c in df.columns for c in ['P09', 'P12', 'P13', 'P15']) else 0
    df['P_early'] = df[['P01', 'P02', 'P03', 'P04']].mean(axis=1) if all(c in df.columns for c in ['P01', 'P02', 'P03', 'P04']) else 0
    print(f"  ✅ Performance: 7 features")

# Features de TEMPO
if len(t_cols) > 0:
    df['T_mean'] = df[t_cols].mean(axis=1)
    df['T_std'] = df[t_cols].std(axis=1)
    df['T_min'] = df[t_cols].min(axis=1)
    df['T_max'] = df[t_cols].max(axis=1)
    print(f"  ✅ Tempo: 4 features")

# Features de FORMULÁRIOS
f_perfil = [c for c in f_cols if c.startswith('F01') or c.startswith('F02')]
if len(f_perfil) > 0:
    df['F_perfil_mean'] = df[f_perfil].mean(axis=1)
    df['F_perfil_std'] = df[f_perfil].std(axis=1)

f_sono = [c for c in f_cols if c.startswith('F07')]
if len(f_sono) > 0:
    df['F_sono_mean'] = df[f_sono].mean(axis=1)
    df['F_sono_std'] = df[f_sono].std(axis=1)

f_final = [c for c in f_cols if c.startswith('F11')]
if len(f_final) > 0:
    df['F_final_mean'] = df[f_final].mean(axis=1)
    df['F_final_std'] = df[f_final].std(axis=1)

df['F_mean_geral'] = df[f_cols].mean(axis=1)

# =============================================================================
# SELEÇÃO DE FEATURES
# =============================================================================

print("\n[4/6] Selecionando TOP features...")

TARGET = 'Target1'
feature_cols = [col for col in df.columns if col not in [TARGET, 'Código de Acesso', 'Data/Hora Último', 'Target2', 'Target3']
                and pd.api.types.is_numeric_dtype(df[col])]

X = df[feature_cols].fillna(0)
y = df[TARGET]

# Variance Threshold
selector = VarianceThreshold(threshold=0.01)
selector.fit(X)
feature_cols = X.columns[selector.get_support()].tolist()
X = df[feature_cols]

# Correlação com target
correlations = []
for col in feature_cols:
    corr = abs(df[col].corr(df[TARGET]))
    if not np.isnan(corr):
        correlations.append((col, corr))

correlations.sort(key=lambda x: x[1], reverse=True)

# TOP 30 features
TOP_K = min(30, len(correlations))
selected_features_r1 = [col for col, _ in correlations[:TOP_K]]

print(f"  ✅ {TOP_K} features selecionadas")

# Criar interações entre TOP 3
top3_features = [col for col, _ in correlations[:3]]
interaction_features = []

for i, f1 in enumerate(top3_features):
    for f2 in top3_features[i+1:]:
        interaction_name = f'{f1}_X_{f2}'
        df[interaction_name] = df[f1] * df[f2]
        interaction_features.append(interaction_name)

selected_features_r1.extend(interaction_features)
selected_features_r1 = list(dict.fromkeys(selected_features_r1))

print(f"  Total com interações: {len(selected_features_r1)}")

# =============================================================================
# PREPARAÇÃO DOS DADOS
# =============================================================================

print("\n[5/6] Preparando dados para treinamento...")

# Scaler
scaler_r1 = RobustScaler()
X_final = df[selected_features_r1].copy().fillna(0)
X_scaled = scaler_r1.fit_transform(X_final)

X_r1 = X_scaled
y_r1 = df[TARGET].values

# Remover NaNs
valid_idx = ~np.isnan(y_r1)
X_r1 = X_r1[valid_idx]
y_r1 = y_r1[valid_idx]

# Split
X_train_r1, X_test_r1, y_train_r1, y_test_r1 = train_test_split(X_r1, y_r1, test_size=0.25, random_state=42)

print(f"  Treino: {len(X_train_r1)} | Teste: {len(X_test_r1)}")

# =============================================================================
# OTIMIZAÇÃO E TREINAMENTO
# =============================================================================

print("\n[6/6] Otimizando hiperparâmetros (100 trials)...")

def objective_r1(trial):
    params = {
        'iterations': 500,
        'learning_rate': trial.suggest_float('learning_rate', 0.01, 0.1, log=True),
        'depth': trial.suggest_int('depth', 3, 6),
        'l2_leaf_reg': trial.suggest_float('l2_leaf_reg', 10, 100, log=True),
        'border_count': trial.suggest_int('border_count', 32, 128),
        'bagging_temperature': trial.suggest_float('bagging_temperature', 0.5, 1.0),
        'random_strength': trial.suggest_float('random_strength', 0.5, 2.0),
        'verbose': False,
        'random_seed': 42
    }
    model = CatBoostRegressor(**params)
    scores = cross_val_score(model, X_train_r1, y_train_r1, cv=5, scoring='r2')
    return scores.mean()

study_r1 = optuna.create_study(direction='maximize')
study_r1.optimize(objective_r1, n_trials=100, show_progress_bar=True)

best_params_r1 = study_r1.best_params
best_params_r1['iterations'] = 500
best_params_r1['verbose'] = False
best_params_r1['random_seed'] = 42

print(f"\n✅ Melhor R² CV: {study_r1.best_value:.4f}")

# Treinar modelo final
print("\n🔧 Treinando modelo final...")
model_r1 = CatBoostRegressor(**best_params_r1)
model_r1.fit(X_train_r1, y_train_r1, verbose=False)

# =============================================================================
# SALVAR ARTEFATOS
# =============================================================================

print("\n💾 Salvando artefatos...")

# Salvar modelo
joblib.dump(model_r1, f'{ARTIFACTS_PATH}/modelo_target1.pkl')
print(f"  ✅ Modelo salvo: {ARTIFACTS_PATH}/modelo_target1.pkl")

# Salvar scaler
joblib.dump(scaler_r1, f'{ARTIFACTS_PATH}/scaler_target1.pkl')
print(f"  ✅ Scaler salvo: {ARTIFACTS_PATH}/scaler_target1.pkl")

# Salvar lista de features
with open(f'{ARTIFACTS_PATH}/features_target1.pkl', 'wb') as f:
    pickle.dump(selected_features_r1, f)
print(f"  ✅ Features salvas: {ARTIFACTS_PATH}/features_target1.pkl")

print("\n" + "=" * 100)
print("✅ TARGET 1 (R1) - TREINAMENTO COMPLETO!".center(100))
print("=" * 100)
print(f"\n📦 Artefatos salvos em: {ARTIFACTS_PATH}/")
print(f"  • modelo_target1.pkl")
print(f"  • scaler_target1.pkl")
print(f"  • features_target1.pkl")
</file>

<file path="dashboard/backend/export_hibrido_target2.py">
# =============================================================================
# EXPORT HÍBRIDO - TARGET 2 (R2)
# =============================================================================
# Este script replica a SEÇÃO 3 do notebook híbrido definitivo (CORRIGIDO!)
# Treina o ENSEMBLE de 3 modelos R2 e salva os artefatos necessários para a API

import pandas as pd
import numpy as np
import warnings
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.preprocessing import QuantileTransformer
from sklearn.feature_selection import VarianceThreshold
from catboost import CatBoostRegressor
import optuna
import joblib
import pickle
import os

warnings.filterwarnings('ignore')
optuna.logging.set_verbosity(optuna.logging.WARNING)

# Configuração de caminhos
ARTIFACTS_PATH = 'ml_artifacts'
os.makedirs(ARTIFACTS_PATH, exist_ok=True)

print("=" * 100)
print("🎯 TREINAMENTO TARGET 2 (R2) - ENSEMBLE HÍBRIDO CORRIGIDO".center(100))
print("=" * 100)

# =============================================================================
# CARREGAMENTO E PRÉ-PROCESSAMENTO
# =============================================================================

df_raw = pd.read_excel('JogadoresV3.xlsx')
df = df_raw.copy()

TARGET = 'Target2'

print(f"\n✅ Dados carregados: {len(df)} linhas")

# Converter F0103
if 'F0103' in df.columns:
    df['F0103'] = pd.to_numeric(df['F0103'].astype(str).str.replace(',', '.'), errors='coerce')

# Identificar colunas P, T, F
p_cols = [col for col in df.columns if col.startswith('P') and any(c.isdigit() for c in col)]
t_cols = [col for col in df.columns if col.startswith('T') and any(c.isdigit() for c in col)]
f_cols = [col for col in df.columns if col.startswith('F') and len(col) > 1 and any(c.isdigit() for c in col)]

print("\n[1/5] Tratando valores -1 e NaN...")

# Converter para numérico e tratar -1
for col in p_cols + t_cols + f_cols:
    if col in df.columns:
        df[col] = pd.to_numeric(df[col], errors='coerce')
        df[col] = df[col].replace(-1, np.nan)
        if df[col].isnull().sum() > 0:
            df[col].fillna(df[col].median(), inplace=True)

# =============================================================================
# FEATURE ENGINEERING MINIMALISTA
# =============================================================================

print("\n[2/5] Criando features minimalistas para R2...")

# Features de sono
if 'QtdHorasDormi' in df.columns and 'Acordar' in df.columns:
    df['sono_total'] = df['QtdHorasDormi']
    df['acordar'] = df['Acordar']

# Features de formulário sono
f_sono = [c for c in f_cols if c.startswith('F07')]
if len(f_sono) > 0:
    df['F_sono_mean'] = df[f_sono].mean(axis=1)

# Features de formulário final
f_final = [c for c in f_cols if c.startswith('F11')]
if len(f_final) > 0:
    df['F_final_mean'] = df[f_final].mean(axis=1)

# Features de performance
p_cols_exist = [c for c in p_cols if c in df.columns]
if len(p_cols_exist) > 0:
    df['P_mean'] = df[p_cols_exist].mean(axis=1)

# Preencher NaN remanescentes
numeric_cols = df.select_dtypes(include=np.number).columns
for col in numeric_cols:
    if df[col].isnull().sum() > 0:
        df[col].fillna(df[col].median(), inplace=True)

# =============================================================================
# SELEÇÃO DE FEATURES CONSERVADORA
# =============================================================================

print("\n[3/5] Seleção conservadora (≤12 features)...")

feature_cols = [col for col in df.columns if col not in [TARGET, 'Código de Acesso', 'Data/Hora Último', 'Target1', 'Target3']
                and pd.api.types.is_numeric_dtype(df[col])]

X_pre = df[feature_cols].fillna(0)
y = df[TARGET]

# Variance Threshold
selector = VarianceThreshold(threshold=0.01)
selector.fit(X_pre)
feature_cols_filtered = X_pre.columns[selector.get_support()].tolist()

# Correlação com target
correlations = []
for col in feature_cols_filtered:
    corr = df[col].corr(df[TARGET])
    if not np.isnan(corr):
        correlations.append((col, abs(corr)))

correlations.sort(key=lambda x: x[1], reverse=True)

# TOP 12 features
MAX_FEATURES = 12
selected_features_r2 = [col for col, _ in correlations[:MAX_FEATURES]]

print(f"  ✅ {len(selected_features_r2)} features selecionadas")

# Criar uma interação entre TOP 2
if len(selected_features_r2) >= 2:
    f1, f2 = selected_features_r2[0], selected_features_r2[1]
    df[f'{f1}_X_{f2}'] = df[f1] * df[f2]
    selected_features_r2.append(f'{f1}_X_{f2}')

# =============================================================================
# PREPARAÇÃO DOS DADOS
# =============================================================================

print("\n[4/5] Preparando dados...")

X_r2 = df[selected_features_r2].copy()
y_r2 = df[TARGET].values

# Remover NaNs
valid_idx = ~np.isnan(y_r2)
X_r2 = X_r2[valid_idx]
y_r2 = y_r2[valid_idx]

print(f"  Dados: {len(X_r2)} amostras × {len(selected_features_r2)} features")

# =============================================================================
# OTIMIZAÇÃO
# =============================================================================

print("\n[5/5] Otimização brutal (150 trials)...")

def objective_r2(trial):
    params = {
        'iterations': trial.suggest_int('iterations', 300, 700),
        'learning_rate': trial.suggest_float('learning_rate', 0.001, 0.03, log=True),
        'depth': trial.suggest_int('depth', 2, 3),
        'l2_leaf_reg': trial.suggest_float('l2_leaf_reg', 50, 300, log=True),
        'border_count': trial.suggest_int('border_count', 16, 48),
        'bagging_temperature': trial.suggest_float('bagging_temperature', 0.0, 0.5),
        'random_strength': trial.suggest_float('random_strength', 2.0, 5.0),
        'min_data_in_leaf': trial.suggest_int('min_data_in_leaf', 5, 15),
        'verbose': False,
        'random_seed': 42
    }

    X_tr_opt, X_te_opt, y_tr_opt, y_te_opt = train_test_split(X_r2, y_r2, test_size=0.25, random_state=42)
    scaler_temp = QuantileTransformer(output_distribution='normal', random_state=42)
    X_tr_scaled = scaler_temp.fit_transform(X_tr_opt)

    model = CatBoostRegressor(**params)
    scores = cross_val_score(model, X_tr_scaled, y_tr_opt, cv=5, scoring='r2')
    return scores.mean()

study_r2 = optuna.create_study(direction='maximize')
study_r2.optimize(objective_r2, n_trials=150, show_progress_bar=True)

best_params_r2 = study_r2.best_params
best_params_r2['verbose'] = False
best_params_r2['random_seed'] = 42

print(f"\n✅ Melhor R² CV: {study_r2.best_value:.4f}")

# =============================================================================
# TREINAMENTO DO ENSEMBLE (3 MODELOS) - VERSÃO CORRIGIDA
# =============================================================================

print("\n🚀 Treinando ensemble (3 modelos)...")
print("  ✅ Cada modelo treina com seed diferente (diversidade)")

# SPLIT BASE COMUM (para consistência do scaler)
X_train_base, X_test_base, y_train_base, y_test_base = train_test_split(
    X_r2, y_r2, test_size=0.25, random_state=42
)

# SCALER BASE COMUM
scaler_base = QuantileTransformer(output_distribution='normal', random_state=42)
X_train_base_scaled = scaler_base.fit_transform(X_train_base)
X_test_base_scaled = scaler_base.transform(X_test_base)

models_r2 = []

for i, seed in enumerate([42, 123, 456], 1):
    print(f"\n  Treinando Modelo {i} (seed={seed})...")
    
    # Cada modelo treina com seed diferente para diversidade
    X_tr_div, X_te_div, y_tr_div, y_te_div = train_test_split(X_r2, y_r2, test_size=0.25, random_state=seed)
    scaler_div = QuantileTransformer(output_distribution='normal', random_state=42)
    X_tr_div_scaled = scaler_div.fit_transform(X_tr_div)
    
    # Treinar modelo
    params_i = best_params_r2.copy()
    params_i['random_seed'] = seed
    model_i = CatBoostRegressor(**params_i)
    model_i.fit(X_tr_div_scaled, y_tr_div, verbose=False)
    
    models_r2.append(model_i)
    print(f"  ✅ Modelo {i} treinado!")

# =============================================================================
# SALVAR ARTEFATOS
# =============================================================================

print("\n💾 Salvando artefatos...")

# Salvar os 3 modelos do ensemble
for i, model in enumerate(models_r2):
    joblib.dump(model, f'{ARTIFACTS_PATH}/modelo_target2_ensemble_{i}.pkl')
    print(f"  ✅ Modelo {i+1} salvo: {ARTIFACTS_PATH}/modelo_target2_ensemble_{i}.pkl")

# Salvar o scaler (QuantileTransformer)
joblib.dump(scaler_base, f'{ARTIFACTS_PATH}/scaler_target2.pkl')
print(f"  ✅ Scaler salvo: {ARTIFACTS_PATH}/scaler_target2.pkl")

# Salvar a lista de features
with open(f'{ARTIFACTS_PATH}/features_target2.pkl', 'wb') as f:
    pickle.dump(selected_features_r2, f)
print(f"  ✅ Features salvas: {ARTIFACTS_PATH}/features_target2.pkl")

print("\n" + "=" * 100)
print("✅ TARGET 2 (R2) - ENSEMBLE COMPLETO!".center(100))
print("=" * 100)
print(f"\n📦 Artefatos salvos em: {ARTIFACTS_PATH}/")
print(f"  • modelo_target2_ensemble_0.pkl")
print(f"  • modelo_target2_ensemble_1.pkl")
print(f"  • modelo_target2_ensemble_2.pkl")
print(f"  • scaler_target2.pkl (QuantileTransformer)")
print(f"  • features_target2.pkl")
print(f"\n💡 NOTA: A API fará a média das predições dos 3 modelos")
</file>

<file path="dashboard/backend/export_hibrido_target3.py">
# =============================================================================
# EXPORT HÍBRIDO - TARGET 3 (R3)
# =============================================================================
# Este script replica a SEÇÃO 4 do notebook híbrido definitivo (CORRIGIDO!)
# Treina o ENSEMBLE de 3 modelos R3 e salva os artefatos necessários para a API

import pandas as pd
import numpy as np
import warnings
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.preprocessing import RobustScaler
from catboost import CatBoostRegressor
import optuna
import joblib
import pickle
import os

warnings.filterwarnings('ignore')
optuna.logging.set_verbosity(optuna.logging.WARNING)

# Configuração de caminhos
ARTIFACTS_PATH = 'ml_artifacts'
os.makedirs(ARTIFACTS_PATH, exist_ok=True)

print("=" * 100)
print("🎯 TREINAMENTO TARGET 3 (R3) - ENSEMBLE HÍBRIDO CORRIGIDO".center(100))
print("=" * 100)

# =============================================================================
# CARREGAMENTO E PRÉ-PROCESSAMENTO
# =============================================================================

df_raw = pd.read_excel('JogadoresV3.xlsx')
df = df_raw.copy()

TARGET = 'Target3'

print(f"\n✅ Dados carregados: {len(df)} linhas")

# Converter F0103
if 'F0103' in df.columns:
    df['F0103'] = pd.to_numeric(df['F0103'].astype(str).str.replace(',', '.'), errors='coerce')

# Identificar colunas P, T, F
p_cols = [col for col in df.columns if col.startswith('P') and any(c.isdigit() for c in col)]
t_cols = [col for col in df.columns if col.startswith('T') and any(c.isdigit() for c in col)]
f_cols = [col for col in df.columns if col.startswith('F') and len(col) > 1 and any(c.isdigit() for c in col)]

print("\n[1/5] Tratando valores -1 e NaN...")

# Converter para numérico e tratar -1
for col in p_cols + t_cols + f_cols:
    if col in df.columns:
        df[col] = pd.to_numeric(df[col], errors='coerce')
        df[col] = df[col].replace(-1, np.nan)
        if df[col].isnull().sum() > 0:
            df[col].fillna(df[col].median(), inplace=True)

# =============================================================================
# FEATURE ENGINEERING
# =============================================================================

print("\n[2/5] Feature engineering para R3...")

# Features de Performance
df['P_mean'] = df[p_cols].mean(axis=1)
df['P_std'] = df[p_cols].std(axis=1)
df['P_late'] = df[['P09', 'P12', 'P13', 'P15']].mean(axis=1) if all(c in df.columns for c in ['P09', 'P12', 'P13', 'P15']) else 0
df['P_early'] = df[['P01', 'P02', 'P03', 'P04']].mean(axis=1) if all(c in df.columns for c in ['P01', 'P02', 'P03', 'P04']) else 0

# Features de Tempo
df['T_mean'] = df[t_cols].mean(axis=1)
df['T_std'] = df[t_cols].std(axis=1)

# Features de Sono
if 'QtdHorasSono' in df.columns:
    f_sono = [c for c in f_cols if '07' in c]
    df['F_sono_mean'] = df[f_sono].mean(axis=1)
    df['F_sono_std'] = df[f_sono].std(axis=1)
    df['F_sono_max'] = df[f_sono].max(axis=1)
    if 'Acordar' in df.columns:
        df['sono_x_acordar'] = df['QtdHorasSono'] * df['Acordar']
        df['acordar_squared'] = df['Acordar'] ** 2

# Features de Formulário Final
f_final = [c for c in f_cols if '11' in c]
df['F_final_mean'] = df[f_final].mean(axis=1)

print("  ✅ Features criadas!")

# =============================================================================
# SELEÇÃO DE FEATURES
# =============================================================================

print("\n[3/5] Seleção TOP 15 features...")

# Pool de features com correlação > 0.35
feature_pool = []
for col in df.columns:
    if col not in [TARGET, 'Código de Acesso', 'Target1', 'Target2'] and df[col].dtype in ['float64', 'int64']:
        corr = abs(df[col].corr(df[TARGET]))
        if not np.isnan(corr) and corr > 0.35:
            feature_pool.append((col, corr))

feature_pool.sort(key=lambda x: x[1], reverse=True)
selected_features_r3 = [f[0] for f in feature_pool[:15]]

print(f"  ✅ {len(selected_features_r3)} features selecionadas")

# Criar interação
if 'F1103' in selected_features_r3 and 'P_mean' in selected_features_r3:
    df['F1103_X_P_mean'] = df['F1103'] * df['P_mean']
    selected_features_r3.append('F1103_X_P_mean')

# =============================================================================
# PREPARAÇÃO DOS DADOS
# =============================================================================

print("\n[4/5] Preparando dados...")

X_r3 = df[selected_features_r3].fillna(df[selected_features_r3].median())
y_r3 = df[TARGET].values

print(f"  Dados: {len(X_r3)} amostras × {len(selected_features_r3)} features")

# =============================================================================
# OTIMIZAÇÃO
# =============================================================================

print("\n[5/5] Otimização (100 trials)...")

def objective_r3(trial):
    X_tr_opt, X_te_opt, y_tr_opt, y_te_opt = train_test_split(X_r3, y_r3, test_size=0.25, random_state=42)
    scaler_temp = RobustScaler()
    X_tr_scaled = scaler_temp.fit_transform(X_tr_opt)

    params = {
        'iterations': trial.suggest_int('iterations', 200, 800),
        'learning_rate': trial.suggest_float('learning_rate', 0.005, 0.05, log=True),
        'depth': 2,
        'l2_leaf_reg': trial.suggest_float('l2_leaf_reg', 120, 180),
        'border_count': trial.suggest_int('border_count', 16, 128),
        'bagging_temperature': trial.suggest_float('bagging_temperature', 0, 1),
        'random_strength': trial.suggest_float('random_strength', 0.5, 5),
        'min_data_in_leaf': trial.suggest_int('min_data_in_leaf', 8, 15),
        'random_seed': 42,
        'verbose': False
    }
    model = CatBoostRegressor(**params)
    scores = cross_val_score(model, X_tr_scaled, y_tr_opt, cv=3, scoring='r2')
    return scores.mean()

study_r3 = optuna.create_study(direction='maximize')
study_r3.optimize(objective_r3, n_trials=100, show_progress_bar=True)

best_params_r3 = study_r3.best_params
best_params_r3['depth'] = 2
best_params_r3['verbose'] = False
best_params_r3['random_seed'] = 42

print(f"\n✅ Melhor R² CV: {study_r3.best_value:.4f}")

# =============================================================================
# TREINAMENTO DO ENSEMBLE (3 MODELOS) - VERSÃO CORRIGIDA
# =============================================================================

print("\n🚀 Treinando ensemble (3 modelos)...")
print("  ✅ Cada modelo treina com seed diferente (diversidade)")

# SPLIT BASE COMUM (para consistência do scaler)
X_train_base_r3, X_test_base_r3, y_train_base_r3, y_test_base_r3 = train_test_split(
    X_r3, y_r3, test_size=0.25, random_state=42
)

# SCALER BASE COMUM
scaler_base_r3 = RobustScaler()
X_train_base_r3_scaled = scaler_base_r3.fit_transform(X_train_base_r3)
X_test_base_r3_scaled = scaler_base_r3.transform(X_test_base_r3)

models_r3 = []

for i, seed in enumerate([42, 123, 456], 1):
    print(f"\n  Treinando Modelo {i} (seed={seed})...")
    
    # Cada modelo treina com seed diferente para diversidade
    X_tr_div, X_te_div, y_tr_div, y_te_div = train_test_split(X_r3, y_r3, test_size=0.25, random_state=seed)
    scaler_div = RobustScaler()
    X_tr_div_scaled = scaler_div.fit_transform(X_tr_div)
    
    # Treinar modelo
    params_i = best_params_r3.copy()
    params_i['random_seed'] = seed
    model_i = CatBoostRegressor(**params_i)
    model_i.fit(X_tr_div_scaled, y_tr_div, verbose=False)
    
    models_r3.append(model_i)
    print(f"  ✅ Modelo {i} treinado!")

# =============================================================================
# SALVAR ARTEFATOS
# =============================================================================

print("\n💾 Salvando artefatos...")

# Salvar os 3 modelos do ensemble
for i, model in enumerate(models_r3):
    joblib.dump(model, f'{ARTIFACTS_PATH}/modelo_target3_ensemble_{i}.pkl')
    print(f"  ✅ Modelo {i+1} salvo: {ARTIFACTS_PATH}/modelo_target3_ensemble_{i}.pkl")

# Salvar o scaler (RobustScaler)
joblib.dump(scaler_base_r3, f'{ARTIFACTS_PATH}/scaler_target3.pkl')
print(f"  ✅ Scaler salvo: {ARTIFACTS_PATH}/scaler_target3.pkl")

# Salvar a lista de features
with open(f'{ARTIFACTS_PATH}/features_target3.pkl', 'wb') as f:
    pickle.dump(selected_features_r3, f)
print(f"  ✅ Features salvas: {ARTIFACTS_PATH}/features_target3.pkl")

print("\n" + "=" * 100)
print("✅ TARGET 3 (R3) - ENSEMBLE COMPLETO!".center(100))
print("=" * 100)
print(f"\n📦 Artefatos salvos em: {ARTIFACTS_PATH}/")
print(f"  • modelo_target3_ensemble_0.pkl")
print(f"  • modelo_target3_ensemble_1.pkl")
print(f"  • modelo_target3_ensemble_2.pkl")
print(f"  • scaler_target3.pkl (RobustScaler)")
print(f"  • features_target3.pkl")
print(f"\n💡 NOTA: A API fará a média das predições dos 3 modelos")
</file>

<file path="dashboard/backend/models.py">
# models.py
from sqlalchemy import Column, Integer, String, Float, DateTime, ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from database import Base

class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, unique=True, index=True, nullable=False)
    password_hash = Column(String, nullable=False)
    predictions = relationship('Prediction', backref='user', lazy=True)

class Prediction(Base):
    __tablename__ = 'predictions'
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey('users.id'), nullable=False)
    upload_timestamp = Column(DateTime, nullable=False, default=func.now())
    jogador_id = Column(String, nullable=False)
    pred_t1 = Column(Float, nullable=False)
    pred_t2 = Column(Float, nullable=False)
    pred_t3 = Column(Float, nullable=False)
</file>

<file path="dashboard/backend/README.md">
# Backend API (FastAPI)

Esta API serve como o cérebro do projeto, lidando com autenticação, processamento de dados e previsões de Machine Learning.

## Principais Funcionalidades

-   **Autenticação JWT:** Sistema de registro (`/register`) e login (`/login`) que gera tokens JWT para proteger os endpoints.
-   **Endpoint de Previsão (`/predict`):** Recebe um arquivo `.xlsx` com novos dados de jogadores, aplica o mesmo pipeline de pré-processamento dos modelos treinados e retorna as previsões para os 3 targets.
-   **Análise SHAP:** Junto com as previsões, a API calcula os valores SHAP para cada jogador, permitindo entender a contribuição de cada feature para o resultado.
-   **Histórico de Previsões (`/history`):** Salva cada lote de previsões no banco de dados, associado ao usuário que fez o upload.
-   **Análise do Modelo (`/feature_importance`):** Expõe a importância geral das features para cada modelo.

## Principais Endpoints

-   `POST /register`: Cria um novo usuário.
-   `POST /login`: Autentica um usuário e retorna um token de acesso.
-   `POST /predict`: (Protegido) Recebe um arquivo Excel e retorna as previsões e dados SHAP.
-   `GET /history`: (Protegido) Retorna o histórico de uploads do usuário logado.
-   `GET /feature_importance`: (Protegido) Retorna a importância das features para cada modelo.
-   `GET /health`: Verifica a saúde da aplicação, incluindo o carregamento dos modelos de ML.
</file>

<file path="dashboard/backend/schemas.py">
# schemas.py
from pydantic import BaseModel

class UserCreate(BaseModel):
    username: str
    password: str

class Token(BaseModel):
    access_token: str
    token_type: str
</file>

<file path="dashboard/frontend/README.md">
# Frontend Dashboard (Plotly Dash)

Este é um dashboard interativo construído com Plotly Dash para fornecer uma interface amigável para o sistema de previsão.

## Funcionalidades

O dashboard é dividido em abas:

1.  **Nova Previsão:**
    -   Permite o upload de um arquivo `.xlsx` com novos dados de jogadores.
    -   Exibe os resultados em uma tabela interativa (ordenável, filtrável) e em gráficos de barras comparativos.
    -   Disponibiliza um botão para download dos resultados.
    -   Apresenta uma seção de análise SHAP, onde é possível selecionar um jogador e visualizar gráficos que explicam sua previsão.

2.  **Análise do Modelo:**
    -   Exibe gráficos de barras horizontais mostrando as 20 features mais importantes para cada um dos 3 modelos de target.

3.  **Histórico:**
    -   Mostra uma tabela com o histórico de uploads de arquivos realizados pelo usuário, incluindo data e quantidade de jogadores previstos em cada lote.
</file>

<file path="dashboard/README.md">
# Projeto Daruma: Previsão de Targets de Jogadores

Este projeto é a solução para o Desafio Final de Ciclo, que consiste em construir um sistema de Machine Learning completo para prever 3 targets numéricos com base nos dados de jogadores.

A solução inclui um pipeline de treinamento de modelos, uma API backend para servir as previsões e um dashboard interativo para visualização e análise dos resultados.

## Arquitetura

O projeto é conteinerizado com Docker e orquestrado com Docker Compose, seguindo a arquitetura abaixo:

```
Frontend (Plotly Dash) <--> Backend (FastAPI) <--> Database (PostgreSQL)
```

-   **Frontend:** Um dashboard interativo onde o usuário pode fazer upload de novos dados, visualizar previsões, análises de importância de features e explicações de predição individuais com SHAP.
-   **Backend:** Uma API RESTful construída com FastAPI que lida com autenticação de usuários, recebe os dados, executa o pipeline de pré-processamento e predição usando modelos pré-treinados, e salva os resultados.
-   **Database:** Um banco de dados PostgreSQL para armazenar informações de usuários e histórico de previsões.
-   **ML Training:** Scripts Python para treinar os modelos de Machine Learning, realizar a otimização de hiperparâmetros e exportar os artefatos (modelos, scalers, listas de features) necessários para a API.

## Estrutura do Projeto

```
.
├── backend/            # Código da API FastAPI
│   ├── ml_artifacts/   # Artefatos de ML (modelos, scalers, etc.)
│   └── ...
├── frontend/           # Código do Dashboard em Dash
│   └── ...
├── .env                # Arquivo de configuração de ambiente (NÃO COMMITAR)
├── .gitignore
├── docker-compose.yml
└── README.md
```

## Como Executar

**Pré-requisitos:**
*   Docker
*   Docker Compose

**Passo 1: Preparar os Modelos de ML**

# Pipeline de Treinamento de Modelos

Esta parte contém os scripts responsáveis pelo treinamento, otimização e exportação dos modelos de Machine Learning. Pois, os modelos precisam ser treinados antes de iniciar a aplicação.

# Navegue até a pasta backend
cd backend

# Instale as dependências
pip install -r requirements.txt

# Certifique-se que o excel para treinamento 'JogadoresV1.xlsx' esteja na mesma pasta e Execute os scripts de treinamento para gerar os artefatos
python export_artifacts_target1.py
python export_artifacts_target2.py
python export_artifacts_target3.py

## Funcionamento
Cada script `export_artifacts_target<N>.py` é um pipeline completo para um dos três targets. O processo geral inclui:

1.  **Carregamento e Limpeza:** Os dados do arquivo `JogadoresV1.xlsx` são carregados. Valores ausentes são tratados (imputação por mediana) e tipos de dados são corrigidos.
2.  **Engenharia de Features:** Novas features são criadas a partir das existentes (médias, interações, features polinomiais) para aumentar o poder preditivo do modelo.
3.  **Seleção de Features:** Técnicas como `VarianceThreshold`, correlação com o target e importância de features de um `RandomForest` são usadas para selecionar as variáveis mais relevantes.
4.  **Otimização de Hiperparâmetros:** A biblioteca `Optuna` é utilizada para encontrar os melhores hiperparâmetros para os modelos (ex: `CatBoost`), maximizando a métrica `R2 Score` em validação cruzada.
5.  **Treinamento Final:** O modelo é treinado com os melhores parâmetros em todo o conjunto de dados de treino.
6.  **Exportação de Artefatos:** O modelo treinado, o `scaler` (para normalização) e a lista de features utilizadas são salvos como arquivos `.pkl` na pasta `backend/ml_artifacts`.

# Volte para a raiz do projeto
cd ..
```
Isso criará a pasta `backend/ml_artifacts` com todos os arquivos `.pkl` necessários.

**Passo 2: Configurar o Ambiente**

Crie uma cópia do arquivo `.env.example` (que você deve criar) e renomeie para `.env`. Preencha com suas configurações, principalmente uma `JWT_SECRET_KEY` segura.

**Passo 3: Iniciar a Aplicação**

Com o Docker em execução, rode o seguinte comando na raiz do projeto:

```bash
docker-compose up --build
```

A aplicação estará disponível nos seguintes endereços:
-   **Dashboard:** `http://localhost:8050`
-   **API (documentação):** `http://localhost:5000/docs`
</file>

<file path="notebooks/PROJETOFINAL.ipynb">
{
  "nbformat": 4,
  "nbformat_minor": 0,
  "metadata": {
    "colab": {
      "provenance": []
    },
    "kernelspec": {
      "name": "python3",
      "display_name": "Python 3"
    },
    "language_info": {
      "name": "python"
    }
  },
  "cells": [
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "tuhH-znyFcGf",
        "outputId": "c0c316ca-190e-4ac9-c8fb-99b0987ab8ae"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "\u001b[?25l   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m0.0/175.3 kB\u001b[0m \u001b[31m?\u001b[0m eta \u001b[36m-:--:--\u001b[0m\r\u001b[2K   \u001b[91m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m\u001b[91m╸\u001b[0m \u001b[32m174.1/175.3 kB\u001b[0m \u001b[31m6.9 MB/s\u001b[0m eta \u001b[36m0:00:01\u001b[0m\r\u001b[2K   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m175.3/175.3 kB\u001b[0m \u001b[31m3.9 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n",
            "\u001b[?25h✅ Bibliotecas instaladas!\n",
            "================================================================================\n",
            "     FASE 2 OTIMIZADA: LIMPEZA E PREPARAÇÃO (VERSÃO MELHORADA)\n",
            "================================================================================\n",
            "📋 Categóricas: 21 | Targets: 3\n",
            "\n",
            "================================================================================\n",
            "ETAPA 0: CARREGANDO DADOS\n",
            "================================================================================\n",
            "✅ Carregado: 183 linhas, 114 colunas\n",
            "\n",
            "================================================================================\n",
            "ETAPA 1: REMOÇÃO DE NEGATIVOS → NaN\n",
            "================================================================================\n",
            "✅ 108 negativos convertidos → NaN\n",
            "\n",
            "================================================================================\n",
            "ETAPA 2: ANÁLISE DE MISSING\n",
            "================================================================================\n",
            "🗑️  Removendo 7 colunas (>70% missing)\n",
            "✅ Shape: (183, 107)\n",
            "\n",
            "================================================================================\n",
            "ETAPA 3: REMOÇÃO DE JOGADORES SEM TARGETS\n",
            "================================================================================\n",
            "✅ Jogadores mantidos: 173 (removidos: 10)\n",
            "\n",
            "================================================================================\n",
            "ETAPA 4: IMPUTAÇÃO\n",
            "================================================================================\n",
            "✅ 90 numéricas imputadas (mediana)\n",
            "✅ 17 categóricas imputadas (moda)\n",
            "\n",
            "================================================================================\n",
            "ETAPA 5: TRATAMENTO DE OUTLIERS\n",
            "================================================================================\n",
            "✅ 727 outliers tratados (substituídos por mediana)\n",
            "\n",
            "================================================================================\n",
            "ETAPA 6: ONE-HOT ENCODING\n",
            "================================================================================\n",
            "✅ One-Hot concluído: 107 → 355 colunas\n",
            "\n",
            "================================================================================\n",
            "ETAPA 7: FEATURE ENGINEERING\n",
            "================================================================================\n",
            "✅ F11_mean criada (8 colunas)\n",
            "✅ F07_mean criada (9 colunas)\n",
            "\n",
            "================================================================================\n",
            "🔧 CORREÇÃO 1: CONVERSÃO BOOL → INT\n",
            "================================================================================\n",
            "📋 Convertendo 265 colunas booleanas...\n",
            "✅ VERDADEIRO/FALSO → 1/0\n",
            "   Exemplo: ['Cor0202_000000', 'Cor0202_3E3200', 'Cor0202_552D2D']\n",
            "\n",
            "================================================================================\n",
            "ETAPA 8: FEATURE SELECTION\n",
            "================================================================================\n",
            "📊 Features disponíveis: 347\n",
            "✅ Features mantidas: 54 (threshold=0.2)\n",
            "✅ Features removidas: 293\n",
            "\n",
            "🏆 TOP 10 FEATURES:\n",
            "    1. F07_mean                       | Corr: 0.6025\n",
            "    2. F1105                          | Corr: 0.5670\n",
            "    3. F1107                          | Corr: 0.5448\n",
            "    4. F1101                          | Corr: 0.5363\n",
            "    5. F0708                          | Corr: 0.5349\n",
            "    6. F0711                          | Corr: 0.5341\n",
            "    7. Acordar                        | Corr: 0.5263\n",
            "    8. F1109                          | Corr: 0.5226\n",
            "    9. F0710                          | Corr: 0.5146\n",
            "   10. F0707                          | Corr: 0.5088\n",
            "\n",
            "================================================================================\n",
            "ETAPA 9: CRIAÇÃO DOS DATAFRAMES FINAIS\n",
            "================================================================================\n",
            "✅ DataFrame NÃO-NORMALIZADO: (173, 57)\n",
            "🔢 Numéricas a normalizar: 25\n",
            "📝 Categóricas (preservadas): 29\n",
            "✅ Normalização concluída!\n",
            "✅ DataFrame NORMALIZADO: (173, 57)\n",
            "\n",
            "================================================================================\n",
            "ETAPA 10: EXPORTAÇÃO\n",
            "================================================================================\n",
            "✅ Arquivo 'Dados_Otimizados_V4.xlsx' criado!\n",
            "\n",
            "================================================================================\n",
            "🎉 FASE 2 OTIMIZADA CONCLUÍDA!\n",
            "================================================================================\n",
            "\n",
            "📊 RESUMO:\n",
            "   Jogadores: 173\n",
            "   Features: 54\n",
            "   Targets: 3\n",
            "\n",
            "🔧 MELHORIAS APLICADAS:\n",
            "   ✅ BOOL convertidas para INT (0/1)\n",
            "   ✅ Clusterização REMOVIDA (não agregava valor)\n",
            "   ✅ Pipeline otimizado\n",
            "\n",
            "📁 ARQUIVO GERADO: Dados_Otimizados_V4.xlsx\n",
            "   Aba 1: Dados_Para_Analise\n",
            "   Aba 2: Dados_Para_Modelo ⭐ (usar este!)\n",
            "   Aba 3: Resumo_Estatistico\n",
            "   Aba 4: Correlacoes\n",
            "\n",
            "🚀 PRÓXIMO PASSO: FASE 3 OTIMIZADA\n",
            "   Use: Dados_Para_Modelo\n"
          ]
        }
      ],
      "source": [
        "# ═══════════════════════════════════════════════════════════════════\n",
        "# FASE 2 OTIMIZADA: PIPELINE COM MELHORIAS APLICADAS\n",
        "# 🔧 CORREÇÕES IMPLEMENTADAS:\n",
        "#    ✅ Conversão BOOL → INT (problema crítico resolvido!)\n",
        "#    ✅ Remoção de features de cluster (não agregavam valor)\n",
        "#    ✅ Código otimizado e mais rápido\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "# CÉLULA 1: INSTALAÇÃO\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "!pip install xlsxwriter openpyxl scikit-learn -q\n",
        "print(\"✅ Bibliotecas instaladas!\")\n",
        "\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "# CÉLULA 2: IMPORTS\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "import pandas as pd\n",
        "import numpy as np\n",
        "from sklearn.impute import SimpleImputer\n",
        "from sklearn.preprocessing import StandardScaler\n",
        "from datetime import datetime\n",
        "import warnings\n",
        "warnings.filterwarnings('ignore')\n",
        "\n",
        "print(\"=\" * 80)\n",
        "print(\"     FASE 2 OTIMIZADA: LIMPEZA E PREPARAÇÃO (VERSÃO MELHORADA)\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "# CÉLULA 3: DEFINIÇÕES\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "COLUNAS_CATEGORICAS = [\n",
        "    'Cor0202', 'Cor0204', 'Cor0206', 'Cor0208', 'Cor0209Outro',\n",
        "    'P01', 'P02', 'P03', 'P04', 'P05', 'P07', 'P08', 'P09', 'P10',\n",
        "    'P12', 'P13', 'P15', 'P12_1', 'P02_1', 'P03_1', 'P09_1'\n",
        "]\n",
        "\n",
        "COLUNAS_TARGETS = ['Target1', 'Target2', 'Target3']\n",
        "\n",
        "COLUNAS_IGNORAR = [\n",
        "    'Código de Acesso', 'Data/Hora Último',\n",
        "    'L0210 (não likert)',\n",
        "    'F0299 - Explicação Tempo', 'T0499 - Explicação Tempo',\n",
        "    'PTempoTotalExpl', 'T1199Expl', 'T1205Expl', 'T1210Expl',\n",
        "    'TempoTotalExpl'\n",
        "]\n",
        "\n",
        "print(f\"📋 Categóricas: {len(COLUNAS_CATEGORICAS)} | Targets: {len(COLUNAS_TARGETS)}\")\n",
        "\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "# CÉLULA 4: CARREGAR DADOS\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 0: CARREGANDO DADOS\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "df = pd.read_excel('JogadoresV1.xlsx')\n",
        "print(f\"✅ Carregado: {df.shape[0]} linhas, {df.shape[1]} colunas\")\n",
        "\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "# CÉLULA 5: TRATAMENTO F0103 (vírgula → ponto)\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "if 'F0103' in df.columns and df['F0103'].dtype == 'object':\n",
        "    print(\"\\n🔧 Convertendo F0103 (vírgula → ponto)\")\n",
        "    df['F0103'] = df['F0103'].str.replace(',', '.').astype(float)\n",
        "    print(\"   ✅ Convertido!\")\n",
        "\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "# CÉLULA 6: REMOÇÃO DE NEGATIVOS (TODOS!)\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 1: REMOÇÃO DE NEGATIVOS → NaN\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "colunas_numericas = df.select_dtypes(include=[np.number]).columns.tolist()\n",
        "colunas_numericas = [col for col in colunas_numericas if col not in COLUNAS_TARGETS]\n",
        "\n",
        "contador = 0\n",
        "for col in colunas_numericas:\n",
        "    negativos = (df[col] < 0).sum()\n",
        "    if negativos > 0:\n",
        "        df.loc[df[col] < 0, col] = np.nan\n",
        "        contador += negativos\n",
        "\n",
        "print(f\"✅ {contador} negativos convertidos → NaN\")\n",
        "\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "# CÉLULA 7: REMOÇÃO DE COLUNAS COM MUITO MISSING\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 2: ANÁLISE DE MISSING\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "missing_info = pd.DataFrame({\n",
        "    'Coluna': df.columns,\n",
        "    'Missing': df.isna().sum(),\n",
        "    'Percentual': (df.isna().sum() / len(df) * 100).round(2)\n",
        "})\n",
        "missing_info = missing_info[missing_info['Missing'] > 0].sort_values('Percentual', ascending=False)\n",
        "\n",
        "threshold = 70\n",
        "colunas_remover = missing_info[missing_info['Percentual'] > threshold]['Coluna'].tolist()\n",
        "\n",
        "if colunas_remover:\n",
        "    print(f\"🗑️  Removendo {len(colunas_remover)} colunas (>{threshold}% missing)\")\n",
        "    df = df.drop(columns=colunas_remover)\n",
        "\n",
        "print(f\"✅ Shape: {df.shape}\")\n",
        "\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "# CÉLULA 8: REMOÇÃO DE JOGADORES SEM TARGETS\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 3: REMOÇÃO DE JOGADORES SEM TARGETS\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "antes = len(df)\n",
        "df = df.dropna(subset=COLUNAS_TARGETS, how='all')\n",
        "depois = len(df)\n",
        "\n",
        "print(f\"✅ Jogadores mantidos: {depois} (removidos: {antes-depois})\")\n",
        "\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "# CÉLULA 9: IMPUTAÇÃO DE VALORES FALTANTES\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 4: IMPUTAÇÃO\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "# Numéricas: MEDIANA\n",
        "colunas_num_imputar = [\n",
        "    col for col in df.select_dtypes(include=[np.number]).columns\n",
        "    if col not in COLUNAS_TARGETS and col not in COLUNAS_IGNORAR\n",
        "]\n",
        "\n",
        "if colunas_num_imputar:\n",
        "    imputer_num = SimpleImputer(strategy='median')\n",
        "    df[colunas_num_imputar] = imputer_num.fit_transform(df[colunas_num_imputar])\n",
        "    print(f\"✅ {len(colunas_num_imputar)} numéricas imputadas (mediana)\")\n",
        "\n",
        "# Categóricas: MODA\n",
        "colunas_cat_imputar = [col for col in COLUNAS_CATEGORICAS if col in df.columns]\n",
        "\n",
        "if colunas_cat_imputar:\n",
        "    imputer_cat = SimpleImputer(strategy='most_frequent')\n",
        "    df[colunas_cat_imputar] = imputer_cat.fit_transform(df[colunas_cat_imputar])\n",
        "    print(f\"✅ {len(colunas_cat_imputar)} categóricas imputadas (moda)\")\n",
        "\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "# CÉLULA 10: TRATAMENTO DE OUTLIERS (IQR + MEDIANA)\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 5: TRATAMENTO DE OUTLIERS\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "colunas_outliers = [\n",
        "    col for col in colunas_num_imputar\n",
        "    if col not in ['QtdHorasSono', 'QtdHorasDormi', 'Acordar']\n",
        "]\n",
        "\n",
        "outliers_tratados = 0\n",
        "for col in colunas_outliers:\n",
        "    Q1 = df[col].quantile(0.25)\n",
        "    Q3 = df[col].quantile(0.75)\n",
        "    IQR = Q3 - Q1\n",
        "\n",
        "    limite_inf = Q1 - 1.5 * IQR\n",
        "    limite_sup = Q3 + 1.5 * IQR\n",
        "\n",
        "    outliers_mask = (df[col] < limite_inf) | (df[col] > limite_sup)\n",
        "    n_outliers = outliers_mask.sum()\n",
        "\n",
        "    if n_outliers > 0:\n",
        "        mediana = df[col].median()\n",
        "        df.loc[outliers_mask, col] = mediana\n",
        "        outliers_tratados += n_outliers\n",
        "\n",
        "print(f\"✅ {outliers_tratados} outliers tratados (substituídos por mediana)\")\n",
        "\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "# CÉLULA 11: ONE-HOT ENCODING\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 6: ONE-HOT ENCODING\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "colunas_cat_presentes = [col for col in COLUNAS_CATEGORICAS if col in df.columns]\n",
        "\n",
        "if colunas_cat_presentes:\n",
        "    colunas_antes = df.shape[1]\n",
        "    df = pd.get_dummies(df, columns=colunas_cat_presentes, prefix=colunas_cat_presentes, drop_first=False)\n",
        "    colunas_depois = df.shape[1]\n",
        "\n",
        "    print(f\"✅ One-Hot concluído: {colunas_antes} → {colunas_depois} colunas\")\n",
        "\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "# CÉLULA 12: FEATURE ENGINEERING (Agregações)\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 7: FEATURE ENGINEERING\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "# Agregação F11*\n",
        "f11_cols = [c for c in df.columns if c.startswith('F11') and pd.api.types.is_numeric_dtype(df[c])]\n",
        "if len(f11_cols) > 2:\n",
        "    df['F11_mean'] = df[f11_cols].mean(axis=1)\n",
        "    print(f\"✅ F11_mean criada ({len(f11_cols)} colunas)\")\n",
        "\n",
        "# Agregação F07*\n",
        "f07_cols = [c for c in df.columns if c.startswith('F07') and pd.api.types.is_numeric_dtype(df[c])]\n",
        "if len(f07_cols) > 2:\n",
        "    df['F07_mean'] = df[f07_cols].mean(axis=1)\n",
        "    print(f\"✅ F07_mean criada ({len(f07_cols)} colunas)\")\n",
        "\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "# CÉLULA 13: 🔧 CORREÇÃO 1 - CONVERTER BOOL → INT\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"🔧 CORREÇÃO 1: CONVERSÃO BOOL → INT\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "bool_cols = df.select_dtypes(include=['bool']).columns.tolist()\n",
        "\n",
        "if bool_cols:\n",
        "    print(f\"📋 Convertendo {len(bool_cols)} colunas booleanas...\")\n",
        "    df[bool_cols] = df[bool_cols].astype(int)\n",
        "    print(f\"✅ VERDADEIRO/FALSO → 1/0\")\n",
        "    print(f\"   Exemplo: {bool_cols[:3]}\")\n",
        "else:\n",
        "    print(\"ℹ️  Nenhuma coluna booleana encontrada\")\n",
        "\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "# CÉLULA 14: FEATURE SELECTION POR CORRELAÇÃO\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 8: FEATURE SELECTION\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "features_numericas_finais = [\n",
        "    col for col in df.columns\n",
        "    if col not in COLUNAS_TARGETS\n",
        "    and col not in COLUNAS_IGNORAR\n",
        "    and pd.api.types.is_numeric_dtype(df[col])\n",
        "]\n",
        "\n",
        "print(f\"📊 Features disponíveis: {len(features_numericas_finais)}\")\n",
        "\n",
        "corr_t1 = df[features_numericas_finais].corrwith(df['Target1']).abs()\n",
        "corr_t2 = df[features_numericas_finais].corrwith(df['Target2']).abs()\n",
        "corr_t3 = df[features_numericas_finais].corrwith(df['Target3']).abs()\n",
        "\n",
        "corr_mean = (corr_t1 + corr_t2 + corr_t3) / 3\n",
        "\n",
        "threshold = 0.20\n",
        "features_selecionadas = corr_mean[corr_mean > threshold].index.tolist()\n",
        "\n",
        "print(f\"✅ Features mantidas: {len(features_selecionadas)} (threshold={threshold})\")\n",
        "print(f\"✅ Features removidas: {len(features_numericas_finais) - len(features_selecionadas)}\")\n",
        "\n",
        "# Top 10\n",
        "print(f\"\\n🏆 TOP 10 FEATURES:\")\n",
        "top10 = corr_mean.sort_values(ascending=False).head(10)\n",
        "for idx, (feat, corr) in enumerate(top10.items(), 1):\n",
        "    print(f\"   {idx:2d}. {feat:30s} | Corr: {corr:.4f}\")\n",
        "\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "# CÉLULA 15: CRIAR DATAFRAMES FINAIS\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 9: CRIAÇÃO DOS DATAFRAMES FINAIS\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "df_final_nao_normalizado = df[features_selecionadas + COLUNAS_TARGETS].copy()\n",
        "print(f\"✅ DataFrame NÃO-NORMALIZADO: {df_final_nao_normalizado.shape}\")\n",
        "\n",
        "df_final_normalizado = df_final_nao_normalizado.copy()\n",
        "\n",
        "# Identificar categóricas (One-Hot) para NÃO normalizar\n",
        "features_cat_onehot = [\n",
        "    col for col in features_selecionadas\n",
        "    if any(cat in col for cat in COLUNAS_CATEGORICAS)\n",
        "]\n",
        "\n",
        "features_numericas_normalizar = [\n",
        "    col for col in features_selecionadas\n",
        "    if col not in features_cat_onehot\n",
        "]\n",
        "\n",
        "print(f\"🔢 Numéricas a normalizar: {len(features_numericas_normalizar)}\")\n",
        "print(f\"📝 Categóricas (preservadas): {len(features_cat_onehot)}\")\n",
        "\n",
        "if features_numericas_normalizar:\n",
        "    scaler = StandardScaler()\n",
        "    df_final_normalizado[features_numericas_normalizar] = scaler.fit_transform(\n",
        "        df_final_normalizado[features_numericas_normalizar]\n",
        "    )\n",
        "    print(f\"✅ Normalização concluída!\")\n",
        "\n",
        "print(f\"✅ DataFrame NORMALIZADO: {df_final_normalizado.shape}\")\n",
        "\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "# CÉLULA 16: EXPORTAR PARA EXCEL\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 10: EXPORTAÇÃO\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "output_file = 'Dados_Otimizados_V4.xlsx'\n",
        "\n",
        "writer = pd.ExcelWriter(output_file, engine='xlsxwriter')\n",
        "workbook = writer.book\n",
        "\n",
        "header_format = workbook.add_format({\n",
        "    'bold': True, 'text_wrap': True, 'valign': 'vcenter',\n",
        "    'align': 'center', 'fg_color': '#1F4E78',\n",
        "    'font_color': 'white', 'border': 1\n",
        "})\n",
        "\n",
        "title_format = workbook.add_format({\n",
        "    'bold': True, 'font_size': 16,\n",
        "    'fg_color': '#4472C4', 'font_color': 'white',\n",
        "    'align': 'center', 'valign': 'vcenter', 'border': 2\n",
        "})\n",
        "\n",
        "# Aba 1: Dados não-normalizados\n",
        "df_final_nao_normalizado.to_excel(writer, sheet_name='Dados_Para_Analise', index=False, startrow=2)\n",
        "worksheet1 = writer.sheets['Dados_Para_Analise']\n",
        "worksheet1.merge_range('A1:Z1', '📋 DADOS LIMPOS - Versão Otimizada', title_format)\n",
        "worksheet1.freeze_panes(3, 0)\n",
        "\n",
        "# Aba 2: Dados normalizados\n",
        "df_final_normalizado.to_excel(writer, sheet_name='Dados_Para_Modelo', index=False, startrow=2)\n",
        "worksheet2 = writer.sheets['Dados_Para_Modelo']\n",
        "worksheet2.merge_range('A1:Z1', '📊 DADOS NORMALIZADOS - Para ML', title_format)\n",
        "worksheet2.freeze_panes(3, 0)\n",
        "\n",
        "# Aba 3: Resumo estatístico\n",
        "summary = df_final_nao_normalizado[COLUNAS_TARGETS].describe().T\n",
        "summary.to_excel(writer, sheet_name='Resumo_Estatistico', startrow=2)\n",
        "worksheet3 = writer.sheets['Resumo_Estatistico']\n",
        "worksheet3.merge_range('A1:I1', '📊 RESUMO ESTATÍSTICO', title_format)\n",
        "\n",
        "# Aba 4: Correlações\n",
        "correlations_df = pd.DataFrame({\n",
        "    'Feature': corr_mean.index,\n",
        "    'Corr_Target1': corr_t1.values,\n",
        "    'Corr_Target2': corr_t2.values,\n",
        "    'Corr_Target3': corr_t3.values,\n",
        "    'Corr_Media': corr_mean.values,\n",
        "    'Mantida': ['✅' if f in features_selecionadas else '❌' for f in corr_mean.index]\n",
        "}).sort_values('Corr_Media', ascending=False)\n",
        "\n",
        "correlations_df.to_excel(writer, sheet_name='Correlacoes', index=False, startrow=2)\n",
        "worksheet4 = writer.sheets['Correlacoes']\n",
        "worksheet4.merge_range('A1:F1', '🔍 ANÁLISE DE CORRELAÇÕES', title_format)\n",
        "\n",
        "writer.close()\n",
        "\n",
        "print(f\"✅ Arquivo '{output_file}' criado!\")\n",
        "\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "# CÉLULA 17: RELATÓRIO FINAL\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"🎉 FASE 2 OTIMIZADA CONCLUÍDA!\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "print(f\"\\n📊 RESUMO:\")\n",
        "print(f\"   Jogadores: {len(df_final_nao_normalizado)}\")\n",
        "print(f\"   Features: {len(features_selecionadas)}\")\n",
        "print(f\"   Targets: {len(COLUNAS_TARGETS)}\")\n",
        "\n",
        "print(f\"\\n🔧 MELHORIAS APLICADAS:\")\n",
        "print(f\"   ✅ BOOL convertidas para INT (0/1)\")\n",
        "print(f\"   ✅ Clusterização REMOVIDA (não agregava valor)\")\n",
        "print(f\"   ✅ Pipeline otimizado\")\n",
        "\n",
        "print(f\"\\n📁 ARQUIVO GERADO: {output_file}\")\n",
        "print(f\"   Aba 1: Dados_Para_Analise\")\n",
        "print(f\"   Aba 2: Dados_Para_Modelo ⭐ (usar este!)\")\n",
        "print(f\"   Aba 3: Resumo_Estatistico\")\n",
        "print(f\"   Aba 4: Correlacoes\")\n",
        "\n",
        "print(f\"\\n🚀 PRÓXIMO PASSO: FASE 3 OTIMIZADA\")\n",
        "print(f\"   Use: Dados_Para_Modelo\")"
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "# ═══════════════════════════════════════════════════════════════════\n",
        "# FASE 3 COMPLETA: MODELAGEM AVANÇADA + VISUALIZAÇÕES DETALHADAS\n",
        "# 🔧 COMBINA O MELHOR DAS DUAS VERSÕES:\n",
        "#    ✅ 8 Algoritmos testados (incluindo LightGBM e CatBoost)\n",
        "#    ✅ Gráfico de Dispersão (Previsto vs. Real) para os melhores modelos\n",
        "#    ✅ Gráfico de Feature Importance para os melhores modelos\n",
        "#    ✅ Salva os modelos e gera um relatório final completo\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "# CÉLULA 1: INSTALAÇÃO DE BIBLIOTECAS\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "!pip install xgboost lightgbm catboost scikit-learn pandas matplotlib seaborn plotly -q\n",
        "print(\"✅ Bibliotecas instaladas com sucesso!\")\n",
        "\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "# CÉLULA 2: IMPORTAÇÃO DE BIBLIOTECAS\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "import pandas as pd\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "import seaborn as sns\n",
        "import warnings\n",
        "from sklearn.model_selection import train_test_split, cross_val_score\n",
        "from sklearn.linear_model import LinearRegression, Ridge\n",
        "from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor\n",
        "from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score\n",
        "import xgboost as xgb\n",
        "import lightgbm as lgb\n",
        "from catboost import CatBoostRegressor\n",
        "import pickle\n",
        "\n",
        "warnings.filterwarnings('ignore')\n",
        "sns.set_style('whitegrid')\n",
        "\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"     FASE 3 COMPLETA: MODELAGEM AVANÇADA + VISUALIZAÇÕES\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "# CÉLULA 3: CARREGAMENTO DOS DADOS\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 1: CARREGANDO DADOS LIMPOS\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "# MUDE O NOME DO ARQUIVO AQUI SE NECESSÁRIO:\n",
        "df = pd.read_excel('Dados_para_modelo.xlsx')\n",
        "\n",
        "print(f\"✅ Dados carregados com sucesso. Shape: {df.shape}\")\n",
        "print(f\"   Total de Jogadores: {len(df)}\")\n",
        "print(f\"   Total de Colunas: {len(df.columns)}\")\n",
        "\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "# CÉLULA 4: SEPARAÇÃO DE FEATURES (X) E TARGETS (y)\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 2: SEPARAÇÃO DE FEATURES E TARGETS\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "targets = ['Target1', 'Target2', 'Target3']\n",
        "X = df.drop(columns=targets)\n",
        "y1 = df['Target1']\n",
        "y2 = df['Target2']\n",
        "y3 = df['Target3']\n",
        "\n",
        "print(f\"✅ Features (X) separadas. Total de features: {X.shape[1]}\")\n",
        "print(f\"✅ Targets (y1, y2, y3) separados.\")\n",
        "\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "# CÉLULA 5: DIVISÃO EM DADOS DE TREINO E TESTE (80/20)\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 3: DIVISÃO TREINO/TESTE\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "X_train, X_test, y1_train, y1_test = train_test_split(X, y1, test_size=0.2, random_state=42)\n",
        "_, _, y2_train, y2_test = train_test_split(X, y2, test_size=0.2, random_state=42)\n",
        "_, _, y3_train, y3_test = train_test_split(X, y3, test_size=0.2, random_state=42)\n",
        "\n",
        "print(f\"✅ Dados divididos em 80% treino e 20% teste.\")\n",
        "print(f\"   Tamanho do treino: {len(X_train)} jogadores\")\n",
        "print(f\"   Tamanho do teste:  {len(X_test)} jogadores\")\n",
        "\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "# CÉLULA 6: DEFINIÇÃO DOS MODELOS A SEREM TESTADOS\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 4: DEFINIÇÃO DOS MODELOS\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "modelos = {\n",
        "    'Linear Regression': LinearRegression(),\n",
        "    'Ridge': Ridge(alpha=1.0),\n",
        "    'Random Forest': RandomForestRegressor(n_estimators=100, max_depth=10, random_state=42, n_jobs=-1),\n",
        "    'Gradient Boosting': GradientBoostingRegressor(n_estimators=100, max_depth=5, random_state=42),\n",
        "    'XGBoost': xgb.XGBRegressor(n_estimators=100, max_depth=6, learning_rate=0.1, random_state=42, n_jobs=-1),\n",
        "    'LightGBM': lgb.LGBMRegressor(n_estimators=100, max_depth=6, learning_rate=0.1, random_state=42, n_jobs=-1, verbose=-1),\n",
        "    'CatBoost': CatBoostRegressor(iterations=100, depth=6, learning_rate=0.1, random_state=42, verbose=False)\n",
        "}\n",
        "print(f\"✅ {len(modelos)} modelos definidos para teste.\")\n",
        "\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "# CÉLULA 7: FUNÇÃO DE TREINAMENTO E AVALIAÇÃO\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "def treinar_avaliar_modelo(modelo, X_train, X_test, y_train, y_test):\n",
        "    \"\"\"Função para treinar, prever e avaliar um modelo, retornando as métricas e o modelo treinado.\"\"\"\n",
        "    modelo.fit(X_train, y_train)\n",
        "    y_pred = modelo.predict(X_test)\n",
        "    r2 = r2_score(y_test, y_pred)\n",
        "    rmse = np.sqrt(mean_squared_error(y_test, y_pred))\n",
        "    mae = mean_absolute_error(y_test, y_pred)\n",
        "    return {'modelo': modelo, 'y_pred': y_pred, 'r2': r2, 'rmse': rmse, 'mae': mae}\n",
        "\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "# CÉLULA 8: TREINAMENTO E AVALIAÇÃO DE TODOS OS MODELOS\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 5: TREINAMENTO E AVALIAÇÃO DOS MODELOS\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "# --- Target 1 ---\n",
        "resultados_t1 = {}\n",
        "for nome, modelo in modelos.items():\n",
        "    resultados_t1[nome] = treinar_avaliar_modelo(type(modelo)(**modelo.get_params()), X_train, X_test, y1_train, y1_test)\n",
        "melhor_t1 = max(resultados_t1.items(), key=lambda x: x[1]['r2'])\n",
        "print(f\"🎯 Target 1 | Melhor Modelo: {melhor_t1[0]:<20} | R² = {melhor_t1[1]['r2']:.4f}\")\n",
        "\n",
        "# --- Target 2 ---\n",
        "resultados_t2 = {}\n",
        "for nome, modelo in modelos.items():\n",
        "    resultados_t2[nome] = treinar_avaliar_modelo(type(modelo)(**modelo.get_params()), X_train, X_test, y2_train, y2_test)\n",
        "melhor_t2 = max(resultados_t2.items(), key=lambda x: x[1]['r2'])\n",
        "print(f\"🎯 Target 2 | Melhor Modelo: {melhor_t2[0]:<20} | R² = {melhor_t2[1]['r2']:.4f}\")\n",
        "\n",
        "# --- Target 3 ---\n",
        "resultados_t3 = {}\n",
        "for nome, modelo in modelos.items():\n",
        "    resultados_t3[nome] = treinar_avaliar_modelo(type(modelo)(**modelo.get_params()), X_train, X_test, y3_train, y3_test)\n",
        "melhor_t3 = max(resultados_t3.items(), key=lambda x: x[1]['r2'])\n",
        "print(f\"🎯 Target 3 | Melhor Modelo: {melhor_t3[0]:<20} | R² = {melhor_t3[1]['r2']:.4f}\")\n",
        "\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "# CÉLULA 9: VISUALIZAÇÃO 1 - PREVISTO vs. REAL (Gráfico de Dispersão)\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 6: VISUALIZAÇÃO - PREVISTO vs. REAL\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "fig, axes = plt.subplots(1, 3, figsize=(18, 5))\n",
        "fig.suptitle('Análise de Previsão vs. Valor Real para os Melhores Modelos', fontsize=16, fontweight='bold')\n",
        "\n",
        "# Gráfico para Target 1\n",
        "y1_pred = melhor_t1[1]['y_pred']\n",
        "axes[0].scatter(y1_test, y1_pred, alpha=0.7, color='blue', edgecolors='k')\n",
        "axes[0].plot([y1_test.min(), y1_test.max()], [y1_test.min(), y1_test.max()], 'r--', lw=2, label='Linha Perfeita')\n",
        "axes[0].set_xlabel('Valores Reais', fontsize=12)\n",
        "axes[0].set_ylabel('Valores Previstos', fontsize=12)\n",
        "axes[0].set_title(f'Target 1 - {melhor_t1[0]}\\nR²={melhor_t1[1][\"r2\"]:.3f}', fontsize=14)\n",
        "axes[0].legend()\n",
        "axes[0].grid(True)\n",
        "\n",
        "# Gráfico para Target 2\n",
        "y2_pred = melhor_t2[1]['y_pred']\n",
        "axes[1].scatter(y2_test, y2_pred, alpha=0.7, color='green', edgecolors='k')\n",
        "axes[1].plot([y2_test.min(), y2_test.max()], [y2_test.min(), y2_test.max()], 'r--', lw=2, label='Linha Perfeita')\n",
        "axes[1].set_xlabel('Valores Reais', fontsize=12)\n",
        "axes[1].set_ylabel('Valores Previstos', fontsize=12)\n",
        "axes[1].set_title(f'Target 2 - {melhor_t2[0]}\\nR²={melhor_t2[1][\"r2\"]:.3f}', fontsize=14)\n",
        "axes[1].legend()\n",
        "axes[1].grid(True)\n",
        "\n",
        "# Gráfico para Target 3\n",
        "y3_pred = melhor_t3[1]['y_pred']\n",
        "axes[2].scatter(y3_test, y3_pred, alpha=0.7, color='purple', edgecolors='k')\n",
        "axes[2].plot([y3_test.min(), y3_test.max()], [y3_test.min(), y3_test.max()], 'r--', lw=2, label='Linha Perfeita')\n",
        "axes[2].set_xlabel('Valores Reais', fontsize=12)\n",
        "axes[2].set_ylabel('Valores Previstos', fontsize=12)\n",
        "axes[2].set_title(f'Target 3 - {melhor_t3[0]}\\nR²={melhor_t3[1][\"r2\"]:.3f}', fontsize=14)\n",
        "axes[2].legend()\n",
        "axes[2].grid(True)\n",
        "\n",
        "plt.tight_layout(rect=[0, 0, 1, 0.96])\n",
        "plt.savefig('grafico_dispersao_previsto_vs_real.png', dpi=300, bbox_inches='tight')\n",
        "print(\"✅ Gráfico de Dispersão (Previsto vs. Real) salvo como 'grafico_dispersao_previsto_vs_real.png'\")\n",
        "\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "# CÉLULA 10: VISUALIZAÇÃO 2 - IMPORTÂNCIA DAS FEATURES\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 7: VISUALIZAÇÃO - IMPORTÂNCIA DAS FEATURES\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "def plotar_importancia(melhor_modelo_info, target_name, feature_names, ax):\n",
        "    \"\"\"Função auxiliar para plotar a importância das features em um eixo do matplotlib.\"\"\"\n",
        "    nome_modelo = melhor_modelo_info[0]\n",
        "    modelo = melhor_modelo_info[1]['modelo']\n",
        "\n",
        "    if hasattr(modelo, 'feature_importances_'):\n",
        "        importances = modelo.feature_importances_\n",
        "    else: # CatBoost\n",
        "        importances = modelo.get_feature_importance()\n",
        "\n",
        "    df_importances = pd.DataFrame({'feature': feature_names, 'importance': importances}).sort_values('importance', ascending=True).tail(15)\n",
        "\n",
        "    ax.barh(df_importances['feature'], df_importances['importance'], color='darkcyan')\n",
        "    ax.set_title(f'Top 15 Features - {target_name}\\n(Modelo: {nome_modelo})', fontsize=14)\n",
        "    ax.set_xlabel('Importância')\n",
        "\n",
        "fig, axes = plt.subplots(1, 3, figsize=(20, 8))\n",
        "fig.suptitle('Análise de Importância das Features para os Melhores Modelos', fontsize=16, fontweight='bold')\n",
        "\n",
        "plotar_importancia(melhor_t1, 'Target 1', X.columns, axes[0])\n",
        "plotar_importancia(melhor_t2, 'Target 2', X.columns, axes[1])\n",
        "plotar_importancia(melhor_t3, 'Target 3', X.columns, axes[2])\n",
        "\n",
        "plt.tight_layout(rect=[0, 0, 1, 0.95])\n",
        "plt.savefig('grafico_feature_importance.png', dpi=300, bbox_inches='tight')\n",
        "print(\"✅ Gráfico de Importância das Features salvo como 'grafico_feature_importance.png'\")\n",
        "\n",
        "\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "# CÉLULA 11: SALVANDO OS MELHORES MODELOS\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"ETAPA 8: SALVANDO OS MELHORES MODELOS\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "with open('modelo_target1_final.pkl', 'wb') as f: pickle.dump(melhor_t1[1]['modelo'], f)\n",
        "print(f\"✅ Modelo para Target 1 ({melhor_t1[0]}) salvo como 'modelo_target1_final.pkl'\")\n",
        "\n",
        "with open('modelo_target2_final.pkl', 'wb') as f: pickle.dump(melhor_t2[1]['modelo'], f)\n",
        "print(f\"✅ Modelo para Target 2 ({melhor_t2[0]}) salvo como 'modelo_target2_final.pkl'\")\n",
        "\n",
        "with open('modelo_target3_final.pkl', 'wb') as f: pickle.dump(melhor_t3[1]['modelo'], f)\n",
        "print(f\"✅ Modelo para Target 3 ({melhor_t3[0]}) salvo como 'modelo_target3_final.pkl'\")\n",
        "\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "# CÉLULA 12: RELATÓRIO FINAL\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "print(\"\\n\" + \"=\" * 80)\n",
        "print(\"🎉 FASE 3 COMPLETA - RELATÓRIO FINAL 🎉\")\n",
        "print(\"=\" * 80)\n",
        "\n",
        "print(\"\\n📊 RESUMO DOS MELHORES MODELOS:\\n\")\n",
        "\n",
        "print(f\"  TARGET 1\")\n",
        "print(f\"  - Melhor Modelo: {melhor_t1[0]}\")\n",
        "print(f\"  - R² (R-quadrado): {melhor_t1[1]['r2']:.4f}  (Explica ~{melhor_t1[1]['r2']:.1%} da variância)\")\n",
        "print(f\"  - RMSE (Erro Médio): {melhor_t1[1]['rmse']:.2f} pontos\")\n",
        "print(f\"  - MAE (Erro Absoluto Médio): {melhor_t1[1]['mae']:.2f} pontos\\n\")\n",
        "\n",
        "print(f\"  TARGET 2\")\n",
        "print(f\"  - Melhor Modelo: {melhor_t2[0]}\")\n",
        "print(f\"  - R² (R-quadrado): {melhor_t2[1]['r2']:.4f}  (Explica ~{melhor_t2[1]['r2']:.1%} da variância)\")\n",
        "print(f\"  - RMSE (Erro Médio): {melhor_t2[1]['rmse']:.2f} pontos\")\n",
        "print(f\"  - MAE (Erro Absoluto Médio): {melhor_t2[1]['mae']:.2f} pontos\\n\")\n",
        "\n",
        "print(f\"  TARGET 3\")\n",
        "print(f\"  - Melhor Modelo: {melhor_t3[0]}\")\n",
        "print(f\"  - R² (R-quadrado): {melhor_t3[1]['r2']:.4f}  (Explica ~{melhor_t3[1]['r2']:.1%} da variância)\")\n",
        "print(f\"  - RMSE (Erro Médio): {melhor_t3[1]['rmse']:.2f} pontos\")\n",
        "print(f\"  - MAE (Erro Absoluto Médio): {melhor_t3[1]['mae']:.2f} pontos\\n\")\n",
        "\n",
        "print(\"📁 ARQUIVOS GERADOS:\")\n",
        "print(\"  ✅ modelo_target1_final.pkl\")\n",
        "print(\"  ✅ modelo_target2_final.pkl\")\n",
        "print(\"  ✅ modelo_target3_final.pkl\")\n",
        "print(\"  ✅ grafico_dispersao_previsto_vs_real.png\")\n",
        "print(\"  ✅ grafico_feature_importance.png\")\n",
        "\n",
        "print(\"\\n🚀 PRÓXIMOS PASSOS:\")\n",
        "print(\"  1. Usar os arquivos '.pkl' salvos para carregar os modelos no seu backend (Node.js/FastAPI).\")\n",
        "print(\"  2. Criar as rotas da API que recebem novos dados de jogadores e usam os modelos para prever os targets.\")\n",
        "print(\"  3. Desenvolver o dashboard interativo que consome essa API e exibe os resultados e insights.\")\n",
        "print(\"  4. Preparar a apresentação de slides contando a história do projeto, dos dados aos resultados.\")\n",
        "\n",
        "print(\"\\n✨ Excelente trabalho! A etapa de modelagem e análise está concluída. ✨\")"
      ],
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 1000
        },
        "id": "qrrGV7ZrGYVu",
        "outputId": "f887f2ae-d192-4602-9d5d-bd8c4dd445b9"
      },
      "execution_count": null,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "✅ Bibliotecas instaladas com sucesso!\n",
            "\n",
            "================================================================================\n",
            "     FASE 3 COMPLETA: MODELAGEM AVANÇADA + VISUALIZAÇÕES\n",
            "================================================================================\n",
            "\n",
            "================================================================================\n",
            "ETAPA 1: CARREGANDO DADOS LIMPOS\n",
            "================================================================================\n",
            "✅ Dados carregados com sucesso. Shape: (173, 57)\n",
            "   Total de Jogadores: 173\n",
            "   Total de Colunas: 57\n",
            "\n",
            "================================================================================\n",
            "ETAPA 2: SEPARAÇÃO DE FEATURES E TARGETS\n",
            "================================================================================\n",
            "✅ Features (X) separadas. Total de features: 54\n",
            "✅ Targets (y1, y2, y3) separados.\n",
            "\n",
            "================================================================================\n",
            "ETAPA 3: DIVISÃO TREINO/TESTE\n",
            "================================================================================\n",
            "✅ Dados divididos em 80% treino e 20% teste.\n",
            "   Tamanho do treino: 138 jogadores\n",
            "   Tamanho do teste:  35 jogadores\n",
            "\n",
            "================================================================================\n",
            "ETAPA 4: DEFINIÇÃO DOS MODELOS\n",
            "================================================================================\n",
            "✅ 7 modelos definidos para teste.\n",
            "\n",
            "================================================================================\n",
            "ETAPA 5: TREINAMENTO E AVALIAÇÃO DOS MODELOS\n",
            "================================================================================\n",
            "🎯 Target 1 | Melhor Modelo: CatBoost             | R² = 0.5766\n",
            "🎯 Target 2 | Melhor Modelo: Random Forest        | R² = 0.4057\n",
            "🎯 Target 3 | Melhor Modelo: Random Forest        | R² = 0.4198\n",
            "\n",
            "================================================================================\n",
            "ETAPA 6: VISUALIZAÇÃO - PREVISTO vs. REAL\n",
            "================================================================================\n",
            "✅ Gráfico de Dispersão (Previsto vs. Real) salvo como 'grafico_dispersao_previsto_vs_real.png'\n",
            "\n",
            "================================================================================\n",
            "ETAPA 7: VISUALIZAÇÃO - IMPORTÂNCIA DAS FEATURES\n",
            "================================================================================\n",
            "✅ Gráfico de Importância das Features salvo como 'grafico_feature_importance.png'\n",
            "\n",
            "================================================================================\n",
            "ETAPA 8: SALVANDO OS MELHORES MODELOS\n",
            "================================================================================\n",
            "✅ Modelo para Target 1 (CatBoost) salvo como 'modelo_target1_final.pkl'\n",
            "✅ Modelo para Target 2 (Random Forest) salvo como 'modelo_target2_final.pkl'\n",
            "✅ Modelo para Target 3 (Random Forest) salvo como 'modelo_target3_final.pkl'\n",
            "\n",
            "================================================================================\n",
            "🎉 FASE 3 COMPLETA - RELATÓRIO FINAL 🎉\n",
            "================================================================================\n",
            "\n",
            "📊 RESUMO DOS MELHORES MODELOS:\n",
            "\n",
            "  TARGET 1\n",
            "  - Melhor Modelo: CatBoost\n",
            "  - R² (R-quadrado): 0.5766  (Explica ~57.7% da variância)\n",
            "  - RMSE (Erro Médio): 16.25 pontos\n",
            "  - MAE (Erro Absoluto Médio): 13.75 pontos\n",
            "\n",
            "  TARGET 2\n",
            "  - Melhor Modelo: Random Forest\n",
            "  - R² (R-quadrado): 0.4057  (Explica ~40.6% da variância)\n",
            "  - RMSE (Erro Médio): 22.05 pontos\n",
            "  - MAE (Erro Absoluto Médio): 18.98 pontos\n",
            "\n",
            "  TARGET 3\n",
            "  - Melhor Modelo: Random Forest\n",
            "  - R² (R-quadrado): 0.4198  (Explica ~42.0% da variância)\n",
            "  - RMSE (Erro Médio): 16.37 pontos\n",
            "  - MAE (Erro Absoluto Médio): 14.50 pontos\n",
            "\n",
            "📁 ARQUIVOS GERADOS:\n",
            "  ✅ modelo_target1_final.pkl\n",
            "  ✅ modelo_target2_final.pkl\n",
            "  ✅ modelo_target3_final.pkl\n",
            "  ✅ grafico_dispersao_previsto_vs_real.png\n",
            "  ✅ grafico_feature_importance.png\n",
            "\n",
            "🚀 PRÓXIMOS PASSOS:\n",
            "  1. Usar os arquivos '.pkl' salvos para carregar os modelos no seu backend (Node.js/FastAPI).\n",
            "  2. Criar as rotas da API que recebem novos dados de jogadores e usam os modelos para prever os targets.\n",
            "  3. Desenvolver o dashboard interativo que consome essa API e exibe os resultados e insights.\n",
            "  4. Preparar a apresentação de slides contando a história do projeto, dos dados aos resultados.\n",
            "\n",
            "✨ Excelente trabalho! A etapa de modelagem e análise está concluída. ✨\n"
          ]
        },
        {
          "output_type": "display_data",
          "data": {
            "text/plain": [
              "<Figure size 1800x500 with 3 Axes>"
            ],
            "image/png": "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lnZIy6xYvHgxbt++DV9fX7x79w7h4eGIi4uDkZERbGxs4OLigv79+0uGUHR2dsbu3buxcuVK3L59G3FxcShXrhw6dOiAkSNHYvbs2V88pqOjI44cOYJ9+/bh7NmzePLkCSIjI6Gvrw9ra2u4uLigT58+qFKlSrbOCZDPz2dqaip5AaBJkyYZ9pIpXrw4li1bBh8fHzx48AAfP35EeHg4EhISYGxsjAoVKqBx48bo37+/ZAiz3NalSxcsWbJEMmQhALi5uWW4fk6vw9cMHz4crVu3hre3N27evImgoCDEx8ejRIkS4u/Id999l6Nkc27Q0dGBu7u7JDHt7e2NoUOHiterffv2qFevHvbs2YMrV67g2bNniIqKgo6ODiwsLFCxYkXUrVsXrq6ukpdEXF1dsWXLFqxduxa+vr5ISUlBhQoV0L17dwwcOBCDBw/Ot/OcNGkSnJ2dsW3bNjx69AgA4ODggMGDB6Ndu3aSdfPr/pPXx2natCmOHz+Ov/76CxcvXsTz588RHR0NQ0ND2NraolGjRujbt6/S33Xbtm2hra2Ne/fu4cmTJwgLC8Pnz5/FYT4dHBzQvn17dO7cOU/mnMyqgnyPy4/fayD7bWBra4uFCxfCx8cHDx8+REhICMLDw5GcnAwTExNUrFgRLVu2RJ8+fVCiRImcNkeuyMlvq5ubG8qXLw8vLy/cu3cPiYmJsLOzg5ubG/r37//F2AGQvzh0/Phx/P333zh//jyePHmCiIgIaGlpoVSpUrCzs0Pt2rXRunVr1KxZM1/Oy93dHU5OTrh37x5evnyJ8PBw8TtWunRpODs74/vvv4eLi0uW6kNERESFi5aQX2OsEBEREREREeWy1q1bS3paZzT0KxERERERUVGg/lf1iIiIiIiIiIiIiIiIiChHmPQjIiIiIiIiIiIiIiIi0nBM+hERERERERERERERERFpOM7pR0RERERERERERERERKTh2NOPiIiIiIiIiIiIiIiISMMx6UdERERERERERERERESk4Zj0IyIiIiIiIiIiIiIiItJwTPoRERERERERERERERERaTgm/YiIiIiIiIiIiIiIiIg0HJN+RERERERERERERERERBqOST8iIiIiIiIiIiIiIiIiDcekHxEREREREREREREREZGGY9KPiIiIiIiIiIiIiIiISMMx6UdERERERERERERERESk4Zj0IyIiIiIiIiIiIiIiItJwTPoRERERERERERERERERaTgm/YiIiIiIiIiIiIiIiIg0HJN+RERERERERERERERERBqOST8iIiIiIiIiIiIiIiIiDcekHxEREREREREREREREZGGY9KPiIiIiIiIiIiIiIiISMMx6UdERERERERERERERESk4Zj0IyIiIiIiIiIiIiIiItJwTPoRERERERERERERERERaTgm/YiIiIiIiIiIiIiIiIg0HJN+RERERERERERERERERBqOST8iIiIiIiIiIiIiIiIiDcekHxEREREREREREREREZGGY9KPiIiIiIiIiIiIiIiISMMx6UdERERERERERERERESk4Zj0IyIiIiIiIiIiIiIiItJwTPoRERERERERERERERERaTgm/YiIiIiIiIiIiIiIiIg0HJN+RERERERERERERERERBqOST8iIiIiIiIiIiIiIiIiDcekHxEREREREREREREREZGGY9KPiIiIiIiIiIiIiIiISMMx6UdERERERERERERERESk4Zj0IyIiIiIiIiIiIiIiItJwTPoRERERERERERERERERaTgm/YiIiIiIiIiIiIiIiIg0HJN+RERERERERERERERERBqOST8iIiIiIiIq0G7cuAEHBwesWrVK3VUhIiIi0miMq4gKN111V4CIpBwcHLK0/uPHj/OoJrlr1apV8PT0xLZt29CgQQOVtwsNDcW+ffvg5+eHhw8fIigoCED+n3dSUhIOHTqEEydO4NGjR/j8+TMMDAxgZ2eHpk2bomfPnrC2ts7Wvt+8eYM2bdrAzc0NCxcuVFq+f/9+TJs2TVKmpaUFY2NjyGQy9OjRAz169MjWsfODg4MDXFxcsH37dnVXhYiI1IgxjtTt27dx+vRp3Lx5E0FBQYiJiYG1tTXatGmDESNGwMTEJA9rnVrvtAwNDVG+fHm0adMGw4YNg7GxcZ7WobAaMGAAbt68menyadOmYfDgwflXoRzK7neciIjyDuMqKV9fX+zatQt+fn74+PEjYmNjUaZMGTg6OmLo0KGoUaNGHtaacVVeYlxFlHVM+hEVMB4eHkplW7duRWRkZIbLCrunT59i2bJl0NLSgq2tLYoVK4bY2Nh8rUNQUBBGjRqFgIAAWFhYoHHjxihbtixiYmLw6NEjbNiwAZs2bcLRo0dha2ubZ/Vo1KgR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1aEAAAAXQl5VdeRVAADgfMirqo68CnAdFP0AVEpCQoI6deqk/Pz8X3zOM888o8jISOXk5NRiZLVv3LhxCgsLK/8TGRmpW2+9VXPmzFFhYaHV4QEAABdHXlWBvAoAAFwK8qoK5FUAJMnT6gAAuIe+fftq8+bN+uijj3T33Xefc7ygoED//Oc/1bNnTwUGBtZ+gLXM29tb06ZNkyTl5+fr448/1vz58/X9999r9uzZNfa6d911l+644w55e3vX2GsAAICaRV7ljLwKAABcLPIqZ+RVAJjpB6BSevXqpUaNGmndunXnPf7xxx/r9OnT6tu3by1HVuH06dO19lqenp666667dNddd+mBBx7Q0qVLFRMTow0bNujEiRM19roeHh7y8fGRzWarsdcAAAA1i7zKGXkVAAC4WORVzsirAFD0A1ApDRo00C233KIvvvhCWVlZ5xxfv369GjVqpF69eunkyZN66aWX1KdPH8XGxiouLk6PPvqo9uzZU6nX2rJli+6//37FxMTommuu0YgRI7R//36n57z++usKCwvTvn379Mwzz6hz5866//77y49/8MEH6t+/v6Kjo9WlSxeNGjVK//3vf53OcfDgQT3xxBPq0aOHoqKidN1112nUqFE6depUlfvHZrMpLi5OhmHohx9+cDr26aeflr+f2NhYDR8+XHv37nV6zp49ezRu3DjdeOONioqKUo8ePfTcc8+ds/TE+dZIT0tL09ChQ9W1a1dFR0erV69eeu6556r8HgAAQO0gr7ow8ioAAFBZ5FUXRl4F1D8s7wmg0vr06aP3339fH374oQYPHlzefvLkSf373//WHXfcoQYNGmjv3r366KOPdNttt6l169Y6ceKE/vKXv2jw4MHasGGDWrRo8YuvkZKSomHDhql169ZKTEzUmTNntGLFCg0aNEjvvfeeWrdu7fT8p556Sm3bttWoUaNkGIYkacGCBZozZ4569+6te+65R9nZ2VqxYoUeeOABrV27Vo0bN1ZRUZGGDh2qoqIiDR48WEFBQTp69Kg++eQT5eXlyd/fv8r98+OPP0qSGjduXN62du1ajRs3Tj179lRSUpIKCgq0atUq3X///Xr//ffL309KSop++OEH9e/fX82aNdPevXu1evVq7du3T6tXr/7FkVJZWVkaOnSoAgMDNXz4cDVu3FiHDx/Wpk2bqhw/AACoPeRV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\n"
          },
          "metadata": {}
        },
        {
          "output_type": "display_data",
          "data": {
            "text/plain": [
              "<Figure size 2000x800 with 3 Axes>"
            ],
            "image/png": "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tmzKmTOnihcvrrJly+rdd9+Vh4dHkuqVWBEREdqwYYPWrVunY8eO6c6dO3JwcFCBAgVUq1Ytde7cWS+//LLFfkm5PnGveYzBgwebfa/GvBee9X0rmX8e8ufPry1bthivre3/3nvvadKkSdq5c6du3bqlpk2basyYMcY2N27c0MKFC7Vjxw5duHBBDx48kIuLi0qWLKnGjRvrvffek6Ojo0Udkvu6WvueGDp0qH777Tf9+eefunbtmrJnz65atWqpV69eFp+DO3fuaP78+Tpx4oTOnTunkJAQhYaGyt7eXjly5FCJEiXk4+OjJk2aKFMm89nlEtNuz3OehErK96yU8p81V1dXPXnyRI8fP9aePXt06tQpeXp6SooeFefy5cuSpDx58uj69evPPN7jx4+1YsUKbd68WSdOnFBoaKgyZ86swoULy9vbW+3bt1eOHDmSVNbYQkJC9Ntvv+mvv/7S9evX5erqqjp16qhfv37KkyeP1X3Onj2rBQsWaO/evQoKCtKTJ0+ULVs2FS9eXG+99ZZatmxp8Tt5+fJlvfXWW8brqlWr6rffftPUqVO1ceNGXblyRR4eHmaf2aS2wdWrVzV79mwjfnr48KFeeuklubm5qXDhwipbtqzefvttlSpVKsntFnMd7927p5UrV6p9+/aSpODgYK1bt87YLnfu3Lpx40a8x4qKitLmzZu1Zs0aHT16VLdv35adnZ1y5cqlChUqqEWLFnr99det7hsREaG5c+dq2bJlunDhgrJmzaoqVaqoZ8+eCa7LiRMntGDBAu3fv19Xr15VWFiYcubMqQoVKqh169aqWbNmgo+VXPVat26d1qxZo+PHj+v27dsymUxyc3NT7ty5VbJkSZUpU0atWrWSvb19ksoGAAAAcyTGAQAAkllMj/AYWbNmVefOnbVlyxYdPnxYUnQSLfaN5PgMHDhQK1euNFsWGBiogQMHKiQkRB988IHZut9//12nT5+2OE5ISIgOHTqkQ4cOaf78+Zo5c6ZKliyZ+ApaERYWpg4dOigwMNBseXh4uB4+fKgrV67owIED2r9/v0VifN68eRo9erTFfOzBwcHaunWrtm7dqjp16mj8+PFydnZOcJnu37+vzp07KyAgwOyYq1at0ubNm9WkSZN494+IiNCwYcOszgEck7hdtWqV/ve//6lv374JLldSjB49Wps3bzZeP3r0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NHr0aH344Yfq3r27GjRooPz588vf31979+412i6p269atUqLFi1SlSpVjKd3z5w5o+3bt8vNzc2sbatXr65NmzapT58+ql27tjJnzqwSJUrI29vb2Gbnzp2SlOD3KAAAGRlxYOrFgfH56KOPtGjRIs2cOVMdO3ZU9uzZ1aFDB+3YsUPt2rVTo0aN5OTkpL179+r69euqWrWq1R5RiVG4cGH17NlTEyZMMOptb2+vP//8U15eXlZ7dH311Vdq166dhg0bJl9fX7366qs6ffq0tmzZopw5c+qrr756rjKlpKRc5/jUqVNHPXv21K+//qr69eurdu3aypcvn0JCQnTx4kUdOHBA/fr1U7FixfT48WO1bdtWRYoUUZkyZZQ3b149fPhQW7du1c2bN9W1a1fjodGiRYsqd+7cWrdunZycnJQnTx7Z2dmpY8eOxjCkDx480OHDh/X6668ra9asKdJeAAAkN+JO4k7iTuJOIClIjANIdu+//74mT56s1atXJygwTaxGjRrJw8NDU6ZM0V9//aVHjx4pf/786tmzpz766COzHsFS9BNz2bJl06+//qoVK1YoW7Zs8vb21oABA6w+Tefk5KTff/9dS5cu1cqVK/Xnn38qLCxMuXLlUrFixdSmTZsEDfXSpUsXFSpUSDNnztTq1asVHh6uIkWKaNCgQerYseNT53lJjCxZsuinn35Sy5YttWzZMvn7++uff/6RJOXNm1c+Pj5q1aqVMde3vb29pkyZoh9//FH//POPjh49qsKFC+v//u//VKdOHauJ8Z49e+ru3bvy9fXVgQMHFBkZqV69elkkxidOnGi8dnJy0ssvv6y2bduqe/fuRk/1GJUrV9aiRYs0adIk7dy5U/fv31fu3LnVqVMn/e9//7OYYyYx2zdp0kRPnjyRv7+/jhw5orCwMKMs3bp1MytLq1atFBQUpPXr12vatGnGE7+xE+Nr1qxRyZIljTYEAABPRxwYLTXiwPjkypVLbdu21fTp0zVjxgz17dtXb775psaPH68pU6Zo9erVypIli6pXr65JkyZp0qRJyXLeXr16KU+ePJo5c6YWLlwod3d3+fj4qG/fvipfvrzF9kWLFtWyZcs0ceJE/fPPP9q2bZty5Mih5s2bq1evXhZzKKY3yX2d+/btqypVqmj27NnavXu37t27Jzc3NxUoUEC9evXSO++8I0ly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O1tpaWnq1q2bOnbsqJkzZ2r37t3KycmRJDVo0KDWvj/77DOlpKR4Il0AAAC40alTp7R27Vo9/PDD+sMf/qB33nnH5flNmzYpJSVF0dHRiouL08iRI53P/fjjj5owYYL+4z/+Q507d9YTTzyhf/3rX87n3377bXXt2lUfffSR+vTpo+joaB07dkylpaUaPny4OnXqpMTERL333nu14lqxYoXuvfdexcTEqEePHsrIyNCpU6d+ddsAAABwP09ef/w1drtdq1at0rBhw9S5c2f17t1bu3fvVmFhoQYNGqSYmBg99NBDOnz4sMvrNm7cqL59+yo6Olq33367Fi1apLNnzzqfv9R+c8uWLerdu7e6dOmiIUOGqKio6IryAAAAMFKg0QH4g7y8PFVWVqp79+7OZZGRkWrevLlycnIUExNT6zVr1qxRgwYN9Mc//tGLkQKAf3M4HIbu16j9w/04pnWjHhf24Ycf6uabb9bNN9+s++67TzNnztSwYcNUr149bd68WampqRo+fLjmzJmjyspKffzxx87XpqWlqbCwUP/n//wfNW7cWHPnztXQoUP1wQcfKCgoSJJUXl6upUuXasaMGbr22msVHh6u0aNHq6ioSG+88YYCAwM1Y8aMWj/BU69ePaWnp6tly5Y6cuSIMjMzNXfuXGVkZDjXqWvbgL9zx/nKiu8F5GwdVszbijlL/pu3v8XrL15++WWlpaUpLS1N8+bN09NPP61WrVpp6NChat68uSZPnqznnntOy5YtkyR98cUXmjhxoqZMmaKuXbvq8OHDmjp1qiQ574R5qf3mq6++qjlz5iggIEDPPvusZs+erfnz53u9BgCswczvI/763u5O1IAaSO6tweVswzSD8c2bN6tLly7OxwkJCVq4cKFbtl1SUqKgoCBdc801LsvDw8NVXFxc52tWr16te+65Rw0aNHBLDABgBQUFBSorKzNs/7m5uYbtG57BMcWlWr16te677z5J5/rIn376SZ9//rni4uK0ePFi9enTR6NHj3au365dO0nSv/71L23atEn/+Z//qdjYWEnSvHnz9Ic//EEbN25U7969JUmVlZXKyMhwvu7QoUP65JNP9N///d/q1KmTJOn5559Xnz59XOJ69NFHnf/dsmVLjR07VtOnT3e5UPnLbQNm4M6ewIrvBeRsHVbM24o5S9bN29d48vrjpUhOTnb2i08++aT69++vESNGKCEhQZI0ePBgTZo0ybn+okWLNHToUPXt21eS1KpVK40ZM0Zz5851DsYvtd/MzMzUTTfdJEkaMGCAXn75ZU+mCsDijL5G6A28t1MDiRpI3q+BaQbjcXFxLg1bSEiIYbHs3r1b33zzjebMmWNYDADgj+x2uyH7dTgcys3NVXR0tGw2myExwL04pnWrqQtcHTx4ULm5uXrppZckSYGBgerTp49Wr16tuLg45efn68EHH6zztd98840CAwPVuXNn57LrrrtOv/3tb/XNN984lwUFBbmc42pe17FjR+eyyMjIWh/E3LZtm5YsWaKDBw/q559/lsPh0JkzZ1RWVubsd3+5bcAM3PH/tBXfC8jZGjlL1szbijlL/pu3WftOo68/nv/+WHOXoLZt27osO3PmjH7++Wc1btxY+/bt065du7R48WLnOr/sJy+l3wwJCXEOxSWpWbNmte50BADuZOZ/4/rre7s7UQNqILm3BpfTe5pmMB4SEqLWrVt7ZNsRERGqrKzUyZMnXS5WlpaWqmnTprXW/+///m9FRUW5XOgEAPw6o5sAm81meAxwL44pLsXq1at19uxZ5zdtJKm6ulrBwcGaNm2aW+4A1KBBA9WrV++yXnP06FENGzZMDz/8sMaNG6ewsDDt3LlT6enpqqysdF6ovJJtA77OneduK74XkLN1WDFvK+YsWTdvX+PJ64+XouZneiQ5+7+6llVVVUmSTp8+rVGjRumuu+6qta369etfcr8ZGOh6CblevXqqrq52b3IAcB4rvOfx3k4NJGogeb8GphmMe1LHjh0VFBSk7du3q1evXpLOfbPo2LFjtX5f/NSpU/rwww/19NNPGxApAAAALsfZs2f17rvvKi0tTf/f//f/uTw3cuRIvf/++2rbtq22b9+ulJSUWq+PjIzU2bNn9eWXXzpvpf7DDz/o0KFDatOmzQX3e/PNN+vs2bPKy8tz3kr94MGDOnnypHOdvXv3qrq6WmlpaQoICJB07rfQAQAAgEvRvn17HTp06ILDfPpNAABgNaYfjJ86dUqHDx92Pj569Kjy8/MVFham5s2bS5JOnDih7777TkVFRZLO/eajdO6b4k2bNlVoaKhSUlI0a9YshYWFqXHjxpoxY4a6dOlSazC+du1aORwO529UAgAAwHdt3rxZP/74ox544AGFhoa6PHfXXXdp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rby8PBUWFmrQoEFKT093Wee//uu/tGbNGn399deSpA4dOmj8+PHO66sAAAD+whSDcUlKSEhQVlaWy7ImTZpo7dq1ysrKUmZmpjp37qzXX39dQ4YM0bp16xQeHq4bb7xRW7dudXndW2+9peXLl+u2226TJDkcDg0bNkwRERFatWqVioqKNHHiRAUFBWn8+PGSpPT0dD399NPObTgcDt1///364x//6OHMAQAArO1CfeC//vUv2e12paSkKDU1tc7Xnj59WrGxserdu7emTJnijXABAADgQ86/Lrh27VotXLhQ69atcy5r2LChEWFdspSUFH355ZcqKCio9ZzD4VD9+vU1aNAgrV+/vs7XV1RU6LrrrtNTTz2l1157rc51PvvsM919992KjY1VcHCwli1bpscff1wffPCBrr/+enemAwAA4FGmuZV6cHCwmjZt6vLHZrNpxYoV6tevn1JSUtSmTRtlZmaqQYMGys7OliTZbLZar9u4caN69+6tRo0aSTrXIB84cEBz585VVFSUevTooTFjxmjlypWqqKiQJIWGhrpsIy8vTz/++KOSk5MNqwkAAIAVXKgP7NGjh8aNG6c777zzgq9NSkpSamqqunXrdkX7ttvtWrVqlYYNG6bOnTurd+/e2r17t/PbNjExMXrooYd0+PBhl9dt3LhRffv2VXR0tG6//XYtWrRIZ8+edT6/YsUK3XvvvYqJiVGPHj2UkZGhU6dOOZ9/++231bVrV23ZskW9e/dWly5dNGTIEBUVFV1RHgAAAFZ1fg8ZGhqqevXquSxbu3atevfurejoaP3xj3/UypUrna89evSo7Ha71q5dq0ceeUSdOnVSSkqKDh06pD179ig5OVldunTRE088oePHjztfl5aWphEjRmjRokX6/e9/r9jYWE2bNs15nVE6N7CeMWOGunXrpujoaD388MPas2ePS+xTpkzRgAED1KpVqzpza9iwoTIzM9WvXz81bdq0znVatmypKVOmKCkpSaGhoXWuM3/+fA0YMEBRUVGKjIzUjBkzVFVVpe3bt19ynQEAAHyBab4xXpeKigrt3btXw4YNcy4LCAhQ9+7dtXv37jpfk5eXp/z8fE2bNs25LCcnR23btlVERIRzWXx8vDIyMnTgwAG1b9++1nZWr16t7t27q0WLFm7MCMCFOBwOr+/Lm/uEZ3FMzYdjWjfq4Rkv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tHTp0lrbeO2119SrVy916tRJPXr00MyZM3XmzJlL2v+OHTs0fPhwxcfHy263a+PGjZf0us8++0x9+/Z1xvz2229fetIAAADwC+f3quf/KSwsvKQ+csOGDXr88ccVFxcnu92u/Pz8WuucOXNGmZmZiouLU5cuXTRq1CiVlJS4rDNjxgwlJyerY8eOuv/++z2WLwAAANzjaq95VlZWatGiRbrjjjsUHR2t++67T5988skl759rngAAwOp8cjAuSQkJCdq6davWr1+vxx57TIsWLdLy5cv1888/a8iQIWrevLnefvttTZgwQYsWLdJbb73lfO3f//53zZ8/X6mpqVq7dq2ef/55rV27Vn/5y18uad+nT5+W3W7X9OnTLzneI0eOaNiwYYqLi9O7776rP/3pT5oyZYq2bNly2bkDAADAt9X0quf/admy5SX1kadPn1ZsbKyeeeaZC64zc+ZM/eMf/9CCBQv05ptvqqioSKmpqbXWS0lJUZ8+fdySEwAAADzvaq55LliwQG+99ZamTp2qtWvX6qGHHlJqaqq++uqrS9o31zwBAIDVBRodwIUEBweradOmkqRHHnlEGzdu1KZNmxQaGqrKykrNnDlTwcHBuuWWW5Sfn68VK1aof//+kqTdu3crNjZW9957rySpZcuWuueee/Tll19e0r579OihHj16XFa8q1atUsuWLZWWliZJioyM1M6dO/Xaa68pISHhsrYFAAAA33Z+r3q+S+kjk5KSJElHjx6t8/mffvpJ2dnZmjdvnrp16ybp3KC8T58+ysnJUUxMjCRpypQpkqTjx4+roKDgCjMBAACAN13NNc93331XTz31lLPffOSRR7R9+3a9+uqrmjdv3q/um2ueAADA6nx2MP5L9evX14kTJ5STk6OuXbsqODjY+Vx8fLyWLl2qH3/8UWFhYerSpYvee+897dmzR506ddKRI0f08ccfe/QWkzk5Oc4Ll+fHNXPmTI/tE7gQh8NhdAimVlNf6mweHFPz4ZjWjXr4h7y8PFVWVqp79+7OZZGRkWrevLnLYByX5pf/31vx/GDFnCVr5k3O1mHFvK2Ys+S/eftbvEa6nGuelZWVLs/XvH7Xrl0ei49rnlfvl3+Prfz3w+o1sHr+EjWQqIFEDSRqILm3BpezDZ8fjFdXV2v79u3aunWrBg4cqIKCArVs2dJlnYiICElSSUmJ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X8/25O1j4O35S4yBxBhIjIHEGEj2HYO81J4OaYwHBASoatWqNstSU1Pl6+urlJQUm+UpKSnW4vFmX331la5du6bOnTvnef9Fi/7/aRUpUsTmduayjIwMSTc+8SnduJz6PffcY7NeZhG7Zs0aTZo0ScOHD1e9evVUokQJJSQkaOfOnTnuN3M/zjhACu/lrX9AncXX15cx9zDMqedhTuEo9qh3c1KuXDmdOXPGZtn169d1/vx5m4O9knTfffdJuvEBzfT0dI0aNUq9e/fmeX+TnMbCG/8+eGPOknfmTc7ewxvz9sacJe/NW9Idj635+fllu/zw4cNq3bq1zbK6detmaYyXKFFCK1asyPL4tm3b2mzLYrFYm+KSFB4eroyMDB09etRa69WoUcOmKS7d+KrIadOmad++fTp//rw1n99++00PPvignn32WQ0ePFh79uxRkyZN1Lp161xdPTNzO0WKFJEkHTlyRK1atbJZJzw8XPPnz1d6err1+RMaGpplWwEBAdamuHSjHq1UqZL1MvGZy26tUXFn2b1uvfn1nMnbx8Db85cYA4kxkBgDiTGQCn8MfAprR/7+/goJCdGmTZusyzIyMrRp06ZsP5W5bNkytWzZMstlJO0tODhY/v7+OnXqlKpWrWrzk3mgcdu2bapXr56ef/551apVS1WrVtXx48cdGhcAAADcS17r3ZzUq1dPFy5c0O7du63LNm/erIyMDNWuXTvHxxljdP36desHQAEAANzZ/fffryJFiujw4cPZ3n/48GGVLVtWpUuXLtB+fHx8shwTvPUDkLkVEBBgczvzEuwlSpTQlClTtHTpUk2bNk3SjatVSlLz5s313//+VzExMfrzzz8VExOjSZMm3XFfmeOS2zPMc4pRyv5kn9udaAQAAOCuHHLGeE569eql4cOHKzQ0VLVr19a8efN09epVm8v5SDculbRlyxZ9+umnDo+pZMmS6t27tyZMmCBjjOrXr6+LFy9q27ZtKlmypLp06aKqVatq5cqV2rhxoypXrqx//etf2rVrV54LTwAAAHi23NS7p0+fVnJysvWDlgcOHFCJEiV03333qUyZMgoODlZkZKTefPNNjR49WmlpaRo7dqw6dOhgvcLRqlWrVLRoUVksFvn7+2vXrl1677331L59+xzPmgIAAHAngYGBatKkiT777DPFxMTYfM/46dOntXr1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de3aVaGhoXryySezxHDkyBH17NlTjRs3VlhYmFq1aqX3339faWlpjh8AAAAAOyvq7ABuJzIyUhMmTFBqaqq+/fZbjRkzRn5+fnr++efVp08fNWrUSKNHj9aBAwf0xhtvqHTp0urRo4fNNk6cOKFJkybl62Br5v4z+fv733b9L7/8UhMmTNDo0aNVp04dzZs3T3369NFXX32loKCgPO8fAADAVf3222+Kj4/Xxo0bde7cOZUvX16tWrXSwIEDFRgYKOlGk/aFF15QTExMnra9fPlyvfPOO9q6dWuW+ywWi6ZPn67WrVvbI418s1gs1t8DAgJUoUIFhYeHKzo6WqGhoU6La+nSpQoICHDa/gEAAGBftx6flKSyZcve8Tjkfffdp++++87mcYsWLVJCQoKaNWtms7xbt27auXOn9u/fn2X/fn5+6ty5s0JCQlSqVCnt27dPb775powxGjp0qP0TBgAAcCCXboz7+/urfPnykqTnnntO69at0/r161WqVCmlpaXpnXfekb+/vx566CHt3btXc+bMsWmMp6ena9iwYRo0aJB+/vlnXbhwId/7z405c+bo6aefVrdu3SRJo0eP1oYNG7Rs2TK99NJLedo3AACAq0pKSlKPHj1UrVo1TZ06VZUrV9bBgwf17rvvauPGjVq0aJHKlCnj7DCzlZqaescPO+bWhAkTFBkZqb/++kvHjh3T4sWL9fTTT+udd95R586dnRJj2bJl871fAAAAuJ6cjk/e6Tikr69vlsetW7dO7du3V4kSJazLRo4cKUk6c+ZMto3xKlWqqEqVKtbblSpV0k8//ZTth1gBAABcnUs3xm9111136dy5c9qxY4caNGhgc8CwadOmmjlzps6fP6+7775bkjR9+nQFBQXpqaee0s8//5zn/f30009q1KiRSpcurYYNG2rIkCHWM6BulZqaql9//VUvv/yydZmPj48aN26s7du353nfQG6lp6c7OwSvkznmjL3nYE49D3OaPXuNx+jRo+Xn56fZs2erWLFikqSKFSuqVq1aatOmjd5//30dOXJEJ0+e1IQJE6xnuGQeaFu+fLni4+N19uxZNW3aVPXr1893LPv379f48eO1Y8cOBQQEqG3btoqLi7Me7IuLi9OFCxcUFhamhQsXyt/fX+vXr9fKlSs1f/58HT16VMWLF1fDhg31xhtvWK/yc/78eY0Z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wDvk9TjksmXL1LJly3xfWfNWxhhdv36dOhQAALgdl26M56RTp07y8/PTiBEjdPDgQX355ZeaP3++evXqJUm66667VKNGDZuf0qVLq0SJEtmeMXSry5cva9KkSdqxY4dOnDihTZs2acCAAapataoiIyOt67344ov6xz/+Yb3dq1cvLV68WCtWrNDhw4f19ttv6+rVqzaXyQQAAHBngYGBatKkiT777LMs37l9+vRprV69Wl26dJF046zxWw+WBQcH65dffrFZtnPnznzFEhwcrP379+vKlSvWZdu2bZOPj48eeOCBHB935MgRnTt3TsOGDVODBg0UHByc5WwbSSpbtqy6dOmiKVOm6I033tCiRYvuGNO8efNUsmRJNW7cWNKNS6tv27bNZp1t27apWrVqXv+JYAAAAORfbo9DJiYmasuWLTZfJXTr/Xv37tXp06d17do17d27V3v37lVqaqokadWqVfryyy91+PBhJSUl6csvv9R7772n9u3b53iVKAAAAFfl0pdSz0mpUqWUkJCgMWPGqGvXrgoMDNSAAQPUo0cPu2zf19dXBw4c0MqVK3Xx4kVVqFBBTZo00SuvvGLTVE9KStLZs2ett6OionTmzBnFx8fr9OnTqlmzpmbNmsWl1AEAgEd588039cwzz6hPnz4aMmSIKleurIMHD+rdd99VtWrVrN+nXalSJW3ZskUdOnSQn5+fypYtq549e+rZZ59VQkKCWrVqpe+++y7LZdRzq1OnToqPj1dcXJxiY2N15swZjR07Vk8++eRt66+KFSvKz89PCxYs0LPPPqsDBw7o448/tlnnww8/VEhIiB566CGlpqZqw4YNWb5X/cKFCzp9+rRSU1N17NgxLVq0SOvWrdOkSZOsZ8z37t1b3bt31/Tp0xUVFaUdO3Zo4cKFeuutt/KVMwAAACDl/jjksmXLdO+996pp06bZbmfkyJH66aefrLczL7f+n//8R5UrV1bRokU1a9YsHT16VNKNWjo6OloxMTEOyQsAAMCRXLYxPnHixNve//DDD+uzzz6z2/ZuVqxYMSUkJNxxvfXr12dZFh0drejo6FzvCwAAwN1Uq1bNevnxIUOGKCUlRcYYtW3bVpMnT7ZeFnzw4MEaNWqUWrdurdTUVO3fv19169bV2LFj9dFHHyk+Pl6NGjVS//79szSmcyMgIEAJCQkaP368unfv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iIgI1atXT4MGDVJycrI907ote+ecm//FevbsmWWeR40aZe/UbsveeX/00UdZcnr88cdt1vG0uc7u9WqxWDR69GjrOu4214sXL9Zzzz2nRx55RI888ohiYmKyrO8u79fwfM6oRV2NM+pSV2Pv58HNRo0addsax1U4YgwOHz6sfv36qX79+qpbt666deumU6dOOSqFArP3GFy+fFljxoxRs2bNVLt2bUVFRemf//ynI1MoMGfU8a7GGXW9K3HEcyCTu/QiHDEGDjl+b+AS1qxZY0JCQszSpUvNwYMHzciRI02DBg1McnKys0NDPvTu3dssW7bMHDhwwOzdu9f07dvXPPbYY+by5cvODg12sHPnTtOiRQvTqVMnM27cOGeHg3w6d+6cadGihYmLizM7d+40x48fNxs3bjSJiYnODg359Mknn5hHH33U/Pe//zVJSUlm7dq1pm7dumbevHnODg2wu7zWjj///LOpWbOmmTlzpjl06JB5//33TUhIiNm/f791nRkzZpj69eubb775xuzdu9f069fPtGzZ0ly7ds26Tp8+fcwTTzxhduzYYbZs2WLatGljhg4d6vB8M9k77wsXLpiYmBizZs0ac/jwYbN9+3bTvXt306VLF5vttGjRwkybNs38+eef1p/CquscMdfDhw83ffr0scnn3LlzNtvxtLk2xtjk++eff5qlS5cai8Vijh8/bl3HneZ6586dZuLEieaLL74wTZo0MXPmzMnXNkeNGmWaN29ufvjhB7Nr1y7z9NNPmx49ejgqzTzHd7Pc5Jyb/8Wio6PNyJEjbeb54sWLjkozC0fkHR8fbzp06GCTU0pKis06njbXKSkpNvl+//33pkaNGmbz5s3WddxtrocOHWr+8Y9/mD179phDhw6ZuLg4U79+ffP7779b13GH92t4PmfVoq7EWXWpK3HE8yDTv//9b/PEE0+Ypk2bZvse4CocMQaJiYnm0UcfNZMmTTK//vqrSUxMNOvWrXPZPoEjxmDkyJGmdevWZvPmzSYpKcl8/vnnpmbNmmbdunWFlVaeOKuOdyXOqutdhSPyv3ldd+hFOGIMHHX8nsa4i+jevbsZPXq09XZ6erpp2rSpmTFjhhOjgr2kpKSYGjVqmJ9++snZoaCALl26ZNq2bWu+//57Ex0d7dJvRri9d9991zz77LPODgN29NJLL5nXX3/dZlls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+KJmzJjh7NAAu8pP7ViuXLksZ6PcvH758uWty3Jap1y5cjpz5ozN/devX9f58+etj3ckR+SdKS0tTUOGDNGpU6c0e/bsO56VU6dOHV2/fl0nTpzIRya558icb1alShUFBgYqMTHRug1PnWtJ2rp1q44ePZqrZqErz7U9tlmuXDmlpaXpwoULWdZx9Fw7+v/gvPwvVqdOHUmyvgYcqbD+/y9durSqVaum48ePS/LsuT558qR++OGHbL8a4VbuMtcJCQn69NNPlZCQoIcffti63B3er+H5nFWLuhJXqkudxRFjsHXrVqWkpKhFixbWY28nT57UpEmT1LJlS8ckUgCOGIPAwEAVLVo0y/Gq4OBglzxe5YgxuHbtmt5//329/vrratmypR5++GFFR0crKipKCQkJjkmkAJxVx7sSV6rrncER+btbL8JRzwFHHb+nMe4C/P39FRISok2bNlmXZWRkaNOmTapXr54TI0N+GWM0ZswYffPNN5o3b56qVKni7JBQQA0bNtTq1au1cuVK609oaKg6deqklStXytfX19khIo/Cw8Ot30Wd6dixY6pUqZKTIkJBXbt2Lcunyn19fWWMcVJEgGPkp3asW7euNm/ebLPshx9+UN26dSVJlStXVvny5W22eenSJe3cudO6zXr16unChQvavXu3dZ3NmzcrIyNDtWvXtld6OXJE3tL/f/AxMTFRc+fOVWBg4B1j2bt3r3x8fLJcJszeHJXzrX7//XedO3fOelDaU+c609KlSxUSEmLTbMqJK8+1PbYZGhoqPz8/m3WOHDmiU6dO3fY5Yw+O+j84P/+L7d27V5IKpWlYWP//X758WUlJSdacPHGuMy1fvlxBQUF67LHH7riuO8z1zJkz9fHHH2vWrFk23xMuucf7NTyfs2pRV+JKdamzOGIMnnzySa1atcrm2FuFChXUp08fzZo1y2G55JcjxsDf319hYWFuc7zKEWNw/fp1paWluc3xHWfV8a7Elep6Z3BE/u7Wi3DUc8Bhx+8NXMKaNWtMaGioWb58uTl06JB58803TYMGDczp06edHRry4a233jL169c3P/74o/nzzz+tP1evXnV2aLCj6OhoM27cOGeHgXzauXOnqVWrlvnkk0/MsWPHzKpVq0ydOnXMv/71L2eHhnwaPny4iYyMNP/9739NUlKS+fe//20iIiLM5MmTnR0a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\n"
          },
          "metadata": {}
        }
      ]
    }
  ]
}
</file>

<file path="dashboard/backend/main.py">
# main.py (COM MODELO HÍBRIDO - VERSÃO FINAL)

import os
import pickle
import joblib
import pandas as pd
import numpy as np
import shap
from fastapi import FastAPI, Depends, HTTPException, UploadFile, File, status
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError
from sqlalchemy import func
import crud
import models
import schemas
import auth
import database
from sklearn.ensemble import StackingRegressor
from flask_bcrypt import Bcrypt
from core import app
from io import BytesIO

# Cria tabelas no DB (se não existirem) ao iniciar
try:
    models.Base.metadata.create_all(bind=database.engine)
except Exception as e:
    print(f"Aviso: Não foi possível criar tabelas do DB na inicialização (pode ser normal se já existirem): {e}")

# --- Carregamento de Artefatos de ML (ATUALIZADO PARA MODELO HÍBRIDO) ---
ARTIFACTS_PATH = os.getenv('ARTIFACTS_PATH', 'ml_artifacts')
MODELS, SCALERS, FEATURES, EXPLAINERS = {}, {}, {}, {}

try:
    # Target 1 (modelo único - mantém compatibilidade)
    MODELS['target1'] = joblib.load(f"{ARTIFACTS_PATH}/modelo_target1.pkl")
    SCALERS['target1'] = joblib.load(f"{ARTIFACTS_PATH}/scaler_target1.pkl")
    with open(f"{ARTIFACTS_PATH}/features_target1.pkl", "rb") as f:
        FEATURES['target1'] = pickle.load(f)
    EXPLAINERS['target1'] = shap.TreeExplainer(MODELS['target1'])

    # Targets 2 e 3 (ensemble de 3 modelos cada - NOVA ESTRUTURA)
    for target in ['target2', 'target3']:
        MODELS[target] = []
        for i in range(3): # Carrega os 3 modelos do ensemble
            model = joblib.load(f"{ARTIFACTS_PATH}/modelo_{target}_ensemble_{i}.pkl")
            MODELS[target].append(model)
        
        SCALERS[target] = joblib.load(f"{ARTIFACTS_PATH}/scaler_{target}.pkl")
        with open(f"{ARTIFACTS_PATH}/features_{target}.pkl", "rb") as f:
            FEATURES[target] = pickle.load(f)
        
        # Cria um explainer para cada modelo do ensemble
        EXPLAINERS[target] = [shap.TreeExplainer(m) for m in MODELS[target]]

    print("✅ Artefatos de ML e Explainers HÍBRIDOS carregados com sucesso.")
except Exception as e:
    print(f"❌ ERRO CRÍTICO ao carregar artefatos de ML: {e}")
    MODELS = None # Invalida para a verificação de saúde da API

# --- Funções de Pré-processamento ATUALIZADAS (Modelo Híbrido) ---

def preprocess_target1(df_input):
    """Pré-processamento específico para Target 1 (modelo único)"""
    df = df_input.copy()
    
    # Conversão de F0103
    if 'F0103' in df.columns: 
        df['F0103'] = pd.to_numeric(df['F0103'].astype(str).str.replace(',', '.'), errors='coerce')
    
    # Identificação de colunas
    p_cols = [c for c in df.columns if c.startswith('P') and any(char.isdigit() for char in c)]
    t_cols = [c for c in df.columns if c.startswith('T') and any(char.isdigit() for char in c)]
    f_cols = [c for c in df.columns if c.startswith('F') and len(c) > 1 and any(char.isdigit() for char in c)]
    
    # Engenharia de features - taxas de pulos
    p_minus_ones = sum((df[col] == -1).sum() for col in p_cols if col in df.columns)
    t_minus_ones = sum((df[col] == -1).sum() for col in t_cols if col in df.columns)
    df['taxa_pulos_P'] = p_minus_ones / len(p_cols) if len(p_cols) > 0 else 0
    df['taxa_pulos_T'] = t_minus_ones / len(t_cols) if len(t_cols) > 0 else 0
    df['taxa_pulos_geral'] = (p_minus_ones + t_minus_ones) / (len(p_cols) + len(t_cols)) if (len(p_cols) + len(t_cols)) > 0 else 0

    # Processamento de colunas numéricas
    for col in p_cols + t_cols + f_cols:
        if col in df.columns:
            df[col] = pd.to_numeric(df[col], errors='coerce').replace(-1, np.nan)
            df[col].fillna(df[col].median(), inplace=True)
            
    # Features de sono
    if 'QtdHorasDormi' in df.columns and 'Acordar' in df.columns:
        df['sono_total'] = df['QtdHorasDormi']
        df['sono_x_acordar'] = df['QtdHorasDormi'] * df['Acordar']
        df['sono_squared'] = df['QtdHorasDormi'] ** 2
        df['sono_irregular'] = np.abs(df['QtdHorasDormi'] - df['QtdHorasDormi'].median())

    # Estatísticas das colunas P
    if p_cols: 
        df['P_mean'] = df[p_cols].mean(axis=1)
        df['P_std'] = df[p_cols].std(axis=1)
        df['P_min'] = df[p_cols].min(axis=1)
        df['P_max'] = df[p_cols].max(axis=1)
        df['P_range'] = df['P_max'] - df['P_min']
        df['P_late'] = df[['P09', 'P12', 'P13', 'P15']].mean(axis=1) if all(c in df.columns for c in ['P09', 'P12', 'P13', 'P15']) else 0
        df['P_early'] = df[['P01', 'P02', 'P03', 'P04']].mean(axis=1) if all(c in df.columns for c in ['P01', 'P02', 'P03', 'P04']) else 0
    
    # Estatísticas das colunas T
    if t_cols: 
        df['T_mean'] = df[t_cols].mean(axis=1)
        df['T_std'] = df[t_cols].std(axis=1)
        df['T_min'] = df[t_cols].min(axis=1)
        df['T_max'] = df[t_cols].max(axis=1)
        
    # Features específicas das colunas F
    f_perfil = [c for c in f_cols if c.startswith('F01') or c.startswith('F02')]
    if f_perfil: 
        df['F_perfil_mean'] = df[f_perfil].mean(axis=1)
        df['F_perfil_std'] = df[f_perfil].std(axis=1)

    f_sono = [c for c in f_cols if c.startswith('F07')]
    if f_sono: 
        df['F_sono_mean'] = df[f_sono].mean(axis=1)
        df['F_sono_std'] = df[f_sono].std(axis=1)
    
    f_final = [c for c in f_cols if c.startswith('F11')]
    if f_final: 
        df['F_final_mean'] = df[f_final].mean(axis=1)
        df['F_final_std'] = df[f_final].std(axis=1)

    df['F_mean_geral'] = df[f_cols].mean(axis=1)

    # Interações entre as top 3 features
    top3 = [f for f in FEATURES['target1'] if '_X_' not in f][:3]
    for i, f1 in enumerate(top3):
        for f2 in top3[i+1:]:
            df[f'{f1}_X_{f2}'] = df.get(f1, 0) * df.get(f2, 0)
    
    # Garante todas as features esperadas pelo modelo
    df_final = df.reindex(columns=FEATURES['target1'], fill_value=0)
    return SCALERS['target1'].transform(df_final)

def preprocess_target2(df_input):
    """Pré-processamento específico para Target 2 (ensemble)"""
    df = df_input.copy()
    
    if 'F0103' in df.columns: 
        df['F0103'] = pd.to_numeric(df['F0103'].astype(str).str.replace(',', '.'), errors='coerce')
    
    # Identificação de colunas
    p_cols = [c for c in df.columns if c.startswith('P') and any(char.isdigit() for char in c)]
    t_cols = [c for c in df.columns if c.startswith('T') and any(char.isdigit() for char in c)]
    f_cols = [c for c in df.columns if c.startswith('F') and len(c) > 1 and any(char.isdigit() for char in c)]

    # Processamento de colunas numéricas
    for col in p_cols + t_cols + f_cols:
        if col in df.columns:
            df[col] = pd.to_numeric(df[col], errors='coerce').replace(-1, np.nan)
            df[col].fillna(df[col].median(), inplace=True)
            
    # Features básicas de sono
    if 'QtdHorasDormi' in df.columns and 'Acordar' in df.columns:
        df['sono_total'] = df['QtdHorasDormi']
        df['acordar'] = df['Acordar']

    # Médias específicas
    f_sono = [c for c in f_cols if c.startswith('F07')]
    if f_sono: 
        df['F_sono_mean'] = df[f_sono].mean(axis=1)

    f_final = [c for c in f_cols if c.startswith('F11')]
    if f_final: 
        df['F_final_mean'] = df[f_final].mean(axis=1)

    if p_cols: 
        df['P_mean'] = df[p_cols].mean(axis=1)
    
    # Interação entre as duas principais features
    base_features = [f for f in FEATURES['target2'] if '_X_' not in f]
    if len(base_features) >= 2:
        f1, f2 = base_features[0], base_features[1]
        interaction_name = f'{f1}_X_{f2}'
        if interaction_name in FEATURES['target2']:
            df[interaction_name] = df[f1] * df[f2]

    # Garante todas as features esperadas pelo modelo
    df_final = df.reindex(columns=FEATURES['target2'], fill_value=0)
    return SCALERS['target2'].transform(df_final)

def preprocess_target3(df_input):
    """Pré-processamento específico para Target 3 (ensemble)"""
    df = df_input.copy()

    if 'F0103' in df.columns: 
        df['F0103'] = pd.to_numeric(df['F0103'].astype(str).str.replace(',', '.'), errors='coerce')

    # Identificação de colunas
    p_cols = [c for c in df.columns if c.startswith('P') and any(char.isdigit() for char in c)]
    t_cols = [c for c in df.columns if c.startswith('T') and any(char.isdigit() for char in c)]
    f_cols = [c for c in df.columns if c.startswith('F') and len(c) > 1 and any(char.isdigit() for char in c)]

    # Processamento de colunas numéricas
    for col in p_cols + t_cols + f_cols:
        if col in df.columns:
            df[col] = pd.to_numeric(df[col], errors='coerce').replace(-1, np.nan)
            df[col].fillna(df[col].median(), inplace=True)
    
    # Estatísticas avançadas das colunas P
    if p_cols:
        df['P_mean'] = df[p_cols].mean(axis=1)
        df['P_std'] = df[p_cols].std(axis=1)
        df['P_late'] = df[['P09', 'P12', 'P13', 'P15']].mean(axis=1) if all(c in df.columns for c in ['P09', 'P12', 'P13', 'P15']) else 0
        df['P_early'] = df[['P01', 'P02', 'P03', 'P04']].mean(axis=1) if all(c in df.columns for c in ['P01', 'P02', 'P03', 'P04']) else 0

    # Estatísticas das colunas T
    if t_cols:
        df['T_mean'] = df[t_cols].mean(axis=1)
        df['T_std'] = df[t_cols].std(axis=1)

    # Features de sono avançadas
    if 'QtdHorasSono' in df.columns:
        f_sono = [c for c in f_cols if '07' in c]
        if f_sono:
            df['F_sono_mean'] = df[f_sono].mean(axis=1)
            df['F_sono_std'] = df[f_sono].std(axis=1)
            df['F_sono_max'] = df[f_sono].max(axis=1)
        if 'Acordar' in df.columns:
            df['sono_x_acordar'] = df['QtdHorasSono'] * df['Acordar']
            df['acordar_squared'] = df['Acordar'] ** 2
    
    # Features finais
    f_final = [c for c in f_cols if '11' in c]
    if f_final: 
        df['F_final_mean'] = df[f_final].mean(axis=1)

    # Interação específica para Target 3
    if 'F1103' in df.columns and 'P_mean' in df.columns and 'F1103_X_P_mean' in FEATURES['target3']:
        df['F1103_X_P_mean'] = df['F1103'] * df['P_mean']
    
    # Garante todas as features esperadas pelo modelo
    df_final = df.reindex(columns=FEATURES['target3'], fill_value=0)
    return SCALERS['target3'].transform(df_final)

# --- Rotas da API (ATUALIZADAS) ---
@app.get("/health", status_code=status.HTTP_200_OK)
def health_check():
    """Endpoint de health check para o Docker Compose."""
    if MODELS is None:
        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail="Modelos de ML não carregados.")
    return {"status": "ok"}

@app.post("/register", status_code=status.HTTP_201_CREATED)
def register(user: schemas.UserCreate, db: Session = Depends(database.get_db)):
    db_user = crud.get_user_by_username(db, username=user.username)
    if db_user:
        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail="Usuário já existe")
    try:
        crud.create_user(db=db, user_schema=user)
        return {"msg": "Usuário registrado com sucesso"}
    except IntegrityError: # Captura erro de corrida (race condition)
        db.rollback()
        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail="Usuário já existe")

@app.post("/login", response_model=schemas.Token)
def login(form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(database.get_db)):
    user = crud.get_user_by_username(db, username=form_data.username)
    if not user or not auth.verify_password(form_data.password, user.password_hash):
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Credenciais inválidas")
    access_token = auth.create_access_token(data={"sub": str(user.id)})
    return {"access_token": access_token, "token_type": "bearer"}

@app.post("/predict")
async def predict(file: UploadFile = File(...), user_id: str = Depends(auth.get_current_user_id), db: Session = Depends(database.get_db)):
    if MODELS is None:
        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail="Modelos de ML não estão disponíveis.")
    
    try:
        contents = await file.read()
        buffer = BytesIO(contents)
        df_new = pd.read_excel(buffer)
        if 'Código de Acesso' not in df_new.columns:
            print("Coluna 'Código de Acesso' não encontrada no arquivo.")
            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Coluna 'Código de Acesso' não encontrada no arquivo.")
    except Exception as e:
        print(f"Erro ao ler o arquivo Excel: {e}")
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=f"Erro ao ler o arquivo Excel: {e}")

    df_results = df_new.copy()
    shap_data = {}

    try:
        # Previsão T1 (modelo único)
        X_scaled_t1 = preprocess_target1(df_new)
        df_results['Previsão T1'] = MODELS['target1'].predict(X_scaled_t1).round(2)
        
        # Previsão T2 (ensemble - média dos 3 modelos)
        X_scaled_t2 = preprocess_target2(df_new)
        preds_t2 = [model.predict(X_scaled_t2) for model in MODELS['target2']]
        df_results['Previsão T2'] = np.mean(preds_t2, axis=0).round(2)
        
        # Previsão T3 (ensemble - média dos 3 modelos)
        X_scaled_t3 = preprocess_target3(df_new)
        preds_t3 = [model.predict(X_scaled_t3) for model in MODELS['target3']]
        df_results['Previsão T3'] = np.mean(preds_t3, axis=0).round(2)

        # Cálculo SHAP - ATUALIZADO PARA ENSEMBLE
        # T1 (modelo único)
        shap_values_t1 = EXPLAINERS['target1'].shap_values(X_scaled_t1)
        
        # T2 (média dos SHAP values dos 3 modelos do ensemble)
        shap_values_list_t2 = [explainer.shap_values(X_scaled_t2) for explainer in EXPLAINERS['target2']]
        shap_values_t2 = np.mean(shap_values_list_t2, axis=0)

        # T3 (média dos SHAP values dos 3 modelos do ensemble)
        shap_values_list_t3 = [explainer.shap_values(X_scaled_t3) for explainer in EXPLAINERS['target3']]
        shap_values_t3 = np.mean(shap_values_list_t3, axis=0)

        # Estrutura dos dados SHAP para resposta
        for i, j_id in enumerate(df_results['Código de Acesso']):
            shap_data[str(j_id)] = {
                'T1': {
                    'shap_values': shap_values_t1[i].tolist(), 
                    'feature_names': FEATURES['target1']
                },
                'T2': {
                    'shap_values': shap_values_t2[i].tolist(), 
                    'feature_names': FEATURES['target2']
                },
                'T3': {
                    'shap_values': shap_values_t3[i].tolist(), 
                    'feature_names': FEATURES['target3']
                }
            }
            
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"Erro durante o pipeline de previsão: {e}")

    # Salvar no DB
    try:
        for _, row in df_results.iterrows():
            db.add(models.Prediction(
                user_id=int(user_id), 
                jogador_id=str(row['Código de Acesso']), 
                pred_t1=row['Previsão T1'], 
                pred_t2=row['Previsão T2'], 
                pred_t3=row['Previsão T3']
            ))
        db.commit()
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"Erro ao salvar previsão no banco de dados: {e}")

    return {
        "predictions": df_results[['Código de Acesso', 'Previsão T1', 'Previsão T2', 'Previsão T3']].to_dict('records'),
        "shap_data": shap_data
    }

@app.get("/history")
def get_history(user_id: str = Depends(auth.get_current_user_id), db: Session = Depends(database.get_db)):
    query = db.query(
        models.Prediction.upload_timestamp, 
        func.count(models.Prediction.id).label('num_jogadores')
    ).filter(models.Prediction.user_id == int(user_id)).group_by(models.Prediction.upload_timestamp).order_by(models.Prediction.upload_timestamp.desc()).all()
    return [{"timestamp": r.upload_timestamp.strftime("%Y-%m-%d %H:%M:%S"), "num_jogadores": r.num_jogadores} for r in query]

@app.get("/feature_importance")
def get_feature_importance(user_id: str = Depends(auth.get_current_user_id)):
    if MODELS is None:
        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail="Modelos de ML não carregados.")
    
    importances_data = {}
    try:
        # Target 1 (modelo único)
        if hasattr(MODELS['target1'], 'feature_importances_'):
            df_imp_t1 = pd.DataFrame({
                'feature': FEATURES['target1'], 
                'importance': MODELS['target1'].feature_importances_
            }).sort_values(by='importance', ascending=False).head(20)
            importances_data['Target1'] = df_imp_t1.to_dict('records')
        else:
            importances_data['Target1'] = []

        # Targets 2 e 3 (média das importâncias dos ensembles)
        for target_key, target_name in [('target2', 'Target2'), ('target3', 'Target3')]:
            all_importances = []
            for model in MODELS[target_key]:
                if hasattr(model, 'feature_importances_'):
                    all_importances.append(model.feature_importances_)
            
            if all_importances:
                avg_importance = np.mean(all_importances, axis=0)
                df_imp = pd.DataFrame({
                    'feature': FEATURES[target_key],
                    'importance': avg_importance
                }).sort_values(by='importance', ascending=False).head(20)
                importances_data[target_name] = df_imp.to_dict('records')
            else:
                importances_data[target_name] = []
                
        return importances_data
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"Erro ao calcular feature importance: {e}")
</file>

<file path="README.md">
# 📊 Documentação do projeto

**Propósito do Projeto**

<small>

Este projeto foi desenvolvido para realizar um ciclo completo de análise de dados, desde a limpeza e preparação até a modelagem preditiva e avaliação de performance. O objetivo principal é transformar um conjunto de dados brutos de jogadores em insights acionáveis e modelos de _machine learning_ robustos, capazes de prever três métricas-alvo distintas (`Target1`, `Target2` e `Target3`).

O processo é dividido em duas fases principais:

1.  **Fase de Limpeza e Preparação (V1)**: Focada em garantir a qualidade e a consistência dos dados. Nesta etapa, são aplicadas técnicas como tratamento de valores ausentes, remoção de _outliers_, _feature engineering_ e seleção de variáveis para criar um _dataset_ otimizado e confiável.

2.  **Fase de Modelagem (V2)**: Utiliza o _dataset_ limpo para treinar, avaliar e comparar diversos algoritmos de regressão, como _Random Forest_, _XGBoost_ e _LightGBM_. O objetivo é identificar os modelos com melhor desempenho para cada uma das variáveis-alvo, salvando-os para futura implementação em produção.

Ao final, o projeto entrega não apenas os modelos treinados, mas também análises visuais e relatórios que facilitam a interpretação dos resultados e a identificação das variáveis mais influentes.

</small>

<details>

<summary> 📊 Fase V1 - Limpeza</summary>

### 🧩 **Célula 1/2 - Configuração do Ambiente e Importações**

<small>
📖 Explicação:

Esta célula inicializa o ambiente de trabalho. Primeiro, realiza a instalação silenciosa das dependências externas necessárias para a manipulação de planilhas e para a aplicação de técnicas de aprendizado de máquina. Em seguida, importa as bibliotecas e módulos que serão utilizados ao longo das etapas de limpeza, transformação e análise de dados.

<details>

<summary> Bibliotecas utilizadas: </summary>

<small>

- **xlsxwriter e openpyxl**:

Dependências utilizadas pelo Pandas para ler e escrever arquivos no formato Excel (.xlsx). A instalação garante a compatibilidade com essas operações.

- **scikit-learn**:

Uma das principais bibliotecas de aprendizado de máquina em Python, que fornece ferramentas eficientes para pré-processamento, modelagem e avaliação de dados.

- **pandas**:

Fundamental para a manipulação e análise de dados. É utilizada para carregar os dados em estruturas conhecidas como DataFrames, que facilitam a limpeza e a transformação.

- **numpy**:

Essencial para computação numérica, oferece suporte a arrays e matrizes multidimensionais, além de uma vasta coleção de funções matemáticas de alto desempenho.

- **SimpleImputer**:

Uma classe do Scikit-learn usada para tratar dados ausentes (NaN), permitindo preenchê-los com uma estratégia definida (como a média, mediana ou a moda da coluna).

- **StandardScaler**:

Uma classe do Scikit-learn utilizada para padronizar as features numéricas, redimensionando-as para que tenham média zero e desvio padrão igual a um, o que é crucial para muitos algoritmos de machine learning.

- **datetime**:

Módulo padrão do Python para manipulação de datas e horas.

- **warnings**:

Módulo para controlar a exibição de mensagens de aviso. A linha warnings.filterwarnings('ignore') é usada para suprimir esses avisos e manter a saída do código mais limpa e focada nos resultados.
</small>

</details>

---

### 🧩 **Célula 3 - DEFINIÇÕES**

<details>

<summary> Trecho do codigo em Python </summary>

```python
COLUNAS_CATEGORICAS = [
    'Cor0202', 'Cor0204', 'Cor0206', 'Cor0208', 'Cor0209Outro',
    'P01', 'P02', 'P03', 'P04', 'P05', 'P07', 'P08', 'P09', 'P10',
    'P12', 'P13', 'P15', 'P12_1', 'P02_1', 'P03_1', 'P09_1'
]

COLUNAS_TARGETS = ['Target1', 'Target2', 'Target3']

COLUNAS_IGNORAR = [
    'Código de Acesso', 'Data/Hora Último',
    'L0210 (não likert)',
    'F0299 - Explicação Tempo', 'T0499 - Explicação Tempo',
    'PTempoTotalExpl', 'T1199Expl', 'T1205Expl', 'T1210Expl',
    'TempoTotalExpl'
]

print(f"📋 Categóricas: {len(COLUNAS_CATEGORICAS)} | Targets: {len(COLUNAS_TARGETS)}")
```

</details>
<small> 📖 Explicação:

Esta célula centraliza as **definições estruturais** do dataset, classificando as colunas em grupos conforme seu papel no processamento:

- **`COLUNAS_CATEGORICAS`**: lista de variáveis qualitativas ou de múltipla escolha, normalmente representadas por códigos (`P01`, `P02`, etc.).
- **`COLUNAS_TARGETS`**: define as variáveis-alvo (targets) utilizadas em análises ou modelagem.
- **`COLUNAS_IGNORAR`**: contém variáveis irrelevantes ou auxiliares, como identificadores, timestamps e campos descritivos.
  </small>

---

### 🧩 **Célula 4 - Carregando Dataset Recebido**

<details>

<summary> Trecho do codigo em Python </summary>

```python
import pandas as pd

df_original = pd.read_excel('JogadoresV1.xlsx')
df = df_original.copy()
print(f"Dados carregados: {df.shape[0]} linhas, {df.shape[1]} colunas")
```

</details>
<small>
📖 Explicação:

Nesta célula, realizamos a leitura do arquivo Excel contendo o dataset bruto e criamos uma cópia para preservar o original.

- `pd.read_excel()` carrega o arquivo no formato Excel.
- `.copy()` evita modificações acidentais no dataset original.  
  </small>

---

### 🧩 **Célula 5 - TRATAMENTO F0103**

<details>

<summary> Trecho do codigo em Python </summary>

```python
if 'F0103' in df.columns and df['F0103'].dtype == 'object':
    print("\n🔧 Convertendo F0103 (vírgula → ponto)")
    df['F0103'] = df['F0103'].str.replace(',', '.').astype(float)
    print("   ✅ Convertido!")
```

</details>

<small> 📖 Explicação:

Nesta célula, corrigimos a coluna chamada `F0103` para garantir que os números estejam em um formato que o Python consegue entender corretamente.

- Primeiro verificamos se a coluna `F0103` existe na tabela e se ela está como texto.

- Em seguida, substituímos todas as vírgulas `,` por pontos `.` — isso é importante porque em alguns arquivos, números decimais vêm escritos como `3,14` em vez de `3.14`.
- Por fim, transformamos essa coluna em números de ponto flutuante (`float`), para que possa ser usada em cálculos, análises e modelos sem causar erros.

Esse passo garante que a informação da coluna `F0103` seja precisa e utilizável em todas as etapas seguintes do processamento de dados.
</small>

---

### 🧩 **Célula 6 — REMOÇÃO DE NEGATIVOS**

<details>

<summary> Trecho do codigo em Python </summary>

```python
print("\n" + "=" * 80)
print("ETAPA 1: REMOÇÃO DE NEGATIVOS → NaN")
print("=" * 80)

colunas_numericas = df.select_dtypes(include=[np.number]).columns.tolist()
colunas_numericas = [col for col in colunas_numericas if col not in COLUNAS_TARGETS]

contador = 0
for col in colunas_numericas:
    negativos = (df[col] < 0).sum()
    if negativos > 0:
        df.loc[df[col] < 0, col] = np.nan
        contador += negativos

print(f"✅ {contador} negativos convertidos → NaN")

```

</details>

<small> 📖 Explicação:

Nesta célula, identificamos todas as colunas numéricas e substituímos valores negativos por valores vazios (NaN).

- Primeiro, usamos `df.select_dtypes(include=[np.number])` para selecionar todas as colunas que contêm números.

- Em seguida, removemos da lista as colunas-alvo definidas em `COLUNAS_TARGETS`, pois essas não devem ser modificadas nesse passo.

- Para cada coluna numérica restante, verificamos quantos valores são negativos usando `(df[col] < 0).sum()`.

- Quando valores negativos são encontrados, usamos `df.loc[df[col] < 0, col] = np.nan` para substituí-los.

- Ao final, imprimimos a quantidade total de valores negativos convertidos.

</small>

---

### 🧩 **Célula 7 - Remoção de Colunas com Muito Missing**

<details>

<summary> Trecho do codigo em Python </summary>

```python
print("\n" + "=" * 80)
print("ETAPA 2: ANÁLISE DE MISSING")
print("=" * 80)

missing_info = pd.DataFrame({
    'Coluna': df.columns,
    'Missing': df.isna().sum(),
    'Percentual': (df.isna().sum() / len(df) * 100).round(2)
})
missing_info = missing_info[missing_info['Missing'] > 0].sort_values('Percentual', ascending=False)

threshold = 70
colunas_remover = missing_info[missing_info['Percentual'] > threshold]['Coluna'].tolist()

if colunas_remover:
    print(f"🗑️  Removendo {len(colunas_remover)} colunas (>{threshold}% missing)")
    df = df.drop(columns=colunas_remover)

print(f"✅ Shape: {df.shape}")

```

</details>

<small> 📖 Explicação:

Nesta célula, realizamos uma análise de dados faltantes (`missing values`) em cada coluna e removemos aquelas que possuem um percentual alto de ausência de dados.

- Usamos `df.isna().sum()` para contar quantos valores estão faltando em cada coluna.

- Calculamos o percentual de valores faltantes dividindo pela quantidade total de linhas (`len(df)`).

- Criamos o DataFrame `missing_info`, que contém o nome da coluna, quantidade de valores ausentes e percentual de ausência.

- Ordenamos `missing_info` pelo percentual de ausência em ordem decrescente para focar nas colunas com mais dados faltantes.

- Definimos um limite (`threshold`) de 70%. Isso significa que qualquer coluna com mais de 70% de valores faltantes será removida.

- Usamos `df.drop(columns=colunas_remover)` para eliminar essas colunas do dataset.

- Por fim, imprimimos quantas colunas foram removidas e o novo formato da tabela (`df.shape`).

</small>

---

### 🧩 **Célula 8 - Remoção de Jogadores sem Targets**

<details>

<summary> Trecho do codigo em Python </summary>

```python
print("\n" + "=" * 80)
print("ETAPA 3: REMOÇÃO DE JOGADORES SEM TARGETS")
print("=" * 80)

antes = len(df)
df = df.dropna(subset=COLUNAS_TARGETS, how='all')
depois = len(df)

print(f"✅ Jogadores mantidos: {depois} (removidos: {antes-depois})")

```

</details>

<small> 📖 Explicação:

Nesta célula, garantimos que todos os registros (linhas) do dataset contenham pelo menos uma informação nos campos-alvo definidos em `COLUNAS_TARGETS`.

- Usamos `len(df)` para contar quantas linhas existem antes da limpeza (antes).

- O comando `df.dropna(subset=COLUNAS_TARGETS, how='all')` remove todas as linhas em que todos os campos de target estejam vazios (`NaN`).

- Calculamos novamente o tamanho do dataset (`depois`) para saber quantos registros restaram.

- Imprimimos a quantidade de jogadores mantidos e removidos após o filtro.

</small>

---

### **🧩 Célula 9 - Imputação de Valores Faltantes**

<details>

<summary> Trecho do codigo em Python </summary>

```python
# Numéricas: MEDIANA
colunas_num_imputar = [
    col for col in df.select_dtypes(include=[np.number]).columns
    if col not in COLUNAS_TARGETS and col not in COLUNAS_IGNORAR
]

if colunas_num_imputar:
    imputer_num = SimpleImputer(strategy='median')
    df[colunas_num_imputar] = imputer_num.fit_transform(df[colunas_num_imputar])
    print(f"✅ {len(colunas_num_imputar)} numéricas imputadas (mediana)")

# Categóricas: MODA
colunas_cat_imputar = [col for col in COLUNAS_CATEGORICAS if col in df.columns]

if colunas_cat_imputar:
    imputer_cat = SimpleImputer(strategy='most_frequent')
    df[colunas_cat_imputar] = imputer_cat.fit_transform(df[colunas_cat_imputar])
    print(f"✅ {len(colunas_cat_imputar)} categóricas imputadas (moda)")


```

</details>

<small> 📖 Explicação:

Nesta célula, tratamos os valores faltantes no dataset usando imputação — ou seja, substituímos valores ausentes (`NaN`) por valores calculados com base nos dados disponíveis.

- Colunas numéricas:

  - Identificamos todas as colunas numéricas usando `df.select_dtypes(include=[np.number])`.

  - Removemos as colunas-alvo (`COLUNAS_TARGETS`) e as colunas marcadas para ignorar (`COLUNAS_IGNORAR`).

  - Criamos um imputador (`SimpleImputer`) usando a estratégia `median` para substituir valores ausentes pela mediana daquela coluna.

  - Aplicamos a imputação usando `fit_transform`.

- Colunas categóricas:

  - Identificamos as colunas categóricas presentes (`COLUNAS_CATEGORICAS`).

  - Criamos um imputador usando a estratégia `most_frequent` para substituir valores ausentes pelo valor mais frequente da coluna (moda).

  - Aplicamos a imputação usando fit_transform.

</small>

---

### **🧩 Célula 10 - Tratamento de Outliers (IQR + Mediana)**

<details>

<summary> Trecho do codigo em Python </summary>

```python
colunas_outliers = [
    col for col in colunas_num_imputar
    if col not in ['QtdHorasSono', 'QtdHorasDormi', 'Acordar']
]

outliers_tratados = 0
for col in colunas_outliers:
    Q1 = df[col].quantile(0.25)
    Q3 = df[col].quantile(0.75)
    IQR = Q3 - Q1

    limite_inf = Q1 - 1.5 * IQR
    limite_sup = Q3 + 1.5 * IQR

    outliers_mask = (df[col] < limite_inf) | (df[col] > limite_sup)
    n_outliers = outliers_mask.sum()

    if n_outliers > 0:
        mediana = df[col].median()
        df.loc[outliers_mask, col] = mediana
        outliers_tratados += n_outliers

print(f"✅ {outliers_tratados} outliers tratados (substituídos por mediana)")

```

</details>

<small> 📖 Explicação:

Nesta célula, detectamos e tratamos outliers — valores extremos que podem distorcer análises e modelos — utilizando o método do Intervalo Interquartílico (IQR) e substituindo-os pela mediana da coluna.

- Primeiro identificamos as colunas numéricas a serem tratadas (`colunas_outliers`), excluindo colunas específicas como `QtdHorasSono`, `QtdHorasDormi` e `Acordar`.

- Para cada coluna:

  - Calculamos o **primeiro quartil** (`Q1`) e o **terceiro quartil** (`Q3`).

  - Determinamos o **Intervalo Interquartílico (IQR)** como `Q3 - Q1`.

  - Definimos limites inferior (`limite_inf`) e superior (`limite_sup`) como `Q1 - 1.5*IQR` e `Q3 + 1.5*IQR`, respectivamente.

  - Criamos uma máscara (`outliers_mask`) identificando valores fora desses limites.

  - Quando outliers são encontrados, substituímos esses valores pela mediana da coluna.

  - Contabilizamos quantos outliers foram tratados.

</small>

---

### **🧩 Célula 11 - One-Hot Encoding**

<details>

<summary> Trecho do codigo em Python </summary>

```python
colunas_cat_presentes = [col for col in COLUNAS_CATEGORICAS if col in df.columns]

if colunas_cat_presentes:
    colunas_antes = df.shape[1]
    df = pd.get_dummies(df, columns=colunas_cat_presentes, prefix=colunas_cat_presentes, drop_first=False)
    colunas_depois = df.shape[1]

    print(f"✅ One-Hot concluído: {colunas_antes} → {colunas_depois} colunas")

```

</details>

<small> 📖 Explicação:

Nesta célula, aplicamos a técnica de One-Hot Encoding, que transforma colunas categóricas em variáveis numéricas binárias, permitindo que algoritmos de machine learning trabalhem com esses dados.

- Identificamos as colunas categóricas presentes no dataset (`colunas_cat_presentes`) comparando `COLUNAS_CATEGORICAS` com as colunas reais do `df`.

- Guardamos o número inicial de colunas (`colunas_antes`).

- Usamos `pd.get_dummies()` para criar colunas binárias para cada categoria, mantendo o prefixo original para identificação.

- Não usamos `drop_first=True` para preservar todas as categorias.

- Calculamos o número final de colunas (`colunas_depois`) após a transformação.

- Imprimimos quantas colunas foram adicionadas no processo.

</small>

---

### **🧩 Célula 12 - Feature Engineering (Agregações)**

<details>

<summary> Trecho do codigo em Python </summary>

```python
# Agregação F11*
f11_cols = [c for c in df.columns if c.startswith('F11') and pd.api.types.is_numeric_dtype(df[c])]
if len(f11_cols) > 2:
    df['F11_mean'] = df[f11_cols].mean(axis=1)
    print(f"✅ F11_mean criada ({len(f11_cols)} colunas)")

# Agregação F07*
f07_cols = [c for c in df.columns if c.startswith('F07') and pd.api.types.is_numeric_dtype(df[c])]
if len(f07_cols) > 2:
    df['F07_mean'] = df[f07_cols].mean(axis=1)
    print(f"✅ F07_mean criada ({len(f07_cols)} colunas)")
```

</details>

<small> 📖 Explicação:

Nesta célula, realizamos Feature Engineering, criando novas colunas que representam agregações de variáveis relacionadas, para facilitar a análise e potencialmente melhorar a performance de modelos.

- **Agregação F11**:

  - Identificamos colunas cujo nome começa com "`F11`" e que são numéricas.

  - Se existirem mais de duas colunas nesse grupo, calculamos a média delas linha a linha (`mean(axis=1)`), criando a nova coluna `F11_mean`.

  - Exibimos quantas colunas foram utilizadas para essa agregação.

- **Agregação F07**:

  - De forma semelhante, identificamos colunas que começam com "`F07`" e que são numéricas.

  - Se houver mais de duas, calculamos a média e criamos `F07_mean`.

  - Exibimos quantas colunas contribuíram para essa agregação.

</small>

---

### **🧩 Célula 13 - 🔧 Correção 1 - Converter BOOL → INT**

<details>

<summary> Trecho do codigo em Python </summary>

```python
bool_cols = df.select_dtypes(include=['bool']).columns.tolist()

if bool_cols:
    print(f"📋 Convertendo {len(bool_cols)} colunas booleanas...")
    df[bool_cols] = df[bool_cols].astype(int)
    print(f"✅ VERDADEIRO/FALSO → 1/0")
    print(f"   Exemplo: {bool_cols[:3]}")
else:
    print("ℹ️  Nenhuma coluna booleana encontrada")
```

</details>

<small> 📖 Explicação:

Nesta célula, corrigimos o formato das colunas booleanas do dataset, transformando valores `True`/`False` em `1/0`. Isso é necessário porque muitos algoritmos de machine learning requerem que todos os dados sejam numéricos.

- Usamos `df.select_dtypes(include=['bool'])` para identificar todas as colunas que contêm valores booleanos (`True` ou `False`).

- Se houver colunas booleanas (`bool_cols`), exibimos quantas serão convertidas.

- Aplicamos `.astype(int)` para transformar os valores em números inteiros (`1` para `True`, `0` para `False`).

- Exibimos alguns exemplos de colunas convertidas para confirmar a ação.

- Caso não existam colunas booleanas, uma mensagem informativa é exibida.

</small>

---

### **🧩 Célula 14 - Feature Selection por Correlação**

<details>

<summary> Trecho do codigo em Python </summary>

```python
print("\n" + "=" * 80)
print("ETAPA 8: FEATURE SELECTION")
print("=" * 80)

features_numericas_finais = [
    col for col in df.columns
    if col not in COLUNAS_TARGETS
    and col not in COLUNAS_IGNORAR
    and pd.api.types.is_numeric_dtype(df[col])
]

print(f"📊 Features disponíveis: {len(features_numericas_finais)}")

corr_t1 = df[features_numericas_finais].corrwith(df['Target1']).abs()
corr_t2 = df[features_numericas_finais].corrwith(df['Target2']).abs()
corr_t3 = df[features_numericas_finais].corrwith(df['Target3']).abs()

corr_mean = (corr_t1 + corr_t2 + corr_t3) / 3

threshold = 0.20
features_selecionadas = corr_mean[corr_mean > threshold].index.tolist()

print(f"✅ Features mantidas: {len(features_selecionadas)} (threshold={threshold})")
print(f"✅ Features removidas: {len(features_numericas_finais) - len(features_selecionadas)}")

# Top 10
print(f"\n🏆 TOP 10 FEATURES:")
top10 = corr_mean.sort_values(ascending=False).head(10)
for idx, (feat, corr) in enumerate(top10.items(), 1):
    print(f"   {idx:2d}. {feat:30s} | Corr: {corr:.4f}")
```

</details>

<small> 📖 Explicação:

Nesta célula, realizamos a **seleção de features** com base na correlação entre variáveis numéricas e os targets (`Target1`, `Target2`, `Target3`). O objetivo é manter apenas as colunas que têm relevância estatística para o modelo.

- Definimos `features_numericas_finais` como todas as colunas numéricas que não são targets nem estão na lista `COLUNAS_IGNORAR`.

- Calculamos a correlação absoluta (`.abs()`) entre cada feature e cada target (`corr_t1`, `corr_t2`, `corr_t3`).

- Obtemos a média das correlações (`corr_mean`) para avaliar a importância geral da feature em relação a todos os targets.

- Definimos um **threshold** (limite) de 0.20; apenas features com correlação média acima desse valor são mantidas (`features_selecionadas`).

- Informamos quantas features foram mantidas e quantas removidas.

- Exibimos as **Top 10 features** com maior correlação média, ordenadas do maior para o menor valor, para referência.

</small>

---

### **🧩 Célula 15 - Criar DataFrames Finais**

<details>

<summary> Trecho do codigo em Python </summary>

```python
df_final_nao_normalizado = df[features_selecionadas + COLUNAS_TARGETS].copy()
print(f"✅ DataFrame NÃO-NORMALIZADO: {df_final_nao_normalizado.shape}")

df_final_normalizado = df_final_nao_normalizado.copy()

# Identificar categóricas (One-Hot) para NÃO normalizar
features_cat_onehot = [
    col for col in features_selecionadas
    if any(cat in col for cat in COLUNAS_CATEGORICAS)
]

features_numericas_normalizar = [
    col for col in features_selecionadas
    if col not in features_cat_onehot
]

print(f"🔢 Numéricas a normalizar: {len(features_numericas_normalizar)}")
print(f"📝 Categóricas (preservadas): {len(features_cat_onehot)}")

if features_numericas_normalizar:
    scaler = StandardScaler()
    df_final_normalizado[features_numericas_normalizar] = scaler.fit_transform(
        df_final_normalizado[features_numericas_normalizar]
    )
    print(f"✅ Normalização concluída!")

print(f"✅ DataFrame NORMALIZADO: {df_final_normalizado.shape}")
```

</details>

<small> 📖 Explicação:

Nesta célula, preparamos os **DataFrames finais** para análise e modelagem, criando versões normalizadas e não-normalizadas.

- Criamos `df_final_nao_normalizado` contendo apenas as **features selecionadas** e os **targets**, preservando o formato original.

- Criamos uma cópia chamada `df_final_normalizado` para aplicar normalização sem alterar o original.

- Identificamos colunas categóricas geradas pelo **One-Hot Encoding** (`features_cat_onehot`) para garantir que elas não sejam normalizadas.

- Definimos `features_numericas_normalizar` como todas as features numéricas restantes.

- Informamos quantas features numéricas serão normalizadas e quantas categóricas serão preservadas.

- Aplicamos o `StandardScaler` às features numéricas, padronizando-as para média zero e desvio padrão igual a um.

- Exibimos o tamanho final de cada DataFrame, garantindo que ambos estejam prontos para uso posterior.

</small>

---

### **🧩 Célula 16 - Exportar para Excel**

<details>

<summary> Trecho do codigo em Python </summary>

```python
output_file = 'Dados_Otimizados_V4.xlsx'

writer = pd.ExcelWriter(output_file, engine='xlsxwriter')
workbook = writer.book

header_format = workbook.add_format({
    'bold': True, 'text_wrap': True, 'valign': 'vcenter',
    'align': 'center', 'fg_color': '#1F4E78',
    'font_color': 'white', 'border': 1
})

title_format = workbook.add_format({
    'bold': True, 'font_size': 16,
    'fg_color': '#4472C4', 'font_color': 'white',
    'align': 'center', 'valign': 'vcenter', 'border': 2
})

# Aba 1: Dados não-normalizados
df_final_nao_normalizado.to_excel(writer, sheet_name='Dados_Para_Analise', index=False, startrow=2)
worksheet1 = writer.sheets['Dados_Para_Analise']
worksheet1.merge_range('A1:Z1', '📋 DADOS LIMPOS - Versão Otimizada', title_format)
worksheet1.freeze_panes(3, 0)

# Aba 2: Dados normalizados
df_final_normalizado.to_excel(writer, sheet_name='Dados_Para_Modelo', index=False, startrow=2)
worksheet2 = writer.sheets['Dados_Para_Modelo']
worksheet2.merge_range('A1:Z1', '📊 DADOS NORMALIZADOS - Para ML', title_format)
worksheet2.freeze_panes(3, 0)

# Aba 3: Resumo estatístico
summary = df_final_nao_normalizado[COLUNAS_TARGETS].describe().T
summary.to_excel(writer, sheet_name='Resumo_Estatistico', startrow=2)
worksheet3 = writer.sheets['Resumo_Estatistico']
worksheet3.merge_range('A1:I1', '📊 RESUMO ESTATÍSTICO', title_format)

# Aba 4: Correlações
correlations_df = pd.DataFrame({
    'Feature': corr_mean.index,
    'Corr_Target1': corr_t1.values,
    'Corr_Target2': corr_t2.values,
    'Corr_Target3': corr_t3.values,
    'Corr_Media': corr_mean.values,
    'Mantida': ['✅' if f in features_selecionadas else '❌' for f in corr_mean.index]
}).sort_values('Corr_Media', ascending=False)

correlations_df.to_excel(writer, sheet_name='Correlacoes', index=False, startrow=2)
worksheet4 = writer.sheets['Correlacoes']
worksheet4.merge_range('A1:F1', '🔍 ANÁLISE DE CORRELAÇÕES', title_format)

writer.close()

print(f"✅ Arquivo '{output_file}' criado!")
```

</details>

<small> 📖 Explicação:

Nesta célula, exportamos os resultados finais para um arquivo Excel estruturado, criando múltiplas abas para facilitar a análise e utilização dos dados.

- Definimos o nome do arquivo de saída como `Dados_Otimizados_V4.xlsx`.

- Criamos um escritor Excel (`pd.ExcelWriter`) usando o engine `xlsxwriter`.

- Definimos formatações personalizadas para cabeçalhos (`header_format`) e títulos (`title_format`) para melhor visualização.

**Aba 1 – Dados não-normalizados:**

- Exporta `df_final_nao_normalizado`.

- Inclui um título e congela a visualização para facilitar navegação.

**Aba 2 – Dados normalizados:**

- Exporta `df_final_normalizado`.

- Inclui título e congelamento de linhas.

**Aba 3 – Resumo estatístico:**

- Cria resumo com estatísticas descritivas dos targets (`describe().T`).

**Aba 4 – Correlações:**

- Exporta tabela contendo correlações médias entre features e targets.

- Indica quais features foram mantidas na seleção.

- Fecha o arquivo Excel (`writer.close()`) e confirma a criação.

Essa celula entrega um arquivo organizado e documentado, pronto para análise e uso em modelos de machine learning.

</small>

---

### ✅ **Resumo Geral da Etapa de Limpeza**

Após a execução de todas as células, o dataset estará pronto para ser utilizado nas próximas fases do projeto, com:

- Códigos inválidos convertidos em `NaN`.
- Colunas pouco informativas removidas.
- Targets completos e consistentes.
- Estrutura final reduzida, porém mais confiável e analisável.

---

</details>

<details>

<summary> 📊 Fase V2 - Modelagem </summary>

### **🧩 Célula 1 - Instalação de Bibliotecas**

<details>

<summary> Trecho do codigo em Python </summary>

```python
!pip install xgboost lightgbm catboost scikit-learn pandas matplotlib seaborn plotly -q
print("✅ Bibliotecas instaladas com sucesso!")
```

</details>

<small> 📖 Explicação:

Esta célula instala todas as bibliotecas necessárias para rodar o projeto de modelagem avançada e visualizações.

O comando `!pip install` funciona dentro de notebooks Jupyter ou Google Colab e serve para instalar pacotes Python diretamente no ambiente.  
Aqui, estamos instalando:

- **xgboost, lightgbm, catboost** → algoritmos de aprendizado de máquina muito eficientes para regressão e classificação.
- **scikit-learn** → biblioteca com ferramentas para pré-processamento, modelagem e avaliação de dados.
- **pandas** → manipulação e análise de dados em tabelas.
- **matplotlib, seaborn** → geração de gráficos e visualizações.
- **plotly** → criação de gráficos interativos.

</small>

---

### **🧩 Célula 2 - Importação de Bibliotecas**

<details>

<summary> Trecho do codigo em Python </summary>

```python
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.linear_model import LinearRegression, Ridge
from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
import xgboost as xgb
import lightgbm as lgb
from catboost import CatBoostRegressor
import pickle

warnings.filterwarnings('ignore')
sns.set_style('whitegrid')

print("\n" + "=" * 80)
print("     FASE 3 COMPLETA: MODELAGEM AVANÇADA + VISUALIZAÇÕES")
print("=" * 80)

```

</details>

<small> 📖 Explicação:

Nesta célula, carregamos todas as bibliotecas necessárias para manipulação, análise, modelagem e visualização dos dados.

- **pandas** e **numpy**: manipulação e cálculo de dados.
- **matplotlib.pyplot** e **seaborn**: criação de gráficos estáticos.
- **warnings**: para suprimir mensagens de aviso indesejadas.
- **sklearn.model_selection**: funções para divisão dos dados e validação cruzada.
- **sklearn.linear_model**: modelos de regressão Linear e Ridge.
- **sklearn.ensemble**: algoritmos ensemble como Random Forest e Gradient Boosting.
- **sklearn.metrics**: cálculo de métricas de avaliação como RMSE e R².
- **xgboost, lightgbm, catboost**: algoritmos de machine learning de alta performance.
- **pickle**: salvar e carregar modelos treinados.

As últimas linhas configuram o estilo dos gráficos (`sns.set_style('whitegrid')`) e imprimem um título indicando o início da fase 3.

</small>

---

### **🧩 Célula 3 - Carregamento dos Dados**

<details>

<summary> Trecho do codigo em Python </summary>

```python
df = pd.read_excel('Dados_para_modelo.xlsx')

print(f"✅ Dados carregados com sucesso. Shape: {df.shape}")
print(f"   Total de Jogadores: {len(df)}")
print(f"   Total de Colunas: {len(df.columns)}")

```

</details>

<small> 📖 Explicação:

Esta célula carrega os dados de um arquivo Excel chamado `'Dados_para_modelo.xlsx'` usando a biblioteca **pandas** e armazena em um DataFrame chamado `df`.

O DataFrame é uma estrutura de dados semelhante a uma tabela, muito utilizada em análise de dados.

- `df.shape` retorna uma tupla (número de linhas, número de colunas) para verificar o tamanho do dataset.
- `len(df)` retorna o número total de linhas, representando a quantidade de jogadores.
- `len(df.columns)` retorna o número total de colunas, representando as variáveis disponíveis.

Essas impressões garantem que os dados foram carregados corretamente antes de prosseguir.

</small>

---

### **🧩 Célula 4 - Separação de Features (X) e Targets (y)**

<details>

<summary> Trecho do codigo em Python </summary>

```python
targets = ['Target1', 'Target2', 'Target3']
X = df.drop(columns=targets)
y1 = df['Target1']
y2 = df['Target2']
y3 = df['Target3']

print(f"✅ Features (X) separadas. Total de features: {X.shape[1]}")
print(f"✅ Targets (y1, y2, y3) separados.")
```

</details>

<small> 📖 Explicação:

Nesta célula, o dataset é separado em duas partes principais:

- **Features (X)**: as variáveis de entrada que serão usadas para prever algo.
- **Targets (y)**: as variáveis que queremos prever.

No código:

- `targets` é uma lista com os nomes das colunas alvo (`Target1`, `Target2`, `Target3`).
- `X` contém todas as colunas exceto as targets, obtido com `df.drop(columns=targets)`.
- `y1`, `y2` e `y3` contêm cada uma das targets separadamente.

</small>

---

### **🧩 Célula 5 - Divisão em Dados de Treino e Teste (80/20)**

<details>

<summary> Trecho do codigo em Python </summary>

```python
X_train, X_test, y1_train, y1_test = train_test_split(X, y1, test_size=0.2, random_state=42)
_, _, y2_train, y2_test = train_test_split(X, y2, test_size=0.2, random_state=42)
_, _, y3_train, y3_test = train_test_split(X, y3, test_size=0.2, random_state=42)

print(f"✅ Dados divididos em 80% treino e 20% teste.")
print(f"   Tamanho do treino: {len(X_train)} jogadores")
print(f"   Tamanho do teste:  {len(X_test)} jogadores")
```

</details>

<small> 📖 Explicação:

Esta célula divide os dados em conjuntos de treino e teste usando a função `train_test_split` do **scikit-learn**.

- `test_size=0.2` significa que 20% dos dados serão usados para teste e 80% para treino.
- `random_state=42` garante que a divisão seja reproduzível (sempre igual).

Para cada target (`y1`, `y2`, `y3`), são criados conjuntos separados:

- `X_train`, `X_test`: dados de entrada para treino e teste.
- `y1_train`, `y1_test`, etc.: valores alvo correspondentes.

</small>

---

### **🧩 Célula 6 - Definição dos Modelos a Serem Testados**

<details>

<summary> Trecho do codigo em Python </summary>

```python
modelos = {
    'Linear Regression': LinearRegression(),
    'Ridge': Ridge(alpha=1.0),
    'Random Forest': RandomForestRegressor(n_estimators=100, max_depth=10, random_state=42, n_jobs=-1),
    'Gradient Boosting': GradientBoostingRegressor(n_estimators=100, max_depth=5, random_state=42),
    'XGBoost': xgb.XGBRegressor(n_estimators=100, max_depth=6, learning_rate=0.1, random_state=42, n_jobs=-1),
    'LightGBM': lgb.LGBMRegressor(n_estimators=100, max_depth=6, learning_rate=0.1, random_state=42, n_jobs=-1, verbose=-1),
    'CatBoost': CatBoostRegressor(iterations=100, depth=6, learning_rate=0.1, random_state=42, verbose=False)
}
print(f"✅ {len(modelos)} modelos definidos para teste.")
```

</details>

<small> 📖 Explicação:

Nesta célula definimos um dicionário chamado `modelos` contendo vários algoritmos de machine learning para serem testados no projeto.

Cada chave é o nome do modelo e cada valor é uma instância do modelo com parâmetros definidos:

- **Linear Regression** e **Ridge**: modelos lineares básicos.
- **Random Forest**: modelo ensemble baseado em árvores, com parâmetros como `n_estimators` (número de árvores) e `max_depth` (profundidade máxima).
- **Gradient Boosting**: modelo ensemble que ajusta sequencialmente as árvores para reduzir erros.
- **XGBoost, LightGBM, CatBoost**: algoritmos avançados e muito eficientes para regressão, com parâmetros como `learning_rate`, `max_depth` e número de iterações (`n_estimators` ou `iterations`).

</small>

---

### **🧩 Célula 7 - Função de Treinamento e Avaliação**

<details>

<summary> Trecho do codigo em Python </summary>

```python
def treinar_avaliar_modelo(modelo, X_train, X_test, y_train, y_test):
    """Função para treinar, prever e avaliar um modelo, retornando as métricas e o modelo treinado."""
    modelo.fit(X_train, y_train)
    y_pred = modelo.predict(X_test)
    r2 = r2_score(y_test, y_pred)
    rmse = np.sqrt(mean_squared_error(y_test, y_pred))
    mae = mean_absolute_error(y_test, y_pred)
    return {'modelo': modelo, 'y_pred': y_pred, 'r2': r2, 'rmse': rmse, 'mae': mae}

```

</details>

<small> 📖 Explicação:

Esta célula define uma função chamada `treinar_avaliar_modelo` que serve para treinar um modelo de machine learning e avaliar seu desempenho.

Parâmetros da função:

- `modelo`: objeto do modelo a ser treinado.
- `X_train`, `X_test`: dados de entrada para treino e teste.
- `y_train`, `y_test`: valores alvo para treino e teste.

O processo realizado dentro da função:

1. `modelo.fit(X_train, y_train)` → treina o modelo com os dados de treino.
2. `modelo.predict(X_test)` → faz previsões com os dados de teste.
3. Calcula métricas de avaliação:
   - **R² (r2_score)**: mede a qualidade da previsão (quanto mais próximo de 1, melhor).
   - **RMSE (root mean squared error)**: erro médio quadrático.
   - **MAE (mean absolute error)**: erro absoluto médio.

A função retorna um dicionário com o modelo treinado, previsões e métricas calculadas.

</small>

---

### **🧩 Célula 8 - Treinamento e Avaliação de Todos os Modelos**

<details>

<summary> Trecho do codigo em Python </summary>

```python
print("\n" + "=" * 80)
print("ETAPA 5: TREINAMENTO E AVALIAÇÃO DOS MODELOS")
print("=" * 80)

# --- Target 1 ---
resultados_t1 = {}
for nome, modelo in modelos.items():
    resultados_t1[nome] = treinar_avaliar_modelo(type(modelo)(**modelo.get_params()), X_train, X_test, y1_train, y1_test)
melhor_t1 = max(resultados_t1.items(), key=lambda x: x[1]['r2'])
print(f"🎯 Target 1 | Melhor Modelo: {melhor_t1[0]:<20} | R² = {melhor_t1[1]['r2']:.4f}")

# --- Target 2 ---
resultados_t2 = {}
for nome, modelo in modelos.items():
    resultados_t2[nome] = treinar_avaliar_modelo(type(modelo)(**modelo.get_params()), X_train, X_test, y2_train, y2_test)
melhor_t2 = max(resultados_t2.items(), key=lambda x: x[1]['r2'])
print(f"🎯 Target 2 | Melhor Modelo: {melhor_t2[0]:<20} | R² = {melhor_t2[1]['r2']:.4f}")

# --- Target 3 ---
resultados_t3 = {}
for nome, modelo in modelos.items():
    resultados_t3[nome] = treinar_avaliar_modelo(type(modelo)(**modelo.get_params()), X_train, X_test, y3_train, y3_test)
melhor_t3 = max(resultados_t3.items(), key=lambda x: x[1]['r2'])
print(f"🎯 Target 3 | Melhor Modelo: {melhor_t3[0]:<20} | R² = {melhor_t3[1]['r2']:.4f}")
```

</details>

<small> 📖 Explicação:

Esta célula realiza o treinamento e avaliação de todos os modelos definidos para cada target (Target1, Target2, Target3).

O processo é feito em três blocos:

1. Para cada target, criamos um dicionário (`resultados_t1`, `resultados_t2`, `resultados_t3`) para armazenar os resultados.
2. Usamos um loop `for` para percorrer cada modelo definido no dicionário `modelos`.
   - `type(modelo)(**modelo.get_params())` cria uma nova instância do modelo com os mesmos parâmetros.
   - Chamamos a função `treinar_avaliar_modelo` para treinar e avaliar o modelo.
3. Usamos `max(..., key=lambda x: x[1]['r2'])` para selecionar o modelo com melhor R² para cada target.

Ao final, imprimimos o nome do melhor modelo e seu R² para cada target.  
Isso ajuda a identificar qual modelo performou melhor para cada variável alvo.

</small>

---

### **🧩 Célula 9 - Visualização 1: Previsto vs. Real (Gráfico de Dispersão)**

<details>

<summary> Trecho do codigo em Python </summary>

```python
fig, axes = plt.subplots(1, 3, figsize=(18, 5))
fig.suptitle('Análise de Previsão vs. Valor Real para os Melhores Modelos', fontsize=16, fontweight='bold')

# Gráfico para Target 1
y1_pred = melhor_t1[1]['y_pred']
axes[0].scatter(y1_test, y1_pred, alpha=0.7, color='blue', edgecolors='k')
axes[0].plot([y1_test.min(), y1_test.max()], [y1_test.min(), y1_test.max()], 'r--', lw=2, label='Linha Perfeita')
axes[0].set_xlabel('Valores Reais', fontsize=12)
axes[0].set_ylabel('Valores Previstos', fontsize=12)
axes[0].set_title(f'Target 1 - {melhor_t1[0]}\nR²={melhor_t1[1]["r2"]:.3f}', fontsize=14)
axes[0].legend()
axes[0].grid(True)

# Gráfico para Target 2
y2_pred = melhor_t2[1]['y_pred']
axes[1].scatter(y2_test, y2_pred, alpha=0.7, color='green', edgecolors='k')
axes[1].plot([y2_test.min(), y2_test.max()], [y2_test.min(), y2_test.max()], 'r--', lw=2, label='Linha Perfeita')
axes[1].set_xlabel('Valores Reais', fontsize=12)
axes[1].set_ylabel('Valores Previstos', fontsize=12)
axes[1].set_title(f'Target 2 - {melhor_t2[0]}\nR²={melhor_t2[1]["r2"]:.3f}', fontsize=14)
axes[1].legend()
axes[1].grid(True)

# Gráfico para Target 3
y3_pred = melhor_t3[1]['y_pred']
axes[2].scatter(y3_test, y3_pred, alpha=0.7, color='purple', edgecolors='k')
axes[2].plot([y3_test.min(), y3_test.max()], [y3_test.min(), y3_test.max()], 'r--', lw=2, label='Linha Perfeita')
axes[2].set_xlabel('Valores Reais', fontsize=12)
axes[2].set_ylabel('Valores Previstos', fontsize=12)
axes[2].set_title(f'Target 3 - {melhor_t3[0]}\nR²={melhor_t3[1]["r2"]:.3f}', fontsize=14)
axes[2].legend()
axes[2].grid(True)

plt.tight_layout(rect=[0, 0, 1, 0.96])
plt.savefig('grafico_dispersao_previsto_vs_real.png', dpi=300, bbox_inches='tight')
print("✅ Gráfico de Dispersão (Previsto vs. Real) salvo como 'grafico_dispersao_previsto_vs_real.png'")
```

</details>

<small> 📖 Explicação:

Esta célula cria gráficos de dispersão comparando valores previstos pelos melhores modelos com os valores reais para cada target (Target1, Target2, Target3).

O processo inclui:

- Criação de uma figura com três subplots (`plt.subplots(1, 3, figsize=(18, 5))`).
- Para cada target:
  - Plotar valores reais (`y_test`) vs. valores previstos (`y_pred`) usando `scatter()`.
  - Adicionar uma linha pontilhada (`plot()`) representando a previsão perfeita (quando previsto = real).
  - Configurar título, rótulos e legenda.
- `plt.tight_layout()` ajusta o espaçamento entre gráficos.
- `plt.savefig()` salva a figura como `'grafico_dispersao_previsto_vs_real.png'`.

Esse tipo de gráfico ajuda a visualizar a precisão do modelo e identificar padrões ou desvios.

</small>

---

### **🧩 Célula 10 - Visualização 2: Importância das Features**

<details>

<summary> Trecho do codigo em Python </summary>

```python
def plotar_importancia(melhor_modelo_info, target_name, feature_names, ax):
    """Função auxiliar para plotar a importância das features em um eixo do matplotlib."""
    nome_modelo = melhor_modelo_info[0]
    modelo = melhor_modelo_info[1]['modelo']

    if hasattr(modelo, 'feature_importances_'):
        importances = modelo.feature_importances_
    else: # CatBoost
        importances = modelo.get_feature_importance()

    df_importances = pd.DataFrame({'feature': feature_names, 'importance': importances}).sort_values('importance', ascending=True).tail(15)

    ax.barh(df_importances['feature'], df_importances['importance'], color='darkcyan')
    ax.set_title(f'Top 15 Features - {target_name}\n(Modelo: {nome_modelo})', fontsize=14)
    ax.set_xlabel('Importância')

fig, axes = plt.subplots(1, 3, figsize=(20, 8))
fig.suptitle('Análise de Importância das Features para os Melhores Modelos', fontsize=16, fontweight='bold')

plotar_importancia(melhor_t1, 'Target 1', X.columns, axes[0])
plotar_importancia(melhor_t2, 'Target 2', X.columns, axes[1])
plotar_importancia(melhor_t3, 'Target 3', X.columns, axes[2])

plt.tight_layout(rect=[0, 0, 1, 0.95])
plt.savefig('grafico_feature_importance.png', dpi=300, bbox_inches='tight')
print("✅ Gráfico de Importância das Features salvo como 'grafico_feature_importance.png'")
```

</details>

<small> 📖 Explicação:

Esta célula cria gráficos mostrando a importância das features para os melhores modelos de cada target.

O processo inclui:

- Definição da função `plotar_importancia()`, que:

  - Recebe informações do melhor modelo (`melhor_modelo_info`), o nome do target, os nomes das features e um eixo (`ax`) para plotagem.
  - Verifica se o modelo possui atributo `feature_importances_` (método comum em modelos de árvore). Caso seja CatBoost, usa `get_feature_importance()`.
  - Cria um DataFrame com nomes e importâncias das features, ordenando e selecionando as 15 mais importantes.
  - Plota um gráfico de barras horizontais (`barh`).

- Criação de uma figura com três subplots para cada target.
- Chamadas da função `plotar_importancia` para cada target.
- Ajuste de layout e salvamento do gráfico como `'grafico_feature_importance.png'`.

Esses gráficos ajudam a entender quais variáveis têm maior influência na previsão do modelo.

</small>

---

### **🧩 Célula 11 - Salvando os Melhores Modelos**

<details>

<summary> Trecho do codigo em Python </summary>

```python
with open('modelo_target1_final.pkl', 'wb') as f: pickle.dump(melhor_t1[1]['modelo'], f)
print(f"✅ Modelo para Target 1 ({melhor_t1[0]}) salvo como 'modelo_target1_final.pkl'")

with open('modelo_target2_final.pkl', 'wb') as f: pickle.dump(melhor_t2[1]['modelo'], f)
print(f"✅ Modelo para Target 2 ({melhor_t2[0]}) salvo como 'modelo_target2_final.pkl'")

with open('modelo_target3_final.pkl', 'wb') as f: pickle.dump(melhor_t3[1]['modelo'], f)
print(f"✅ Modelo para Target 3 ({melhor_t3[0]}) salvo como 'modelo_target3_final.pkl'")
```

</details>

<small> 📖 Explicação:

Esta célula salva os melhores modelos encontrados para cada target usando a biblioteca **pickle**.

O processo:

- Para cada target, abrimos um arquivo `.pkl` em modo de escrita binária (`'wb'`).
- Usamos `pickle.dump()` para salvar o modelo treinado (`melhor_tX[1]['modelo']`).
- Cada arquivo recebe um nome correspondente ao target (`modelo_target1_final.pkl`, etc.).
- Mensagens confirmam que os modelos foram salvos com sucesso.

Esses arquivos `.pkl` podem ser carregados posteriormente para fazer previsões sem precisar treinar novamente o modelo.

</small>

---

### **🧩 Célula 12 - Relatório Final dos Resultados**

<details>

<summary> Trecho do codigo em Python </summary>

```python
print("\n" + "=" * 80)
print("🎉 FASE 3 COMPLETA - RELATÓRIO FINAL 🎉")
print("=" * 80)

print("\n📊 RESUMO DOS MELHORES MODELOS:\n")

print(f"  TARGET 1")
print(f"  - Melhor Modelo: {melhor_t1[0]}")
print(f"  - R² (R-quadrado): {melhor_t1[1]['r2']:.4f}  (Explica ~{melhor_t1[1]['r2']:.1%} da variância)")
print(f"  - RMSE (Erro Médio): {melhor_t1[1]['rmse']:.2f} pontos")
print(f"  - MAE (Erro Absoluto Médio): {melhor_t1[1]['mae']:.2f} pontos\n")

print(f"  TARGET 2")
print(f"  - Melhor Modelo: {melhor_t2[0]}")
print(f"  - R² (R-quadrado): {melhor_t2[1]['r2']:.4f}  (Explica ~{melhor_t2[1]['r2']:.1%} da variância)")
print(f"  - RMSE (Erro Médio): {melhor_t2[1]['rmse']:.2f} pontos")
print(f"  - MAE (Erro Absoluto Médio): {melhor_t2[1]['mae']:.2f} pontos\n")

print(f"  TARGET 3")
print(f"  - Melhor Modelo: {melhor_t3[0]}")
print(f"  - R² (R-quadrado): {melhor_t3[1]['r2']:.4f}  (Explica ~{melhor_t3[1]['r2']:.1%} da variância)")
print(f"  - RMSE (Erro Médio): {melhor_t3[1]['rmse']:.2f} pontos")
print(f"  - MAE (Erro Absoluto Médio): {melhor_t3[1]['mae']:.2f} pontos\n")

print("📁 ARQUIVOS GERADOS:")
print("  ✅ modelo_target1_final.pkl")
print("  ✅ modelo_target2_final.pkl")
print("  ✅ modelo_target3_final.pkl")
print("  ✅ grafico_dispersao_previsto_vs_real.png")
print("  ✅ grafico_feature_importance.png")

print("\n🚀 PRÓXIMOS PASSOS:")
print("  1. Usar os arquivos '.pkl' salvos para carregar os modelos no seu backend (Node.js/FastAPI).")
print("  2. Criar as rotas da API que recebem novos dados de jogadores e usam os modelos para prever os targets.")
print("  3. Desenvolver o dashboard interativo que consome essa API e exibe os resultados e insights.")
print("  4. Preparar a apresentação de slides contando a história do projeto, dos dados aos resultados.")

print("\n✨ Excelente trabalho! A etapa de modelagem e análise está concluída. ✨")
```

</details>

<small> 📖 Explicação:

Esta célula gera um relatório final resumindo os resultados obtidos na fase de modelagem.

O conteúdo inclui:

- **Resumo dos Melhores Modelos** para cada target, exibindo:
  - Nome do modelo com melhor performance.
  - R² (R-quadrado): mede a qualidade da previsão.
  - RMSE: erro médio quadrático.
  - MAE: erro absoluto médio.
- **Lista dos arquivos gerados** no processo, incluindo modelos `.pkl` e gráficos.
- **Próximos passos sugeridos**, como integrar os modelos salvos a uma API e criar dashboards interativos.

</small>

---

</details>

---

**📈 Visão Geral dos Resultados da Modelagem**

<small>
Nesta fase, o dataset limpo e otimizado foi utilizado para treinar e avaliar **7 algoritmos de regressão diferentes**, com o objetivo de encontrar o melhor modelo para prever cada uma das três métricas-alvo.

Após o treinamento e a validação, os modelos com melhor desempenho, medido pelo coeficiente de determinação (R²), foram:

- **Target 1**: **CatBoost**, com **R² = 0.577**. Isso indica que o modelo consegue explicar aproximadamente **57,7%** da variação nos dados.
- **Target 2**: **Random Forest**, com **R² = 0.406**, explicando cerca de **40,6%** da variância.
- **Target 3**: **Random Forest**, com **R² = 0.420**, explicando aproximadamente **42,0%** da variância.

A imagem abaixo apresenta uma análise visual da performance desses três modelos. Cada gráfico de dispersão compara os **valores reais** (eixo X) com os **valores previstos** pelo modelo (eixo Y). A "Linha Perfeita" (tracejada em vermelho) representa o cenário ideal, onde a previsão é exatamente igual ao valor real.

Quanto mais próximos os pontos estiverem dessa linha, mais precisas são as previsões do modelo. Essa visualização ajuda a entender rapidamente a capacidade preditiva dos modelos escolhidos.
</small>

![alt text](data/processed/02_model_ready/grafico_dispersao_previsto_vs_real.png)
</file>

<file path="dashboard/frontend/Dockerfile">
FROM python:3.10-slim

WORKDIR /app

# Instala dependências
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copia o código da aplicação
COPY dashboard_dash.py .

# Expor a porta do Dash (8050 é o padrão do Plotly Dash)
EXPOSE 8050

# Comando para rodar a aplicação Dash
# O Dash é executado como um script Python normal (dashboard_dash.py), 
# onde a porta 8050 e o host 0.0.0.0 já estão definidos internamente.
CMD ["python", "dashboard_dash.py"]
</file>

<file path="dashboard/frontend/requirements.txt">
requests # Para fazer chamadas HTTP ao Flask
pandas
plotly-express
plotly
xlsxwriter
shap
matplotlib
dash 
dash-bootstrap-components 
dash-core-components 
dash-html-components 
dash-table 
numpy 
shap
</file>

<file path="dashboard/docker-compose.yml">
version: '3.8'

services:
  # 1. SERVIÇO DO BANCO DE DADOS (PostgreSQL)
  db:
    image: postgres:15-alpine
    restart: always
    environment:
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}
    ports:
      - "5433:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data/
    networks:
      - daruma_net

  # 2. SERVIÇO DA API (Flask/FastAPI)
  backend:
    build: ./backend
    restart: always
    environment:
      # Variáveis de ambiente para o Flask se conectar ao DB
      DATABASE_URL: postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@db:5432/${POSTGRES_DB}
      JWT_SECRET_KEY: ${JWT_SECRET_KEY}
    depends_on:
      - db
    networks:
      - daruma_net

  # 3. SERVIÇO DO DASHBOARD (PLOTLY DASH)
  frontend:
    build:
      context: ./frontend  # Assumindo que o Dockerfile e o código estão em uma pasta 'frontend'
    restart: always
    environment:
      # Variável para o Dash saber onde está o Backend
      BACKEND_URL: http://backend:5000
    depends_on:
      - backend
    ports:
      # CORREÇÃO: Mapeando a porta padrão do Dash (8050)
      - "127.0.0.1:8050:8050"
    networks:
      - daruma_net

networks:
  daruma_net:
    driver: bridge

volumes:
  postgres_data:
</file>

<file path="dashboard/backend/Dockerfile">
FROM python:3.10-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copia todos os arquivos da aplicação
COPY . .

EXPOSE 5000

# Comando para rodar a aplicação com Uvicorn (servidor ASGI para FastAPI)
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "5000"]
</file>

<file path="dashboard/backend/requirements.txt">
fastapi
uvicorn[standard]
python-multipart
sqlalchemy
psycopg2-binary
python-jose[cryptography]
pandas
scikit-learn==1.7.2 # Fixando a versão para consistência
joblib
openpyxl
catboost
shap
Flask-Bcrypt 
optuna
lightgbm
xgboost
</file>

<file path="dashboard/frontend/dashboard_dash.py">
import dash
from dash import dcc, html, dash_table
from dash.dependencies import Input, Output, State
import dash_bootstrap_components as dbc
import requests
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go # Import necessário para o gráfico SHAP
import os
from io import BytesIO
import base64

# --- Configuração ---
BACKEND_URL = os.getenv('BACKEND_URL', 'http://localhost:5000') 
app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP], suppress_callback_exceptions=True)
app.title = "🎯 Projeto Daruma: Dashboard de Previsão"
server = app.server # Para o Gunicorn

# =============================================================================
# FUNÇÕES DE API E UTILITÁRIAS
# =============================================================================

def login_api(username, password):
    """Chama a API de login do backend FastAPI."""
    try:
        # ----> CORREÇÃO AQUI: Trocar 'json=' por 'data=' <----
        # FastAPI com OAuth2PasswordRequestForm espera dados de formulário.
        login_data = {'username': username, 'password': password}
        response = requests.post(f"{BACKEND_URL}/login", data=login_data)
        
        if response.status_code == 200:
            return response.json().get('access_token'), None
        else:
            # Tenta extrair a mensagem de erro detalhada do FastAPI
            detail = response.json().get('detail', 'Erro desconhecido no login.')
            return None, detail
            
    except requests.exceptions.RequestException as e:
        return None, f"Erro de conexão com o backend: {e}"
    
def register_api(username, password):
    """Chama a API de registro do backend."""
    try:
        response = requests.post(f"{BACKEND_URL}/register", json={'username': username, 'password': password})
        return (True, response.json().get('msg')) if response.status_code == 201 else (False, response.json().get('msg', 'Erro desconhecido'))
    except requests.exceptions.RequestException as e:
        return False, f"Erro de conexão com o backend: {e}"

def parse_contents(contents):
    """Decodifica o conteúdo do arquivo enviado via dcc.Upload."""
    _, content_string = contents.split(',')
    decoded = base64.b64decode(content_string)
    return decoded

def convert_df_to_excel(df):
    """Converte um DataFrame para um arquivo Excel em memória e o codifica em base64."""
    output = BytesIO()
    with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
        df.to_excel(writer, index=False, sheet_name='Previsoes')
    excel_data = output.getvalue()
    return base64.b64encode(excel_data).decode('utf-8')

# =============================================================================
# COMPONENTES DE LAYOUT
# =============================================================================

store = dcc.Store(id='session-store', storage_type='session', data={'logged_in': False, 'token': None, 'username': None, 'last_results': None})
upload_data_store = dcc.Store(id='upload-data-store', storage_type='memory')

auth_layout = dbc.Container(
    dbc.Row(
        dbc.Col(
            dbc.Card(
                dbc.CardBody([
                    html.H3("🎯 Bem-vindo ao Projeto Daruma", className="text-center mb-4"),
                    dbc.Alert(id='auth-message', color='danger', is_open=False),
                    dbc.RadioItems(
                        id='auth-mode',
                        options=[
                            {'label': 'Login', 'value': 'login'},
                            {'label': 'Registrar', 'value': 'register'}
                        ],
                        value='login',
                        inline=True,
                        className="mb-3 d-flex justify-content-center"
                    ),
                    dbc.Input(id='username-input', placeholder='Usuário', type='text', className="mb-3"),
                    dbc.Input(id='password-input', placeholder='Senha', type='password', className="mb-3"),
                    dbc.Button("Acessar", id='auth-button', color='primary', n_clicks=0, className="w-100")
                ])
            ),
            width=4
        ),
        justify="center",
        align="center",
        className="vh-100"
    ),
    fluid=True
)

main_dashboard_layout = dbc.Container([
    dbc.Row([
        dbc.Col(html.H2("🎯 Projeto Daruma: Dashboard de Previsão"), width='auto'),
        dbc.Col(html.Div(id='welcome-user-message'), className="text-center my-auto"),
        dbc.Col(dbc.Button("Logout", id='logout-button', color='danger'), width='auto', className="ms-auto")
    ], className="mb-4 align-items-center"),
    
    dbc.Tabs([
        dbc.Tab(label="📊 Nova Previsão", tab_id="predict-tab", children=[
            dcc.Upload(
                id='upload-data',
                children=html.Div(['Arraste e solte ou ', html.A('Selecione um Arquivo Excel (.xlsx)')]),
                style={'width': '100%', 'height': '60px', 'lineHeight': '60px', 'borderWidth': '1px', 'borderStyle': 'dashed', 'borderRadius': '5px', 'textAlign': 'center', 'margin': '20px 0'},
                multiple=False
            ),
            html.Div(id='upload-status', className="mb-3"),
            dbc.Button("Executar Previsão", id='predict-button', color='success', className="mb-4", disabled=True),
            dcc.Loading(id="loading-output", type="default", children=[
                html.Div(id='prediction-results-output'),
                html.Div(id='shap-analysis-output', className="mt-4")
            ])
        ]),
        dbc.Tab(label="🧠 Análise do Modelo", tab_id="analysis-tab", children=[
            html.H3("Ranking de Importância das Features", className="mt-3"),
            html.P("Este gráfico mostra as 20 features mais importantes que o modelo utiliza para fazer as previsões para cada target."),
            dbc.Button("Carregar Análise", id='load-analysis-button', color='primary', className="mb-3"),
            dcc.Loading(id="loading-analysis", type="default", children=html.Div(id='feature-importance-output'))
        ]),
        dbc.Tab(label="⏳ Histórico", tab_id="history-tab", children=[
            html.H3("Histórico de Uploads", className="mt-3"),
            dbc.Button("Carregar Histórico", id='load-history-button', color='secondary', className="mb-3"),
            html.Div(id='history-output')
        ]),
    ], id="tabs", active_tab="predict-tab"),
], fluid=True)

app.layout = html.Div([dcc.Location(id='url', refresh=False), store, upload_data_store, html.Div(id='page-content')])

# =============================================================================
# FUNÇÕES DE RENDERIZAÇÃO
# =============================================================================

def render_prediction_results(predictions_data):
    """
    ### FUNÇÃO SIMPLIFICADA ###
    Gera o layout dos resultados da previsão com tabela ordenável e gráfico de barras.
    """
    if not predictions_data:
        return dbc.Alert("Nenhuma previsão retornada.", color="warning")

    df_output = pd.DataFrame(predictions_data)
    excel_base64 = convert_df_to_excel(df_output)

    # Gráfico de barras das previsões
    # O melt transforma as colunas de previsão em linhas, facilitando a plotagem
    df_melted = df_output.melt(
        id_vars='Código de Acesso', 
        value_vars=['Previsão T1', 'Previsão T2', 'Previsão T3'], 
        var_name='Target', 
        value_name='Valor Previsto'
    )
    fig_bar = px.bar(
        df_melted, 
        x='Código de Acesso', 
        y='Valor Previsto', 
        color='Target', 
        title="Previsões dos Targets por Jogador", 
        barmode='group',
        labels={'Código de Acesso': 'Jogador', 'Valor Previsto': 'Valor da Previsão'}
    )
    fig_bar.update_layout(xaxis={'categoryorder':'total descending'}) # Ordena o gráfico pelo valor total

    return html.Div([
        html.H4("Resultados da Previsão", className="mt-4"),
        # A tabela agora é ordenável pelo usuário clicando nos cabeçalhos
        dash_table.DataTable(
            id='predictions-table',
            columns=[{"name": i, "id": i} for i in df_output.columns],
            data=df_output.to_dict('records'),
            style_table={'overflowX': 'auto'},
            sort_action="native",  # Habilita a ordenação pelo frontend
            filter_action="native", # Habilita filtros simples
            page_action="native",
            page_current=0,
            page_size=10,
            style_header={'backgroundColor': 'rgb(230, 230, 230)', 'fontWeight': 'bold'}
        ),
        html.A(
            dbc.Button("📥 Baixar Resultados (.xlsx)", color="info", className="mt-3"),
            id='download-link',
            href=f"data:application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;base64,{excel_base64}",
            download="previsoes_daruma.xlsx"
        ),
        html.H4("Comparação Visual", className="mt-4"),
        dcc.Graph(id='bar-chart', figure=fig_bar)
    ])

# =============================================================================
# CALLBACKS (SEM ALTERAÇÕES NAS SEÇÕES DE AUTENTICAÇÃO E UPLOAD)
# =============================================================================

@app.callback(
    Output('page-content', 'children'),
    [Input('session-store', 'data'), Input('url', 'pathname')]
)
def render_page_content(data, pathname):
    is_logged_in = data and data.get('logged_in')

    if pathname == '/dashboard' and is_logged_in:
        return main_dashboard_layout
    elif pathname == '/logout':
        # Limpa os dados da sessão ao fazer logout
        data['logged_in'] = False
        data['token'] = None
        data['username'] = None
        data['last_results'] = None
        return auth_layout
    elif is_logged_in:
        # Se estiver logado mas a URL for a raiz ('/'), mostra o dashboard
        return main_dashboard_layout
    else:
        # Se não estiver logado, sempre mostra a tela de login
        return auth_layout
@app.callback(
    [
        Output('url', 'pathname', allow_duplicate=True), # <-- ADICIONE ESTA LINHA
        Output('session-store', 'data'),
        Output('auth-message', 'children'),
        Output('auth-message', 'is_open')
    ],
    [Input('auth-button', 'n_clicks')],
    [
        State('auth-mode', 'value'),
        State('username-input', 'value'),
        State('password-input', 'value'),
        State('session-store', 'data')
    ],
    prevent_initial_call=True
)
def handle_auth(n_clicks, auth_mode, username, password, data):
    if not username or not password:
        # dash.no_update para a URL, pois não queremos redirecionar
        return dash.no_update, dash.no_update, "Usuário e senha são obrigatórios.", True

    if auth_mode == 'login':
        token, error = login_api(username, password)
        if token:
            data.update({'logged_in': True, 'token': token, 'username': username})
            # Redireciona para /dashboard em caso de sucesso
            return '/dashboard', data, "", False
        # Se o login falhar, não redireciona
        return dash.no_update, dash.no_update, error, True
        
    elif auth_mode == 'register':
        success, message = register_api(username, password)
        # Não redireciona no registro, apenas mostra a mensagem
        return dash.no_update, dash.no_update, message, True
        
    return dash.no_update, dash.no_update, "", False

@app.callback(Output('welcome-user-message', 'children'), Input('session-store', 'data'))
def update_welcome_message(data):
    return f"Bem-vindo(a), {data.get('username')}!" if data and data.get('logged_in') else ""

@app.callback(
    [Output('url', 'pathname', allow_duplicate=True),
     Output('session-store', 'data', allow_duplicate=True)],
    [Input('logout-button', 'n_clicks')],
    [State('session-store', 'data')],
    prevent_initial_call=True
)
def handle_logout(n_clicks, data):
    if n_clicks:
        data.update({'logged_in': False, 'token': None, 'username': None, 'last_results': None})
        return '/logout', data
    return dash.no_update, dash.no_update

@app.callback(
    [Output('upload-data-store', 'data'), Output('upload-status', 'children'), Output('predict-button', 'disabled')],
    [Input('upload-data', 'contents')],
    [State('upload-data', 'filename')],
    prevent_initial_call=True
)
def handle_upload(contents, filename):
    if contents:
        decoded_content = parse_contents(contents)
        stored_data = {'filename': filename, 'contents': base64.b64encode(decoded_content).decode('utf-8')}
        return stored_data, html.Div(['Arquivo selecionado: ', html.B(filename)]), False
    return None, "", True

# --- CALLBACK DE PREVISÃO (Simplificado) ---
@app.callback(
    [Output('prediction-results-output', 'children'), Output('session-store', 'data', allow_duplicate=True)],
    [Input('predict-button', 'n_clicks')],
    [State('session-store', 'data'), State('upload-data-store', 'data')],
    prevent_initial_call=True
)
def run_prediction(n_clicks, session_data, upload_data):
    if not n_clicks or not upload_data or not session_data.get('token'):
        raise dash.exceptions.PreventUpdate

    headers = {'Authorization': f'Bearer {session_data["token"]}'}
    files = {'file': (upload_data['filename'], base64.b64decode(upload_data['contents']), 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')}
    
    try:
        response = requests.post(f"{BACKEND_URL}/predict", headers=headers, files=files)
        if response.status_code == 200:
            response_json = response.json()
            predictions_list = response_json.get('predictions')
            session_data['last_results'] = response_json
            return render_prediction_results(predictions_list), session_data
        else:
            return dbc.Alert(f"Erro na API: {response.json().get('msg')}", color="danger"), dash.no_update
    except requests.exceptions.RequestException as e:
        return dbc.Alert(f"Erro de conexão com o backend: {e}", color="danger"), dash.no_update

# --- CALLBACKS DE HISTÓRICO E ANÁLISE (Sem alterações) ---
@app.callback(
    Output('history-output', 'children'),
    Input('load-history-button', 'n_clicks'),
    State('session-store', 'data'),
    prevent_initial_call=True
)
def load_history(n_clicks, data):
    if not data or not data.get('token'):
        return dbc.Alert("Sessão inválida.", color="danger")
    
    headers = {'Authorization': f'Bearer {data["token"]}'}
    try:
        response = requests.get(f"{BACKEND_URL}/history", headers=headers)
        if response.status_code == 200:
            history_data = response.json()
            if not history_data:
                return dbc.Alert("Nenhum histórico encontrado.", color="info")
            df_history = pd.DataFrame(history_data)
            return dash_table.DataTable(
                columns=[{'name': 'Data do Upload', 'id': 'timestamp'}, {'name': 'Nº de Jogadores Previstos', 'id': 'num_jogadores'}],
                data=df_history.to_dict('records'),
                sort_action="native"
            )
        else:
            print(f"Erro ao buscar histórico: {response.json().get('msg')}")
            return dbc.Alert(f"Erro ao buscar histórico: {response.json().get('msg')}", color="danger")
    except requests.exceptions.RequestException as e:
        return dbc.Alert(f"Erro de conexão com o backend: {e}", color="danger")

@app.callback(
    Output('feature-importance-output', 'children'),
    Input('load-analysis-button', 'n_clicks'),
    State('session-store', 'data'),
    prevent_initial_call=True
)
def load_feature_importance(n_clicks, data):
    if not data or not data.get('token'):
        return dbc.Alert("Sessão inválida.", color="danger")

    headers = {'Authorization': f'Bearer {data["token"]}'}
    try:
        response = requests.get(f"{BACKEND_URL}/feature_importance", headers=headers)
        if response.status_code == 200:
            importances = response.json()
            graphs = []
            for target, features in importances.items():
                if not features: continue
                df_importance = pd.DataFrame(features)
                fig = px.bar(df_importance, x='importance', y='feature', orientation='h', title=f"Importância para o {target}")
                fig.update_layout(yaxis={'categoryorder':'total ascending'})
                graphs.append(dcc.Graph(figure=fig))
            return html.Div(graphs) if graphs else dbc.Alert("Nenhuma informação de importância de feature disponível.", color="info")
        else:
            return dbc.Alert(f"Erro ao buscar dados: {response.json().get('msg')}", color="danger")
    except requests.exceptions.RequestException as e:
        return dbc.Alert(f"Erro de conexão com o backend: {e}", color="danger")

# --- CALLBACK DO SHAP (Sem alterações) ---
@app.callback(
    Output('shap-analysis-output', 'children'),
    Input('session-store', 'data') # Dispara quando os resultados da sessão são atualizados
)
def render_shap_analysis(session_data):
    if not session_data or 'last_results' not in session_data or not session_data['last_results']:
        return None

    shap_data = session_data['last_results'].get('shap_data')
    if not shap_data:
        return None # Não renderiza nada se não houver dados SHAP

    # Pega a lista de jogadores (as chaves do dicionário shap_data)
    jogadores = list(shap_data.keys())
    
    return html.Div([
        html.H4("Análise de Contribuição das Features (SHAP)", className="mt-5"),
        html.P("Selecione um jogador para ver como cada feature contribuiu para a sua previsão. Valores positivos empurram a previsão para cima, e valores negativos, para baixo."),
        
        dbc.Row([
            dbc.Col(
                dcc.Dropdown(
                    id='shap-player-dropdown',
                    options=[{'label': j, 'value': j} for j in jogadores],
                    value=jogadores[0], # Seleciona o primeiro jogador por padrão
                    clearable=False
                ),
                width=12, md=6, lg=4
            )
        ], className="mb-4"),

        # Este Div receberá os gráficos do jogador selecionado
        dcc.Loading(html.Div(id='shap-graphs-container'))
    ])

@app.callback(
    Output('shap-graphs-container', 'children'),
    Input('shap-player-dropdown', 'value'),
    State('session-store', 'data')
)
def update_shap_graphs(selected_player, session_data):
    if not selected_player or not session_data or not session_data.get('last_results'):
        return None

    all_predictions = session_data['last_results'].get('predictions', [])
    shap_data = session_data['last_results'].get('shap_data', {})
    
    # Encontra os dados de previsão para o jogador selecionado
    player_predictions = next((p for p in all_predictions if p['Código de Acesso'] == selected_player), None)
    
    # Encontra os dados SHAP para o jogador selecionado
    player_shap_data = shap_data.get(selected_player)

    if not player_shap_data or not player_predictions:
        return dbc.Alert("Dados não encontrados para o jogador selecionado.", color="warning")

    # --- ### NOVA SEÇÃO: CRIAÇÃO DOS CARTÕES DE RESULTADO (KPIs) ### ---
    kpi_cards = dbc.Row([
        dbc.Col(dbc.Card([
            dbc.CardHeader("Previsão Target 1"),
            dbc.CardBody(html.H4(f"{player_predictions.get('Previsão T1', 'N/A')}", className="card-title"))
        ], color="primary", inverse=True), md=4),
        dbc.Col(dbc.Card([
            dbc.CardHeader("Previsão Target 2"),
            dbc.CardBody(html.H4(f"{player_predictions.get('Previsão T2', 'N/A')}", className="card-title"))
        ], color="success", inverse=True), md=4),
        dbc.Col(dbc.Card([
            dbc.CardHeader("Previsão Target 3"),
            dbc.CardBody(html.H4(f"{player_predictions.get('Previsão T3', 'N/A')}", className="card-title"))
        ], color="info", inverse=True), md=4)
    ], className="mb-4")


    # --- Geração dos gráficos de barras SHAP (lógica existente) ---
    graphs = []
    for target_key, data in player_shap_data.items():
        if not all(k in data for k in ['feature_names', 'shap_values']):
            continue
            
        df_shap = pd.DataFrame({
            'feature': data['feature_names'],
            'shap_value': data['shap_values']
        }).sort_values(by='shap_value', key=abs, ascending=False).head(15)

        fig = px.bar(
            df_shap,
            x='shap_value',
            y='feature',
            orientation='h',
            title=f"Contribuições (SHAP) para {target_key} do Jogador: {selected_player}",
            labels={'shap_value': 'Impacto na Previsão', 'feature': 'Feature'}
        )
        fig.update_layout(yaxis={'categoryorder': 'total ascending'})
        graphs.append(dcc.Graph(figure=fig))
    
    # --- Retorna os cartões e os gráficos juntos ---
    return html.Div([kpi_cards] + graphs) if graphs else html.Div(kpi_cards)

if __name__ == '__main__':
    # Use 'debug=False' para produção com Gunicorn
    app.run(debug=True, host='0.0.0.0', port=8050)
</file>

</files>
