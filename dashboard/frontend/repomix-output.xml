This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
dashboard_dash.py
Dockerfile
README.md
requirements.txt
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="dashboard_dash.py">
# dashboard/frontend/dashboard_dash.py (VERS√ÉO ATUALIZADA COMPLETA)

import dash
from dash import dcc, html, dash_table
from dash.dependencies import Input, Output, State
import dash_bootstrap_components as dbc
import requests
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
import os
from io import BytesIO
import base64
import numpy as np

# --- Configura√ß√£o ---
BACKEND_URL = os.getenv('BACKEND_URL', 'http://localhost:5000') 
app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP], suppress_callback_exceptions=True)
app.title = "üéØ Projeto Daruma: Dashboard de Previs√£o"
server = app.server

# =============================================================================
# FUN√á√ïES DE API E UTILIT√ÅRIAS
# =============================================================================

def login_api(username, password):
    try:
        login_data = {'username': username, 'password': password}
        response = requests.post(f"{BACKEND_URL}/login", data=login_data)
        if response.status_code == 200:
            return response.json().get('access_token'), None
        else:
            detail = response.json().get('detail', 'Erro desconhecido no login.')
            return None, detail
    except requests.exceptions.RequestException as e:
        return None, f"Erro de conex√£o com o backend: {e}"

def register_api(username, password):
    try:
        response = requests.post(f"{BACKEND_URL}/register", json={'username': username, 'password': password})
        return (True, response.json().get('msg')) if response.status_code == 201 else (False, response.json().get('msg', 'Erro desconhecido'))
    except requests.exceptions.RequestException as e:
        return False, f"Erro de conex√£o com o backend: {e}"

def parse_contents(contents):
    _, content_string = contents.split(',')
    decoded = base64.b64decode(content_string)
    return decoded

def convert_df_to_excel(df):
    output = BytesIO()
    with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
        df.to_excel(writer, index=False, sheet_name='Previsoes')
    excel_data = output.getvalue()
    return base64.b64encode(excel_data).decode('utf-8')

# =============================================================================
# COMPONENTES DE LAYOUT
# =============================================================================

store = dcc.Store(id='session-store', storage_type='session', data={'logged_in': False, 'token': None, 'username': None, 'last_results': None})
upload_data_store = dcc.Store(id='upload-data-store', storage_type='memory')
cluster_data_store = dcc.Store(id='cluster-data-store', storage_type='memory')

auth_layout = dbc.Container(
    dbc.Row(
        dbc.Col(
            dbc.Card(
                dbc.CardBody([
                    html.H3("üéØ Bem-vindo ao Projeto Daruma", className="text-center mb-4"),
                    dbc.Alert(id='auth-message', color='danger', is_open=False),
                    dbc.RadioItems(id='auth-mode', options=[{'label': 'Login', 'value': 'login'}, {'label': 'Registrar', 'value': 'register'}], value='login', inline=True, className="mb-3 d-flex justify-content-center"),
                    dbc.Input(id='username-input', placeholder='Usu√°rio', type='text', className="mb-3"),
                    dbc.Input(id='password-input', placeholder='Senha', type='password', className="mb-3"),
                    dbc.Button("Acessar", id='auth-button', color='primary', n_clicks=0, className="w-100")
                ])
            ), width=4
        ), justify="center", align="center", className="vh-100"
    ), fluid=True
)

# --- LAYOUT ATUALIZADO COM AS NOVAS ABAS ---
main_dashboard_layout = dbc.Container([
    dbc.Row([
        dbc.Col(html.H2("üéØ Projeto Daruma: Dashboard de Previs√£o"), width='auto'),
        dbc.Col(html.Div(id='welcome-user-message'), className="text-center my-auto"),
        dbc.Col(dbc.Button("Logout", id='logout-button', color='danger'), width='auto', className="ms-auto")
    ], className="mb-4 align-items-center"),
    
    dbc.Tabs([
        # Aba 1: Previs√£o Individual
        dbc.Tab(label="üìä Nova Previs√£o", tab_id="predict-tab", children=[
            dcc.Upload(
                id='upload-data',
                children=html.Div(['Arraste e solte ou ', html.A('Selecione um Arquivo Excel (.xlsx)')]),
                style={'width': '100%', 'height': '60px', 'lineHeight': '60px', 'borderWidth': '1px', 'borderStyle': 'dashed', 'borderRadius': '5px', 'textAlign': 'center', 'margin': '20px 0'},
                multiple=False
            ),
            html.Div(id='upload-status', className="mb-3"),
            dbc.Button("Executar An√°lise Completa", id='predict-button', color='success', className="mb-4", disabled=True),
            dcc.Loading(id="loading-output", type="default", children=[
                html.Div(id='prediction-results-output'),
                html.Div(id='shap-analysis-output', className="mt-4")
            ])
        ]),
        
        # NOVA ABA 2: Vis√£o Geral das Previs√µes
        dbc.Tab(label="üìà Vis√£o Geral das Previs√µes", tab_id="overview-tab", children=[
            dcc.Loading(id="loading-overview", children=html.Div(id='overview-output', className="mt-3"))
        ]),

        # NOVA ABA 3: An√°lise de Perfis (Clustering)
        dbc.Tab(label="üß¨ An√°lise de Perfis", tab_id="clustering-tab", children=[
            dcc.Loading(id="loading-clustering", children=html.Div(id='clustering-output', className="mt-3"))
        ]),

        # NOVA ABA 4: Performance do Modelo
        dbc.Tab(label="üî¨ Performance do Modelo", tab_id="performance-tab", children=[
            html.Div(id='performance-output', className="mt-3")
        ]),

        # Aba 5: An√°lise de Features
        dbc.Tab(label="üß† An√°lise de Features", tab_id="analysis-tab", children=[
            html.H3("Ranking de Import√¢ncia das Features", className="mt-3"),
            html.P("Este gr√°fico mostra as 20 features mais importantes que o modelo utiliza para fazer as previs√µes para cada target."),
            dcc.Loading(id="loading-analysis", children=html.Div(id='feature-importance-output'))
        ]),

        # Aba 6: Hist√≥rico
        dbc.Tab(label="‚è≥ Hist√≥rico", tab_id="history-tab", children=[
            html.H3("Hist√≥rico de Uploads", className="mt-3"),
            dcc.Loading(id="loading-history", children=html.Div(id='history-output'))
        ]),
    ], id="tabs", active_tab="predict-tab"),
], fluid=True)


app.layout = html.Div([dcc.Location(id='url', refresh=False), store, upload_data_store, cluster_data_store, html.Div(id='page-content')])

# =============================================================================
# CALLBACKS DE CONTROLE E AUTENTICA√á√ÉO
# =============================================================================

@app.callback(
    Output('page-content', 'children'),
    [Input('session-store', 'data'), Input('url', 'pathname')]
)
def render_page_content(data, pathname):
    is_logged_in = data and data.get('logged_in')
    if is_logged_in:
        return main_dashboard_layout
    else:
        return auth_layout

@app.callback(
    [Output('url', 'pathname', allow_duplicate=True), Output('session-store', 'data'), Output('auth-message', 'children'), Output('auth-message', 'is_open')],
    [Input('auth-button', 'n_clicks')],
    [State('auth-mode', 'value'), State('username-input', 'value'), State('password-input', 'value'), State('session-store', 'data')],
    prevent_initial_call=True
)
def handle_auth(n_clicks, auth_mode, username, password, data):
    if not username or not password:
        return dash.no_update, dash.no_update, "Usu√°rio e senha s√£o obrigat√≥rios.", True
    if auth_mode == 'login':
        token, error = login_api(username, password)
        if token:
            data.update({'logged_in': True, 'token': token, 'username': username})
            return '/', data, "", False
        return dash.no_update, dash.no_update, error, True
    elif auth_mode == 'register':
        success, message = register_api(username, password)
        return dash.no_update, dash.no_update, message, True
    return dash.no_update, dash.no_update, "", False

@app.callback(Output('welcome-user-message', 'children'), Input('session-store', 'data'))
def update_welcome_message(data):
    return f"Bem-vindo(a), {data.get('username')}!" if data and data.get('logged_in') else ""

@app.callback(
    [Output('url', 'pathname', allow_duplicate=True), Output('session-store', 'data', allow_duplicate=True)],
    [Input('logout-button', 'n_clicks')],
    [State('session-store', 'data')], prevent_initial_call=True
)
def handle_logout(n_clicks, data):
    if n_clicks:
        data.update({'logged_in': False, 'token': None, 'username': None, 'last_results': None})
        return '/', data
    return dash.no_update, dash.no_update

@app.callback(
    [Output('upload-data-store', 'data'), Output('upload-status', 'children'), Output('predict-button', 'disabled')],
    [Input('upload-data', 'contents')],
    [State('upload-data', 'filename')], prevent_initial_call=True
)
def handle_upload(contents, filename):
    if contents:
        decoded_content = parse_contents(contents)
        stored_data = {'filename': filename, 'contents': base64.b64encode(decoded_content).decode('utf-8')}
        return stored_data, html.Div(['Arquivo selecionado: ', html.B(filename)]), False
    return None, "", True

# =============================================================================
# CALLBACK PRINCIPAL (PREVIS√ÉO E CLUSTERING) - VERS√ÉO CORRIGIDA
# =============================================================================

@app.callback(
    [
        Output('prediction-results-output', 'children'),
        Output('session-store', 'data', allow_duplicate=True),
        Output('cluster-data-store', 'data', allow_duplicate=True),
        Output('overview-output', 'children'),
        Output('clustering-output', 'children'),
        Output('performance-output', 'children'),
        Output('feature-importance-output', 'children'),
        Output('history-output', 'children'),
        Output('tabs', 'active_tab')
    ],
    [Input('predict-button', 'n_clicks')],
    [State('session-store', 'data'), State('upload-data-store', 'data')],
    prevent_initial_call=True
)
def run_full_analysis(n_clicks, session_data, upload_data):
    from dash.exceptions import PreventUpdate
    
    # üî• VERIFICA√á√ïES DE SEGURAN√áA
    if not n_clicks or not upload_data or not session_data:
        raise PreventUpdate
    
    if not session_data.get('token'):
        error_alert = dbc.Alert("‚ùå Token de autentica√ß√£o n√£o encontrado. Fa√ßa login novamente.", color="danger")
        # Retorna o alerta para o primeiro output e no_update para os outros
        return error_alert, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, "predict-tab"

    headers = {'Authorization': f'Bearer {session_data["token"]}'}
    files = {'file': (upload_data['filename'], base64.b64decode(upload_data['contents']), 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')}
    
    # 1. Chamar API de Previs√£o
    try:
        response_pred = requests.post(f"{BACKEND_URL}/predict", headers=headers, files=files)
        if response_pred.status_code != 200:
            msg = f"Erro na API de Previs√£o: {response_pred.json().get('detail')}"
            error_alert = dbc.Alert(msg, color="danger")
            return error_alert, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, "predict-tab"
        
        results_data = response_pred.json()
        session_data['last_results'] = results_data
        
    except requests.exceptions.RequestException as e:
        error_alert = dbc.Alert(f"Erro de conex√£o com o backend: {e}", color="danger")
        return error_alert, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, "predict-tab"
    
    # 2. Chamar API de Clustering
    # Recria o dicion√°rio de arquivos para garantir que a leitura comece do in√≠cio
    files_cluster = {'file': (upload_data['filename'], base64.b64decode(upload_data['contents']), 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')}
    try:
        response_cluster = requests.post(f"{BACKEND_URL}/clustering", headers=headers, files=files_cluster)
        if response_cluster.status_code != 200:
            cluster_data = None
            clustering_layout = dbc.Alert(f"‚ö†Ô∏è Clustering n√£o dispon√≠vel: {response_cluster.json().get('detail')}", color="warning")
        else:
            cluster_data = response_cluster.json()
            clustering_layout = render_clustering_results(cluster_data)
            
    except requests.exceptions.RequestException as e:
        cluster_data = None
        clustering_layout = dbc.Alert(f"‚ö†Ô∏è Erro no clustering: {e}", color="warning")
    
    # 3. Gerar todos os outputs COM PROTE√á√ÉO
    try:
        predictions_list = results_data.get('predictions', [])
        
        # üî• GARANTIR QUE OS DADOS EXISTEM ANTES DE RENDERIZAR
        prediction_layout = render_prediction_results(predictions_list) if predictions_list else dbc.Alert("Nenhuma previs√£o dispon√≠vel.", color="warning")
        overview_layout = render_overview_results(predictions_list) if predictions_list else dbc.Alert("Nenhum dado para vis√£o geral.", color="warning")
        performance_layout = render_performance_results()
        
        # Carregar dados das abas "pregui√ßosas"
        feat_importance_layout = get_feature_importance_layout(headers)
        history_layout = get_history_layout(headers)

        return (
            prediction_layout, 
            session_data, 
            cluster_data, 
            overview_layout, 
            clustering_layout, 
            performance_layout,
            feat_importance_layout,
            history_layout,
            'overview-tab'
        )
        
    except Exception as e:
        error_msg = f"Erro na renderiza√ß√£o dos resultados: {str(e)}"
        print(f"‚ùå ERRO NO CALLBACK: {error_msg}")
        error_alert = dbc.Alert(f"‚ùå Erro interno ao processar os dados: {error_msg}", color="danger")
        return error_alert, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, "predict-tab"


# =============================================================================
# FUN√á√ïES DE RENDERIZA√á√ÉO DAS ABAS
# =============================================================================

def render_prediction_results(predictions_data):
    if not predictions_data:
        return dbc.Alert("Nenhuma previs√£o retornada.", color="warning")
    
    try:
        df_output = pd.DataFrame(predictions_data)
        excel_base64 = convert_df_to_excel(df_output)

        return html.Div([
            html.H4("Resultados da Previs√£o", className="mt-4"),
            dash_table.DataTable(
                id='predictions-table',
                columns=[{"name": i, "id": i} for i in df_output.columns],
                data=df_output.to_dict('records'),
                style_table={'overflowX': 'auto'},
                sort_action="native", filter_action="native", page_action="native",
                page_current=0, page_size=10,
                style_header={'backgroundColor': 'rgb(230, 230, 230)', 'fontWeight': 'bold'}
            ),
            html.A(dbc.Button("üì• Baixar Resultados (.xlsx)", color="info", className="mt-3"), id='download-link',
                   href=f"data:application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;base64,{excel_base64}",
                   download="previsoes_daruma.xlsx")
        ])
    except Exception as e:
        return dbc.Alert(f"Erro ao processar dados de previs√£o: {e}", color="danger")


def render_overview_results(predictions_data):
    if not predictions_data:
        return dbc.Alert("Dados de previs√£o n√£o dispon√≠veis.", color="warning")
    
    try:
        df = pd.DataFrame(predictions_data)
        
        # KPIs
        kpis = dbc.Row([
            dbc.Col(dbc.Card([dbc.CardHeader("Total de Jogadores"), dbc.CardBody(html.H2(f"{len(df)}", className="text-center"))], color="primary", inverse=True)),
            dbc.Col(dbc.Card([dbc.CardHeader("M√©dia Target 1"), dbc.CardBody(html.H2(f"{df['Previs√£o T1'].mean():.2f}", className="text-center"))], color="success", inverse=True)),
            dbc.Col(dbc.Card([dbc.CardHeader("M√©dia Target 2"), dbc.CardBody(html.H2(f"{df['Previs√£o T2'].mean():.2f}", className="text-center"))], color="info", inverse=True)),
            dbc.Col(dbc.Card([dbc.CardHeader("M√©dia Target 3"), dbc.CardBody(html.H2(f"{df['Previs√£o T3'].mean():.2f}", className="text-center"))], color="secondary", inverse=True)),
        ])
        
        # Histogramas
        fig_hist = px.histogram(df.melt(id_vars=['C√≥digo de Acesso'], value_vars=['Previs√£o T1', 'Previs√£o T2', 'Previs√£o T3']),
                            x="value", color="variable", facet_col="variable",
                            title="Distribui√ß√£o das Previs√µes por Target")
        fig_hist.update_xaxes(matches=None) # Eixos X independentes
        
        # Box plots
        fig_box = px.box(df[['Previs√£o T1', 'Previs√£o T2', 'Previs√£o T3']], title="Box Plot Comparativo dos Targets")
        
        # Heatmap
        corr = df[['Previs√£o T1', 'Previs√£o T2', 'Previs√£o T3']].corr()
        fig_heatmap = go.Figure(data=go.Heatmap(z=corr.values, x=corr.columns, y=corr.columns, colorscale='Viridis'))
        fig_heatmap.update_layout(title="Heatmap de Correla√ß√£o entre Targets Previstos")
        
        return html.Div([kpis,
                        dcc.Graph(figure=fig_hist),
                        dbc.Row([dbc.Col(dcc.Graph(figure=fig_box), md=6),
                                dbc.Col(dcc.Graph(figure=fig_heatmap), md=6)])
                        ])
    except Exception as e:
        return dbc.Alert(f"Erro ao renderizar a vis√£o geral: {e}", color="danger")

    
def render_clustering_results(cluster_data):
    if not cluster_data:
        return dbc.Alert("Dados de clustering n√£o dispon√≠veis.", color="warning")
    
    try:
        df_pca = pd.DataFrame(cluster_data['pca_coords'], columns=['PC1', 'PC2'])
        df_pca['Cluster'] = [f"Cluster {c}" for c in cluster_data['clusters']]
        df_pca['Jogador'] = cluster_data['jogadores']
        
        fig_pca = px.scatter(df_pca, x='PC1', y='PC2', color='Cluster', hover_name='Jogador',
                            title="Visualiza√ß√£o dos Perfis de Jogadores (PCA + K-Means)")
        
        # Cards de Estat√≠sticas
        stats_cards = []
        for cluster_id, stats in cluster_data['stats'].items():
            percentage = cluster_data['counts'].get(str(cluster_id), 0) * 100
            stats_cards.append(dbc.Col(dbc.Card([
                dbc.CardHeader(f"üìä Cluster {cluster_id} ({percentage:.1f}% dos jogadores)"),
                dbc.CardBody([
                    html.P(f"‚Ä¢ Performance m√©dia (P_mean): {stats.get('P_mean', 0):.2f}"),
                    html.P(f"‚Ä¢ M√©dia Target 1: {stats.get('Target1', 0):.2f}"),
                    html.P(f"‚Ä¢ M√©dia Target 2: {stats.get('Target2', 0):.2f}"),
                    html.P(f"‚Ä¢ M√©dia Target 3: {stats.get('Target3', 0):.2f}"),
                ])
            ])))
            
        return html.Div([
            html.H3("An√°lise de Perfis (Clustering)"),
            dbc.Row(stats_cards, className="mb-4"),
            dcc.Graph(figure=fig_pca)
        ])
    except Exception as e:
        return dbc.Alert(f"Erro ao renderizar os resultados do clustering: {e}", color="danger")


def render_performance_results():
    # M√©tricas est√°ticas baseadas no seu pedido
    metrics = {
        'Target 1': {'R¬≤ LOO-CV': 0.5558, 'Overfitting': 11.0, 'Features': 33},
        'Target 2': {'R¬≤ LOO-CV': 0.4137, 'Overfitting': 14.2, 'Features': 13},
        'Target 3': {'R¬≤ LOO-CV': 0.4285, 'Overfitting': -1.0, 'Features': 16}
    }
    
    cards = []
    for target, data in metrics.items():
        cards.append(dbc.Col(dbc.Card([
            dbc.CardHeader(f"üéØ {target}"),
            dbc.CardBody([
                html.P(f"‚Ä¢ R¬≤ LOO-CV: {data['R¬≤ LOO-CV']:.4f} ‚≠ê"),
                html.P(f"‚Ä¢ Overfitting: {data['Overfitting']:.1f}%"),
                html.P(f"‚Ä¢ Features: {data['Features']}"),
            ])
        ], color="light")))
        
    df_perf = pd.DataFrame(metrics).T.reset_index().rename(columns={'index': 'Target'})
    fig_r2 = px.bar(df_perf, x='R¬≤ LOO-CV', y='Target', orientation='h', title="Comparativo de Performance (R¬≤)")
        
    return html.Div([
        html.H3("Performance dos Modelos em Valida√ß√£o Cruzada"),
        dbc.Row(cards, className="mb-4"),
        dcc.Graph(figure=fig_r2)
    ])


# =============================================================================
# CALLBACKS "PREGUI√áOSOS" (Para abas que n√£o dependem do upload)
# =============================================================================

def get_history_layout(headers):
    try:
        response = requests.get(f"{BACKEND_URL}/history", headers=headers)
        if response.status_code == 200:
            history_data = response.json()
            if not history_data:
                return dbc.Alert("Nenhum hist√≥rico encontrado.", color="info")
            df_history = pd.DataFrame(history_data)
            return dash_table.DataTable(
                columns=[{'name': 'Data do Upload', 'id': 'timestamp'}, {'name': 'N¬∫ de Jogadores Previstos', 'id': 'num_jogadores'}],
                data=df_history.to_dict('records'), sort_action="native"
            )
        else:
            return dbc.Alert(f"Erro ao buscar hist√≥rico: {response.json().get('detail')}", color="danger")
    except requests.exceptions.RequestException as e:
        return dbc.Alert(f"Erro de conex√£o com o backend: {e}", color="danger")

def get_feature_importance_layout(headers):
    try:
        response = requests.get(f"{BACKEND_URL}/feature_importance", headers=headers)
        if response.status_code == 200:
            importances = response.json()
            graphs = []
            for target, features in importances.items():
                if not features: continue
                df_importance = pd.DataFrame(features)
                fig = px.bar(df_importance, x='importance', y='feature', orientation='h', title=f"Import√¢ncia para o {target}")
                fig.update_layout(yaxis={'categoryorder':'total ascending'})
                graphs.append(dcc.Graph(figure=fig))
            return html.Div(graphs) if graphs else dbc.Alert("Nenhuma informa√ß√£o dispon√≠vel.", color="info")
        else:
            return dbc.Alert(f"Erro ao buscar dados: {response.json().get('detail')}", color="danger")
    except requests.exceptions.RequestException as e:
        return dbc.Alert(f"Erro de conex√£o com o backend: {e}", color="danger")

# =============================================================================
# CALLBACKS DE INTERATIVIDADE (SHAP)
# =============================================================================

@app.callback(
    Output('shap-analysis-output', 'children'),
    Input('session-store', 'data')
)
def render_shap_analysis(session_data):
    if not session_data or 'last_results' not in session_data or not session_data['last_results']:
        return None
    shap_data = session_data['last_results'].get('shap_data')
    if not shap_data:
        return None
    jogadores = list(shap_data.keys())
    return html.Div([
        html.H4("An√°lise de Contribui√ß√£o das Features (SHAP)", className="mt-5"),
        html.P("Selecione um jogador para ver como cada feature contribuiu para a sua previs√£o."),
        dbc.Row([dbc.Col(dcc.Dropdown(id='shap-player-dropdown', options=[{'label': j, 'value': j} for j in jogadores], value=jogadores[0], clearable=False), width=12, md=6, lg=4)], className="mb-4"),
        dcc.Loading(html.Div(id='shap-graphs-container'))
    ])

@app.callback(
    Output('shap-graphs-container', 'children'),
    Input('shap-player-dropdown', 'value'),
    State('session-store', 'data')
)
def update_shap_graphs(selected_player, session_data):
    if not selected_player or not session_data or not session_data.get('last_results'):
        return None
    all_predictions = session_data['last_results'].get('predictions', [])
    shap_data = session_data['last_results'].get('shap_data', {})
    player_predictions = next((p for p in all_predictions if str(p['C√≥digo de Acesso']) == str(selected_player)), None)
    player_shap_data = shap_data.get(str(selected_player))
    if not player_shap_data or not player_predictions:
        return dbc.Alert("Dados n√£o encontrados para o jogador selecionado.", color="warning")

    kpi_cards = dbc.Row([
        dbc.Col(dbc.Card([dbc.CardHeader("Previs√£o Target 1"), dbc.CardBody(html.H4(f"{player_predictions.get('Previs√£o T1', 'N/A')}", className="card-title"))], color="primary", inverse=True), md=4),
        dbc.Col(dbc.Card([dbc.CardHeader("Previs√£o Target 2"), dbc.CardBody(html.H4(f"{player_predictions.get('Previs√£o T2', 'N/A')}", className="card-title"))], color="success", inverse=True), md=4),
        dbc.Col(dbc.Card([dbc.CardHeader("Previs√£o Target 3"), dbc.CardBody(html.H4(f"{player_predictions.get('Previs√£o T3', 'N/A')}", className="card-title"))], color="info", inverse=True), md=4)
    ], className="mb-4")

    graphs = []
    for target_key, data in player_shap_data.items():
        if not all(k in data for k in ['feature_names', 'shap_values']): continue
        df_shap = pd.DataFrame({'feature': data['feature_names'], 'shap_value': data['shap_values']}).sort_values(by='shap_value', key=abs, ascending=False).head(15)
        fig = px.bar(df_shap, x='shap_value', y='feature', orientation='h', title=f"Contribui√ß√µes (SHAP) para {target_key}", labels={'shap_value': 'Impacto na Previs√£o', 'feature': 'Feature'})
        fig.update_layout(yaxis={'categoryorder': 'total ascending'})
        graphs.append(dcc.Graph(figure=fig))
    
    return html.Div([kpi_cards] + graphs) if graphs else html.Div(kpi_cards)

# =============================================================================
# EXECU√á√ÉO DO SERVIDOR
# =============================================================================
if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=8050)
</file>

<file path="Dockerfile">
FROM python:3.10-slim

WORKDIR /app

# Instala depend√™ncias
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copia o c√≥digo da aplica√ß√£o
COPY dashboard_dash.py .

# Expor a porta do Dash (8050 √© o padr√£o do Plotly Dash)
EXPOSE 8050

# Comando para rodar a aplica√ß√£o Dash
# O Dash √© executado como um script Python normal (dashboard_dash.py), 
# onde a porta 8050 e o host 0.0.0.0 j√° est√£o definidos internamente.
CMD ["python", "dashboard_dash.py"]
</file>

<file path="README.md">
# Frontend Dashboard (Plotly Dash)

Este √© um dashboard interativo constru√≠do com Plotly Dash para fornecer uma interface amig√°vel para o sistema de previs√£o.

## Funcionalidades

O dashboard √© dividido em abas:

1.  **Nova Previs√£o:**
    -   Permite o upload de um arquivo `.xlsx` com novos dados de jogadores.
    -   Exibe os resultados em uma tabela interativa (orden√°vel, filtr√°vel) e em gr√°ficos de barras comparativos.
    -   Disponibiliza um bot√£o para download dos resultados.
    -   Apresenta uma se√ß√£o de an√°lise SHAP, onde √© poss√≠vel selecionar um jogador e visualizar gr√°ficos que explicam sua previs√£o.

2.  **An√°lise do Modelo:**
    -   Exibe gr√°ficos de barras horizontais mostrando as 20 features mais importantes para cada um dos 3 modelos de target.

3.  **Hist√≥rico:**
    -   Mostra uma tabela com o hist√≥rico de uploads de arquivos realizados pelo usu√°rio, incluindo data e quantidade de jogadores previstos em cada lote.
</file>

<file path="requirements.txt">
requests # Para fazer chamadas HTTP ao Flask
pandas
plotly-express
plotly
xlsxwriter
shap
matplotlib
dash 
dash-bootstrap-components 
dash-core-components 
dash-html-components 
dash-table 
numpy 
shap
</file>

</files>
